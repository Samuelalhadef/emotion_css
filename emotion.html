<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Demain, dès l'aube... - Vision cubiste</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500;600&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      background-color: #121212;
      font-family: 'Cormorant Garamond', serif;
      color: #fff;
      position: relative;
      height: 100vh;
      width: 100vw;
    }
    
    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    
    #intro {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: radial-gradient(circle, rgba(30,30,46,0.95) 0%, rgba(10,10,20,0.98) 100%);
      z-index: 1000;
      transition: opacity 2s ease-in-out;
    }
    
    #intro h1 {
      font-size: 3.5rem;
      font-weight: 300;
      margin-bottom: 1.5rem;
      letter-spacing: 3px;
      color: #e0e0e0;
      text-align: center;
    }
    
    #intro p {
      font-size: 1.2rem;
      max-width: 600px;
      text-align: center;
      line-height: 1.6;
      margin-bottom: 2rem;
      color: #b0b0b0;
      padding: 0 20px;
    }
    
    #start-button {
      padding: 12px 30px;
      background: transparent;
      border: 1px solid #b0b0b0;
      color: #e0e0e0;
      font-size: 1rem;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: inherit;
    }
    
    #start-button:hover {
      background: rgba(255,255,255,0.1);
      transform: scale(1.05);
    }
    
    #poem-container {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    
    .poem-line {
      font-size: 1.8rem;
      line-height: 1.5;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 2s ease, transform 2s ease;
      text-align: center;
      max-width: 80%;
      text-shadow: 0 0 10px rgba(0,0,0,0.7);
    }
    
    .poem-line.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .controls {
      position: absolute;
      bottom: 30px;
      width: 100%;
      display: flex;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .control-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      margin: 0 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .control-dot.active {
      background: rgba(255,255,255,0.9);
      transform: scale(1.3);
    }
    
    .progress-container {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 2px;
      background: rgba(255,255,255,0.1);
      z-index: 100;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .progress-bar {
      height: 100%;
      width: 0;
      background: rgba(255,255,255,0.5);
      transition: width 0.5s linear;
    }
    
    .scene-title {
      position: absolute;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      letter-spacing: 3px;
      color: rgba(255,255,255,0.7);
      text-shadow: 0 0 10px rgba(0,0,0,0.5);
      opacity: 0;
      transition: opacity 1s ease;
      z-index: 100;
      text-align: center;
      width: 100%;
    }
    
    @keyframes floatElement {
      0% { transform: translate(0, 0) rotate(0deg); }
      50% { transform: translate(5px, -5px) rotate(1deg); }
      100% { transform: translate(0, 0) rotate(0deg); }
    }
    
    @keyframes pulseGlow {
      0% { filter: drop-shadow(0 0 5px rgba(255,255,255,0.3)); }
      50% { filter: drop-shadow(0 0 15px rgba(255,255,255,0.5)); }
      100% { filter: drop-shadow(0 0 5px rgba(255,255,255,0.3)); }
    }
    
    #loading {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #121212;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      transition: opacity 1s ease;
    }
    
    .loader {
      width: 60px;
      height: 60px;
      border: 3px solid rgba(255,255,255,0.1);
      border-radius: 50%;
      border-top-color: rgba(255,255,255,0.8);
      animation: spin 1s infinite linear;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .audio-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 200;
      display: flex;
      align-items: center;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .volume-slider {
      -webkit-appearance: none;
      width: 80px;
      height: 4px;
      background: rgba(255, 255, 255, 0.2);
      outline: none;
      border-radius: 2px;
      margin-right: 8px;
      transition: opacity 0.3s;
    }
    
    .volume-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
    }
    
    .volume-slider::-moz-range-thumb {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: none;
    }
    
    .mute-button {
      background: none;
      border: none;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.3s;
      display: flex;
      justify-content: center;
      align-items: center;
      width: 30px;
      height: 30px;
    }
    
    .mute-button:hover {
      opacity: 1;
    }
    
    .click-hint {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.5);
      opacity: 0;
      transition: opacity 1s ease;
      z-index: 100;
      text-align: center;
      pointer-events: none;
    }
    
    #magic-circle {
      position: absolute;
      pointer-events: none;
      width: 40px;
      height: 40px;
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: 150;
      opacity: 0;
      transition: width 0.3s, height 0.3s, opacity 0.3s;
    }
    
    @keyframes ripple {
      0% { transform: scale(0); opacity: 1; }
      100% { transform: scale(1.5); opacity: 0; }
    }
    
    .ripple {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.4);
      transform: scale(0);
      animation: ripple 1s linear;
    }
    
    .author-credit {
      position: absolute;
      bottom: 10px;
      width: 100%;
      text-align: center;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.4);
      z-index: 100;
      pointer-events: none;
    }
    
    @media (max-width: 768px) {
      #intro h1 {
        font-size: 2.5rem;
      }
      
      #intro p {
        font-size: 1rem;
      }
      
      .poem-line {
        font-size: 1.4rem;
      }
      
      .audio-controls {
        top: 10px;
        right: 10px;
      }
      
      .volume-slider {
        width: 60px;
      }
    }
  </style>
</head>
<script>
    /**
     * Solution complète pour l'animation cubiste de "Demain, dès l'aube..."
     * Cette solution remplace intégralement la logique d'origine
     */
    document.addEventListener('DOMContentLoaded', function() {
      // ------------------ CONFIGURATION ------------------
      // Données du poème et des scènes
      const sceneData = [
        {
          title: "L'Aube",
          lines: [
            "Demain, dès l'aube, à l'heure où blanchit la campagne,",
            "Je partirai. Vois-tu, je sais que tu m'attends."
          ],
          background: "#1A1A2E",
          primary: "#3B4D7B",
          secondary: "#A68DAD",
          accent: "#F7C59F"
        },
        {
          title: "Le Voyage",
          lines: [
            "J'irai par la forêt, j'irai par la montagne.",
            "Je ne puis demeurer loin de toi plus longtemps."
          ],
          background: "#1E2639",
          primary: "#2C5F60",
          secondary: "#68A691",
          accent: "#E0AB94"
        },
        {
          title: "La Solitude",
          lines: [
            "Je marcherai les yeux fixés sur mes pensées,",
            "Sans rien voir au dehors, sans entendre aucun bruit,"
          ],
          background: "#232331",
          primary: "#455561",
          secondary: "#7B6D8D",
          accent: "#D8B4A0"
        },
        {
          title: "Le Cheminement",
          lines: [
            "Seul, inconnu, le dos courbé, les mains croisées,",
            "Triste, et le jour pour moi sera comme la nuit."
          ],
          background: "#28293D",
          primary: "#484D6D",
          secondary: "#8A817C",
          accent: "#BCB6FF"
        },
        {
          title: "L'Indifférence",
          lines: [
            "Je ne regarderai ni l'or du soir qui tombe,",
            "Ni les voiles au loin descendant vers Harfleur,"
          ],
          background: "#2A2B3D",
          primary: "#5E4B56",
          secondary: "#9C8CB0",
          accent: "#F1AB86"
        },
        {
          title: "L'Arrivée",
          lines: [
            "Et quand j'arriverai, je mettrai sur ta tombe",
            "Un bouquet de houx vert et de bruyère en fleur."
          ],
          background: "#1D1D2C",
          primary: "#58355E",
          secondary: "#7D6B7D",
          accent: "#D8A7B0"
        }
      ];
    
      // ------------------ VARIABLES GLOBALES ------------------
      let currentSceneIndex = 0;
      let isTransitioning = false;
      let animationFrame = null;
      let autoAdvanceTimer = null;
      let particles = [];
      let shapes = [];
      let audioContext = null;
      let masterGain = null;
      let isMuted = false;
      let ambientSounds = [];
      let backgroundMusic = null;
    
      // ------------------ ACCÈS AUX ÉLÉMENTS DOM ------------------
      // Masquer immédiatement l'écran de chargement
      const loadingScreen = document.getElementById('loading');
      if (loadingScreen) {
        loadingScreen.style.opacity = '0';
        setTimeout(() => { loadingScreen.style.display = 'none'; }, 1000);
      }
    
      // Obtenir les éléments principaux
      const canvases = {
        bg: document.getElementById('bg-canvas'),
        main: document.getElementById('main-canvas'),
        particles: document.getElementById('particle-canvas'),
        interactive: document.getElementById('interactive-canvas')
      };
      
      const contexts = {};
      // Initialiser les contextes de canvas s'ils existent
      Object.keys(canvases).forEach(key => {
        if (canvases[key]) {
          contexts[key] = canvases[key].getContext('2d');
        }
      });
    
      const elements = {
        intro: document.getElementById('intro'),
        startButton: document.getElementById('start-button'),
        poemContainer: document.getElementById('poem-container'),
        sceneTitle: document.getElementById('scene-title'),
        controls: document.getElementById('controls'),
        progressContainer: document.getElementById('progress-container'),
        progressBar: document.getElementById('progress-bar'),
        audioControls: document.getElementById('audio-controls'),
        volumeSlider: document.getElementById('volume-slider'),
        muteButton: document.getElementById('mute-button'),
        clickHint: document.getElementById('click-hint'),
        magicCircle: document.getElementById('magic-circle')
      };
    
      // ------------------ FONCTIONS UTILITAIRES ------------------
      // Convertir une couleur hexadécimale en RGB
      function hexToRgb(hex) {
        hex = hex.replace('#', '');
        if (hex.length === 3) {
          hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        return `${r}, ${g}, ${b}`;
      }
    
      // Redimensionner les canvas
      function resizeCanvases() {
        Object.keys(canvases).forEach(key => {
          const canvas = canvases[key];
          if (canvas) {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
          }
        });
        
        // Redessiner le fond après redimensionnement
        drawBackground();
        generateShapes();
      }
    
      // Créer des particules pour l'arrière-plan
      function createParticles() {
        const count = 50;
        particles = [];
        
        for (let i = 0; i < count; i++) {
          const scene = sceneData[currentSceneIndex];
          const colorPool = [scene.primary, scene.secondary, scene.accent];
          const color = colorPool[Math.floor(Math.random() * colorPool.length)];
          
          particles.push({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            size: Math.random() * 3 + 1,
            speedX: (Math.random() - 0.5) * 0.5,
            speedY: (Math.random() - 0.5) * 0.5,
            color: color,
            opacity: Math.random() * 0.5 + 0.2
          });
        }
      }
    
      // ------------------ FONCTIONS DE DESSIN ------------------
      // Dessiner l'arrière-plan
      function drawBackground() {
        const ctx = contexts.bg;
        if (!ctx) return;
        
        const scene = sceneData[currentSceneIndex];
        
        // Effacer le canvas
        ctx.clearRect(0, 0, canvases.bg.width, canvases.bg.height);
        
        // Dessiner le fond
        ctx.fillStyle = scene.background;
        ctx.fillRect(0, 0, canvases.bg.width, canvases.bg.height);
        
        // Ajouter des formes géométriques
        const shapesCount = 15;
        for (let i = 0; i < shapesCount; i++) {
          const colorChoice = Math.random();
          let color;
          
          if (colorChoice < 0.4) {
            color = scene.primary;
          } else if (colorChoice < 0.8) {
            color = scene.secondary;
          } else {
            color = scene.accent;
          }
          
          const opacity = Math.random() * 0.2 + 0.05;
          const size = Math.random() * canvases.bg.width * 0.3 + 100;
          const x = Math.random() * canvases.bg.width;
          const y = Math.random() * canvases.bg.height;
          
          ctx.fillStyle = `rgba(${hexToRgb(color)}, ${opacity})`;
          
          // Dessiner des formes aléatoires (cubistes)
          if (Math.random() < 0.6) {
            // Polygone
            const sides = Math.floor(Math.random() * 3) + 3;
            const angle = Math.random() * Math.PI * 2;
            
            ctx.beginPath();
            for (let j = 0; j <= sides; j++) {
              const a = j * (Math.PI * 2) / sides + angle;
              const radius = size * (0.7 + Math.random() * 0.3);
              
              if (j === 0) {
                ctx.moveTo(x + radius * Math.cos(a), y + radius * Math.sin(a));
              } else {
                ctx.lineTo(x + radius * Math.cos(a), y + radius * Math.sin(a));
              }
            }
            ctx.closePath();
            ctx.fill();
          } else {
            // Rectangle avec rotation
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.random() * Math.PI / 2);
            
            const width = size * (0.5 + Math.random() * 0.5);
            const height = size * (0.5 + Math.random() * 0.5);
            
            ctx.fillRect(-width/2, -height/2, width, height);
            ctx.restore();
          }
        }
      }
    
      // Générer les formes principales pour la scène courante
      function generateShapes() {
        shapes = [];
        const scene = sceneData[currentSceneIndex];
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Ajouter des formes selon la scène
        switch (currentSceneIndex) {
          case 0: // L'Aube
            // Ajouter un soleil
            shapes.push({
              type: 'sun',
              x: width * 0.5,
              y: height * 0.3,
              size: width * 0.15,
              color: scene.accent,
              offset: Math.random() * Math.PI * 2
            });
            
            // Ajouter des champs (horizon)
            for (let i = 0; i < 10; i++) {
              shapes.push({
                type: 'field',
                x: width * Math.random(),
                y: height * (0.6 + Math.random() * 0.3),
                width: width * (0.1 + Math.random() * 0.2),
                height: height * 0.1,
                color: Math.random() < 0.5 ? scene.primary : scene.secondary,
                offset: Math.random() * Math.PI * 2
              });
            }
            break;
            
          case 1: // Le Voyage
            // Montagnes
            for (let i = 0; i < 5; i++) {
              shapes.push({
                type: 'mountain',
                x: width * (0.2 + i * 0.15),
                y: height * 0.5,
                size: width * (0.1 + Math.random() * 0.1),
                color: i % 2 === 0 ? scene.primary : scene.secondary,
                offset: Math.random() * Math.PI * 2
              });
            }
            
            // Arbres (forêt)
            for (let i = 0; i < 8; i++) {
              shapes.push({
                type: 'tree',
                x: width * (0.1 + i * 0.1),
                y: height * 0.7,
                size: height * (0.1 + Math.random() * 0.1),
                color: scene.accent,
                offset: Math.random() * Math.PI * 2
              });
            }
            break;
            
          case 2: // La Solitude
            // Figure centrale
            shapes.push({
              type: 'figure',
              x: width * 0.5,
              y: height * 0.6,
              size: width * 0.1,
              color: scene.primary,
              offset: 0
            });
            
            // Pensées abstraites
            for (let i = 0; i < 15; i++) {
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * width * 0.3;
              
              shapes.push({
                type: 'thought',
                x: width * 0.5 + Math.cos(angle) * distance,
                y: height * 0.5 + Math.sin(angle) * distance,
                size: width * (0.02 + Math.random() * 0.04),
                color: i % 3 === 0 ? scene.accent : scene.secondary,
                rotation: Math.random() * Math.PI * 2,
                offset: Math.random() * Math.PI * 2
              });
            }
            break;
            
          case 3: // Le Cheminement
            // Figure courbée
            shapes.push({
              type: 'bentFigure',
              x: width * 0.5,
              y: height * 0.6,
              size: width * 0.12,
              color: scene.primary,
              offset: 0
            });
            
            // Mains croisées
            shapes.push({
              type: 'hands',
              x: width * 0.5,
              y: height * 0.7,
              size: width * 0.08,
              color: scene.primary,
              offset: 0
            });
            
            // Ombres (nuit)
            for (let i = 0; i < 10; i++) {
              shapes.push({
                type: 'shadow',
                x: width * Math.random(),
                y: height * Math.random(),
                size: width * (0.05 + Math.random() * 0.1),
                color: scene.background,
                offset: Math.random() * Math.PI * 2
              });
            }
            break;
            
          case 4: // L'Indifférence
            // Figure qui marche
            shapes.push({
              type: 'figure',
              x: width * 0.3,
              y: height * 0.6,
              size: width * 0.1,
              color: scene.primary,
              offset: 0,
              walking: true
            });
            
            // Coucher de soleil (ignoré)
            shapes.push({
              type: 'sunset',
              x: width * 0.7,
              y: height * 0.3,
              size: width * 0.15,
              color: scene.accent,
              offset: 0
            });
            
            // Voiles (Harfleur)
            for (let i = 0; i < 3; i++) {
              shapes.push({
                type: 'ship',
                x: width * (0.6 + i * 0.1),
                y: height * 0.5,
                size: width * 0.05,
                color: scene.secondary,
                offset: i * Math.PI / 4
              });
            }
            break;
            
          case 5: // L'Arrivée
            // Tombe
            shapes.push({
              type: 'tomb',
              x: width * 0.5,
              y: height * 0.6,
              width: width * 0.15,
              height: height * 0.2,
              color: scene.secondary,
              offset: 0
            });
            
            // Figure en deuil
            shapes.push({
              type: 'mourningFigure',
              x: width * 0.4,
              y: height * 0.6,
              size: width * 0.1,
              color: scene.primary,
              offset: 0
            });
            
            // Bouquet
            shapes.push({
              type: 'bouquet',
              x: width * 0.55,
              y: height * 0.55,
              size: width * 0.06,
              color: scene.accent,
              colorHolly: '#2D5F4C',
              offset: 0
            });
            break;
        }
      }
    
      // Dessiner les formes de la scène
      function drawShapes(time) {
        const ctx = contexts.main;
        if (!ctx) return;
        
        // Effacer le canvas
        ctx.clearRect(0, 0, canvases.main.width, canvases.main.height);
        
        // Dessiner chaque forme
        shapes.forEach(shape => {
          // Calculer l'animation basée sur le temps
          const animFactor = Math.sin(time * 0.001 + (shape.offset || 0)) * 5;
          
          ctx.save();
          
          // Dessiner selon le type
          switch (shape.type) {
            case 'sun':
              drawSun(ctx, shape, animFactor, time);
              break;
            case 'field':
              drawField(ctx, shape, animFactor);
              break;
            case 'mountain':
              drawMountain(ctx, shape, animFactor);
              break;
            case 'tree':
              drawTree(ctx, shape, animFactor);
              break;
            case 'figure':
              drawFigure(ctx, shape, animFactor, time, shape.walking);
              break;
            case 'thought':
              drawThought(ctx, shape, animFactor, time);
              break;
            case 'bentFigure':
              drawBentFigure(ctx, shape, animFactor);
              break;
            case 'hands':
              drawHands(ctx, shape, animFactor);
              break;
            case 'shadow':
              drawShadow(ctx, shape, animFactor);
              break;
            case 'sunset':
              drawSunset(ctx, shape, animFactor);
              break;
            case 'ship':
              drawShip(ctx, shape, animFactor, time);
              break;
            case 'tomb':
              drawTomb(ctx, shape, animFactor);
              break;
            case 'mourningFigure':
              drawMourningFigure(ctx, shape, animFactor);
              break;
            case 'bouquet':
              drawBouquet(ctx, shape, animFactor, time);
              break;
          }
          
          ctx.restore();
        });
      }
    
      // Dessiner et mettre à jour les particules
      function drawParticles(time) {
        const ctx = contexts.particles;
        if (!ctx) return;
        
        // Effacer le canvas
        ctx.clearRect(0, 0, canvases.particles.width, canvases.particles.height);
        
        // Mettre à jour et dessiner chaque particule
        particles.forEach(particle => {
          // Mettre à jour la position
          particle.x += particle.speedX;
          particle.y += particle.speedY;
          
          // Reboucler si nécessaire
          if (particle.x < 0) particle.x = canvases.particles.width;
          if (particle.x > canvases.particles.width) particle.x = 0;
          if (particle.y < 0) particle.y = canvases.particles.height;
          if (particle.y > canvases.particles.height) particle.y = 0;
          
          // Dessiner la particule
          ctx.globalAlpha = particle.opacity;
          ctx.fillStyle = particle.color;
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
          ctx.fill();
        });
      }
    
      // Fonctions de dessin spécifiques
      function drawSun(ctx, shape, animFactor, time) {
        const radius = shape.size + animFactor;
        
        // Corps principal
        ctx.fillStyle = shape.color;
        ctx.beginPath();
        ctx.arc(shape.x, shape.y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Rayons
        ctx.strokeStyle = shape.color;
        ctx.lineWidth = radius * 0.05;
        
        for (let i = 0; i < 12; i++) {
          const angle = i * Math.PI / 6 + time * 0.0005;
          const innerRadius = radius * 1.2;
          const outerRadius = radius * 1.8;
          
          ctx.globalAlpha = 0.6;
          ctx.beginPath();
          ctx.moveTo(
            shape.x + Math.cos(angle) * innerRadius,
            shape.y + Math.sin(angle) * innerRadius
          );
          ctx.lineTo(
            shape.x + Math.cos(angle) * outerRadius,
            shape.y + Math.sin(angle) * outerRadius
          );
          ctx.stroke();
        }
        
        // Éclat central
        const gradient = ctx.createRadialGradient(
          shape.x, shape.y, 0,
          shape.x, shape.y, radius * 0.8
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(shape.x, shape.y, radius * 0.8, 0, Math.PI * 2);
        ctx.fill();
      }
    
      function drawField(ctx, shape, animFactor) {
        ctx.fillStyle = shape.color;
        
        // Forme trapézoïdale pour les champs
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.width/2, shape.y - shape.height/2);
        ctx.lineTo(shape.x + shape.width/2, shape.y - shape.height/2);
        ctx.lineTo(shape.x + shape.width/2 + animFactor * 0.5, shape.y + shape.height/2);
        ctx.lineTo(shape.x - shape.width/2 + animFactor * 0.5, shape.y + shape.height/2);
        ctx.closePath();
        ctx.fill();
      }
    
      function drawMountain(ctx, shape, animFactor) {
        ctx.fillStyle = shape.color;
        
        // Forme de montagne
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.size, shape.y);
        ctx.lineTo(shape.x - shape.size * 0.5, shape.y - shape.size * 0.8 + animFactor * 0.3);
        ctx.lineTo(shape.x, shape.y - shape.size * 1.2 + animFactor * 0.5);
        ctx.lineTo(shape.x + shape.size * 0.5, shape.y - shape.size * 0.7 + animFactor * 0.3);
        ctx.lineTo(shape.x + shape.size, shape.y);
        ctx.closePath();
        ctx.fill();
      }
    
      function drawTree(ctx, shape, animFactor) {
        // Tronc
        ctx.fillStyle = '#5D4037';
        ctx.fillRect(
          shape.x - shape.size * 0.1,
          shape.y - shape.size * 0.3,
          shape.size * 0.2,
          shape.size * 0.7
        );
        
        // Feuillage (style cubiste)
        ctx.fillStyle = shape.color;
        
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.size * 0.5, shape.y - shape.size * 0.3);
        ctx.lineTo(shape.x - shape.size * 0.3, shape.y - shape.size * 0.7 - animFactor * 0.2);
        ctx.lineTo(shape.x, shape.y - shape.size * 1.1 - animFactor * 0.3);
        ctx.lineTo(shape.x + shape.size * 0.3, shape.y - shape.size * 0.7 - animFactor * 0.2);
        ctx.lineTo(shape.x + shape.size * 0.5, shape.y - shape.size * 0.3);
        ctx.closePath();
        ctx.fill();
      }
    
      function drawFigure(ctx, shape, animFactor, time, walking = false) {
        ctx.fillStyle = shape.color;
        
        // Tête
        ctx.beginPath();
        ctx.arc(shape.x, shape.y - shape.size * 0.5, shape.size * 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Corps
        ctx.beginPath();
        ctx.moveTo(shape.x, shape.y - shape.size * 0.3);
        ctx.lineTo(shape.x - shape.size * 0.3, shape.y + shape.size * 0.5);
        ctx.lineTo(shape.x + shape.size * 0.3, shape.y + shape.size * 0.5);
        ctx.closePath();
        ctx.fill();
        
        // Bras et jambes
        ctx.strokeStyle = shape.color;
        ctx.lineWidth = shape.size * 0.1;
        
        if (walking) {
          // Animation de marche
          const walkOffset = Math.sin(time * 0.002) * 0.2;
          
          // Bras
          ctx.beginPath();
          ctx.moveTo(shape.x - shape.size * 0.15, shape.y - shape.size * 0.1);
          ctx.lineTo(
            shape.x - shape.size * 0.4,
            shape.y + shape.size * 0.2 + Math.sin(time * 0.002) * shape.size * 0.2
          );
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(shape.x + shape.size * 0.15, shape.y - shape.size * 0.1);
          ctx.lineTo(
            shape.x + shape.size * 0.4,
            shape.y + shape.size * 0.2 + Math.sin(time * 0.002 + Math.PI) * shape.size * 0.2
          );
          ctx.stroke();
          
          // Jambes
          ctx.beginPath();
          ctx.moveTo(shape.x - shape.size * 0.15, shape.y + shape.size * 0.3);
          ctx.lineTo(
            shape.x - shape.size * 0.25,
            shape.y + shape.size * 0.8 + Math.sin(time * 0.002 + Math.PI) * shape.size * 0.15
          );
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(shape.x + shape.size * 0.15, shape.y + shape.size * 0.3);
          ctx.lineTo(
            shape.x + shape.size * 0.25,
            shape.y + shape.size * 0.8 + Math.sin(time * 0.002) * shape.size * 0.15
          );
          ctx.stroke();
        } else {
          // Posture statique
          // Bras
          ctx.beginPath();
          ctx.moveTo(shape.x - shape.size * 0.15, shape.y - shape.size * 0.1);
          ctx.lineTo(shape.x - shape.size * 0.4, shape.y + shape.size * 0.2);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(shape.x + shape.size * 0.15, shape.y - shape.size * 0.1);
          ctx.lineTo(shape.x + shape.size * 0.4, shape.y + shape.size * 0.2);
          ctx.stroke();
          
          // Jambes
          ctx.beginPath();
          ctx.moveTo(shape.x - shape.size * 0.15, shape.y + shape.size * 0.3);
          ctx.lineTo(shape.x - shape.size * 0.25, shape.y + shape.size * 0.8);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(shape.x + shape.size * 0.15, shape.y + shape.size * 0.3);
          ctx.lineTo(shape.x + shape.size * 0.25, shape.y + shape.size * 0.8);
          ctx.stroke();
        }
      }
    
      function drawThought(ctx, shape, animFactor, time) {
        ctx.fillStyle = shape.color;
        
        // Forme abstraite de pensée (diamant)
        ctx.save();
        ctx.translate(shape.x, shape.y);
        ctx.rotate(shape.rotation + time * 0.0005);
        
        ctx.beginPath();
        ctx.moveTo(0, -shape.size);
        ctx.lineTo(shape.size, 0);
        ctx.lineTo(0, shape.size);
        ctx.lineTo(-shape.size, 0);
        ctx.closePath();
        ctx.fill();
        
        // Cercle central
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        ctx.arc(0, 0, shape.size * 0.3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
    
      function drawBentFigure(ctx, shape, animFactor) {
        ctx.fillStyle = shape.color;
        
        // Tête (baissée)
        ctx.beginPath();
        ctx.arc(shape.x, shape.y - shape.size * 0.3, shape.size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Corps courbé
        ctx.beginPath();
        ctx.moveTo(shape.x, shape.y - shape.size * 0.15);
        ctx.quadraticCurveTo(
          shape.x, shape.y,
          shape.x - shape.size * 0.2, shape.y + shape.size * 0.2
        );
        ctx.lineTo(shape.x + shape.size * 0.2, shape.y + shape.size * 0.3);
        ctx.quadraticCurveTo(
          shape.x, shape.y,
          shape.x, shape.y - shape.size * 0.15
        );
        ctx.closePath();
        ctx.fill();
        
        // Bras courbés
        ctx.strokeStyle = shape.color;
        ctx.lineWidth = shape.size * 0.08;
        
        // Jambes
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.size * 0.1, shape.y + shape.size * 0.25);
        ctx.lineTo(shape.x - shape.size * 0.2, shape.y + shape.size * 0.6);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(shape.x + shape.size * 0.1, shape.y + shape.size * 0.25);
        ctx.lineTo(shape.x + shape.size * 0.15, shape.y + shape.size * 0.6);
        ctx.stroke();
      }
    
      function drawHands(ctx, shape, animFactor) {
        ctx.strokeStyle = shape.color;
        ctx.lineWidth = shape.size * 0.15;
        
        // Bras avec mains croisées
        // Bras gauche
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.size, shape.y - shape.size * 0.3);
        ctx.quadraticCurveTo(
          shape.x - shape.size * 0.3, 
          shape.y,
          shape.x + shape.size * 0.3 + animFactor * 0.3, 
          shape.y
        );
        ctx.stroke();
        
        // Bras droit
        ctx.beginPath();
        ctx.moveTo(shape.x + shape.size, shape.y - shape.size * 0.3);
        ctx.quadraticCurveTo(
          shape.x + shape.size * 0.3, 
          shape.y,
          shape.x - shape.size * 0.3 + animFactor * 0.3, 
          shape.y + shape.size * 0.2
        );
        ctx.stroke();
      }
    
      function drawShadow(ctx, shape, animFactor) {
        // Ombre abstraite
        const gradient = ctx.createRadialGradient(
          shape.x, shape.y, 0,
          shape.x, shape.y, shape.size
        );
        gradient.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(shape.x, shape.y, shape.size + animFactor * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }
    
      function drawSunset(ctx, shape, animFactor) {
        // Coucher de soleil
        const gradient = ctx.createRadialGradient(
          shape.x, shape.y, 0,
          shape.x, shape.y, shape.size
        );
        gradient.addColorStop(0, shape.color);
        gradient.addColorStop(0.7, `${shape.color}80`);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        
        ctx.globalAlpha = 0.6; // Atténué car ignoré
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(shape.x, shape.y, shape.size + animFactor * 0.2, 0, Math.PI);
        ctx.fill();
      }
    
      function drawShip(ctx, shape, animFactor, time) {
        ctx.globalAlpha = 0.4; // Atténué car ignoré
        ctx.fillStyle = shape.color;
        
        // Coque
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.size, shape.y + Math.sin(time * 0.001) * 2);
        ctx.lineTo(shape.x + shape.size, shape.y + Math.sin(time * 0.001) * 2);
        ctx.lineTo(shape.x + shape.size * 0.6, shape.y - shape.size * 0.5 + Math.sin(time * 0.001) * 2);
        ctx.lineTo(shape.x - shape.size * 0.6, shape.y - shape.size * 0.5 + Math.sin(time * 0.001) * 2);
        ctx.closePath();
        ctx.fill();
        
        // Voile
        ctx.beginPath();
        ctx.moveTo(shape.x, shape.y - shape.size * 0.5 + Math.sin(time * 0.001) * 2);
        ctx.lineTo(shape.x, shape.y - shape.size * 2 + Math.sin(time * 0.001) * 2);
        ctx.lineTo(shape.x + shape.size * 0.8, shape.y - shape.size * 0.8 + Math.sin(time * 0.001) * 2);
        ctx.closePath();
        ctx.fill();
      }
    
      function drawTomb(ctx, shape, animFactor) {
        ctx.fillStyle = shape.color;
        
        // Base
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.width/2, shape.y - shape.height * 0.1);
        ctx.lineTo(shape.x + shape.width/2, shape.y - shape.height * 0.1);
        ctx.lineTo(shape.x + shape.width/2, shape.y + shape.height * 0.4);
        ctx.lineTo(shape.x - shape.width/2, shape.y + shape.height * 0.4);
        ctx.closePath();
        ctx.fill();
        
        // Pierre tombale
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.width * 0.4, shape.y - shape.height * 0.1);
        ctx.lineTo(shape.x + shape.width * 0.4, shape.y - shape.height * 0.1);
        ctx.lineTo(shape.x + shape.width * 0.3, shape.y - shape.height * 0.8 + animFactor * 0.2);
        ctx.lineTo(shape.x - shape.width * 0.3, shape.y - shape.height * 0.8 + animFactor * 0.2);
        ctx.closePath();
        ctx.fill();
        
        // Ombre
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.width/2, shape.y + shape.height * 0.4);
        ctx.lineTo(shape.x + shape.width/2, shape.y + shape.height * 0.4);
        ctx.lineTo(shape.x + shape.width * 0.7, shape.y + shape.height * 0.6);
        ctx.lineTo(shape.x - shape.width * 0.7, shape.y + shape.height * 0.6);
        ctx.closePath();
        ctx.fill();
      }
    
      function drawMourningFigure(ctx, shape, animFactor) {
        ctx.fillStyle = shape.color;
        
        // Tête
        ctx.beginPath();
        ctx.arc(shape.x, shape.y - shape.size * 0.5, shape.size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Corps (agenouillé)
        ctx.beginPath();
        ctx.moveTo(shape.x, shape.y - shape.size * 0.35);
        ctx.lineTo(shape.x - shape.size * 0.25, shape.y);
        ctx.lineTo(shape.x - shape.size * 0.35, shape.y + shape.size * 0.3);
        ctx.lineTo(shape.x + shape.size * 0.35, shape.y + shape.size * 0.3);
        ctx.lineTo(shape.x + shape.size * 0.25, shape.y);
        ctx.closePath();
        ctx.fill();
        
        // Bras (tendus vers la tombe)
        ctx.strokeStyle = shape.color;
        ctx.lineWidth = shape.size * 0.08;
        
        ctx.beginPath();
        ctx.moveTo(shape.x, shape.y - shape.size * 0.2);
        ctx.lineTo(shape.x + shape.size * 0.5 + animFactor * 0.1, shape.y - shape.size * 0.1);
        ctx.stroke();
      }
    
      function drawBouquet(ctx, shape, animFactor, time) {
        // Base du bouquet
        ctx.fillStyle = '#5D4037';
        ctx.beginPath();
        ctx.moveTo(shape.x, shape.y);
        ctx.lineTo(shape.x - shape.size * 0.3, shape.y - shape.size * 0.6);
        ctx.lineTo(shape.x + shape.size * 0.3, shape.y - shape.size * 0.6);
        ctx.closePath();
        ctx.fill();
        
        // Houx vert
        ctx.fillStyle = shape.colorHolly || '#2D5F4C';
        
        for (let i = 0; i < 5; i++) {
          const angle = i * Math.PI * 0.4 - Math.PI * 0.8 + Math.sin(time * 0.001) * 0.1;
          const x = shape.x + Math.cos(angle) * shape.size * 0.3;
          const y = shape.y - shape.size * 0.5 + Math.sin(angle) * shape.size * 0.2;
          
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(angle + Math.PI * 0.5);
          
          // Feuille de houx
          ctx.beginPath();
          ctx.moveTo(0, -shape.size * 0.2);
          ctx.lineTo(shape.size * 0.1, -shape.size * 0.05);
          ctx.lineTo(shape.size * 0.2, -shape.size * 0.2);
          ctx.lineTo(shape.size * 0.1, 0);
          ctx.lineTo(shape.size * 0.2, shape.size * 0.2);
          ctx.lineTo(0, shape.size * 0.05);
          ctx.lineTo(-shape.size * 0.2, shape.size * 0.2);
          ctx.lineTo(-shape.size * 0.1, 0);
          ctx.lineTo(-shape.size * 0.2, -shape.size * 0.2);
          ctx.lineTo(-shape.size * 0.1, -shape.size * 0.05);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        }
        
        // Bruyère en fleurs
        ctx.fillStyle = shape.color;
        
        for (let i = 0; i < 8; i++) {
          const angle = i * Math.PI * 0.25 + Math.sin(time * 0.001 + i) * 0.1;
          const x = shape.x + Math.cos(angle) * shape.size * 0.3;
          const y = shape.y - shape.size * 0.4 + Math.sin(angle) * shape.size * 0.3;
          
          ctx.beginPath();
          ctx.arc(x, y, shape.size * 0.1, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Baies rouges du houx
        ctx.fillStyle = '#D32F2F';
        
        for (let i = 0; i < 3; i++) {
          const angle = i * Math.PI * 0.5 - Math.PI * 0.5;
          const x = shape.x + Math.cos(angle) * shape.size * 0.15;
          const y = shape.y - shape.size * 0.3 + Math.sin(angle) * shape.size * 0.15;
          
          ctx.beginPath();
          ctx.arc(x, y, shape.size * 0.08, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    
      // ------------------ FONCTIONS AUDIO ------------------
      // Initialiser l'audio
      function initAudio() {
  try {
    // Récupérer l'élément audio de fond
    backgroundMusic = document.getElementById('background-music');
    
    // Initialiser le volume
    if (backgroundMusic) {
      backgroundMusic.volume = 0.5; // Volume initial à 50%
    }
    
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Créer un nœud de gain principal
    masterGain = audioContext.createGain();
    masterGain.gain.value = 0.7; // Volume initial
    masterGain.connect(audioContext.destination);
    
    return true;
  } catch (e) {
    console.error("Audio initialization failed:", e);
    return false;
  }
}
    
      // Jouer un son simple
      function playTone(freq, duration, type = 'sine', volume = 0.3) {
        if (!audioContext || isMuted) return;
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.type = type;
        oscillator.frequency.value = freq;
        
        gainNode.gain.value = 0;
        gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
        
        oscillator.connect(gainNode);
        gainNode.connect(masterGain);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration);
      }
    
      // Créer un bruit blanc
      function createNoiseBuffer() {
        const bufferSize = audioContext.sampleRate * 2;
        const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        
        return buffer;
      }
    
      // Jouer un effet sonore d'ambiance pour la scène actuelle
// Jouer un effet sonore d'ambiance pour la scène actuelle
function playAmbientSound() {
  if (!audioContext || isMuted) return;
  
  // Arrêter tout son précédent
  if (ambientSounds && ambientSounds.length > 0) {
    ambientSounds.forEach(sound => {
      try {
        if (sound.oscillator) {
          sound.oscillator.stop();
        }
        if (sound.source) {
          sound.source.stop();
        }
        if (sound.oscillator2) {
          sound.oscillator2.stop();
        }
      } catch(e) {
        // Ignorer les erreurs de fermeture des nœuds audio
      }
    });
  }
  
  // Réinitialiser le tableau des sons ambiants
  ambientSounds = [];
  
  // Le reste de la fonction reste identique...
        const scene = sceneData[currentSceneIndex];
        
        // Créer un son différent selon la scène
        switch (currentSceneIndex) {
          case 0: // L'Aube
            // Ton doux de l'aube
            const osc1 = audioContext.createOscillator();
            const gain1 = audioContext.createGain();
            
            osc1.type = 'sine';
            osc1.frequency.value = 220;
            
            gain1.gain.value = 0;
            gain1.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 1);
            
            osc1.connect(gain1);
            gain1.connect(masterGain);
            
            osc1.start();
            
            ambientSounds.push({ oscillator: osc1, gain: gain1 });
            break;
            
          case 1: // Le Voyage
            // Bruit de fond forestier
            const noiseBuffer = createNoiseBuffer();
            const forestSource = audioContext.createBufferSource();
            forestSource.buffer = noiseBuffer;
            forestSource.loop = true;
            
            const forestFilter = audioContext.createBiquadFilter();
            forestFilter.type = 'bandpass';
            forestFilter.frequency.value = 400;
            forestFilter.Q.value = 0.5;
            
            const forestGain = audioContext.createGain();
            forestGain.gain.value = 0.05;
            
            forestSource.connect(forestFilter);
            forestFilter.connect(forestGain);
            forestGain.connect(masterGain);
            
            forestSource.start();
            
            ambientSounds.push({ source: forestSource, gain: forestGain });
            break;
            
          case 2: // La Solitude
            // Ton grave et espacé
            const osc2 = audioContext.createOscillator();
            const gain2 = audioContext.createGain();
            
            osc2.type = 'sine';
            osc2.frequency.value = 80;
            
            gain2.gain.value = 0;
            gain2.gain.linearRampToValueAtTime(0.08, audioContext.currentTime + 1);
            
            osc2.connect(gain2);
            gain2.connect(masterGain);
            
            osc2.start();
            
            ambientSounds.push({ oscillator: osc2, gain: gain2 });
            break;
            
          case 3: // Le Cheminement
            // Rythme lent des pas
            setInterval(() => {
              if (audioContext && !isMuted) {
                const freq = 100 + Math.random() * 30;
                playTone(freq, 0.3, 'sine', 0.1);
              }
            }, 2000);
            break;
            
          case 4: // L'Indifférence
            // Bruit de vagues distantes
            const noiseBuffer2 = createNoiseBuffer();
            const wavesSource = audioContext.createBufferSource();
            wavesSource.buffer = noiseBuffer2;
            wavesSource.loop = true;
            
            const wavesFilter = audioContext.createBiquadFilter();
            wavesFilter.type = 'lowpass';
            wavesFilter.frequency.value = 200;
            
            const wavesGain = audioContext.createGain();
            wavesGain.gain.value = 0.05;
            
            const lfo = audioContext.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.1;
            
            const lfoGain = audioContext.createGain();
            lfoGain.gain.value = 0.03;
            
            lfo.connect(lfoGain);
            lfoGain.connect(wavesGain.gain);
            
            wavesSource.connect(wavesFilter);
            wavesFilter.connect(wavesGain);
            wavesGain.connect(masterGain);
            
            wavesSource.start();
            lfo.start();
            
            ambientSounds.push({ source: wavesSource, oscillator: lfo, gain: wavesGain });
            break;
            
          case 5: // L'Arrivée
            // Accord harmonique
            const osc3 = audioContext.createOscillator();
            const osc4 = audioContext.createOscillator();
            const gain3 = audioContext.createGain();
            
            osc3.type = 'sine';
            osc3.frequency.value = 220; // La3
            
            osc4.type = 'sine';
            osc4.frequency.value = 329.63; // Mi4
            
            gain3.gain.value = 0;
            gain3.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 2);
            
            osc3.connect(gain3);
            osc4.connect(gain3);
            gain3.connect(masterGain);
            
            osc3.start();
            osc4.start();
            
            ambientSounds.push({ oscillator: osc3, oscillator2: osc4, gain: gain3 });
            break;
        }
        
        return ambientSounds;
      }
    
      // Mettre à jour le volume
      function updateVolume() {
        if (masterGain) {
          if (isMuted) {
            masterGain.gain.value = 0;
            if (elements.muteButton) {
              elements.muteButton.textContent = '🔇';
            }
          } else {
            const volume = elements.volumeSlider ? elements.volumeSlider.value / 100 : 0.7;
            masterGain.gain.value = volume;
            if (elements.muteButton) {
              elements.muteButton.textContent = '🔊';
            }
          }
        }
      }
    
      // Jouer un son de clic
      function playClickSound() {
        if (!audioContext || isMuted) return;
        
        const clickOsc = audioContext.createOscillator();
        const clickGain = audioContext.createGain();
        
        clickOsc.type = 'sine';
        clickOsc.frequency.value = 600 + Math.random() * 100;
        
        clickGain.gain.value = 0;
        clickGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.01);
        clickGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
        
        clickOsc.connect(clickGain);
        clickGain.connect(masterGain);
        
        clickOsc.start();
        clickOsc.stop(audioContext.currentTime + 0.1);
      }
    
      // Jouer un son de transition
      function playTransitionSound() {
        if (!audioContext || isMuted) return;
        
        // Un accord plus complexe avec une montée
        const freqs = [220, 277.18, 329.63]; // La3, Do#4, Mi4
        
        freqs.forEach((freq, i) => {
          const transOsc = audioContext.createOscillator();
          const transGain = audioContext.createGain();
          
          transOsc.type = 'sine';
          transOsc.frequency.value = freq;
          
          transGain.gain.value = 0;
          transGain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.1 + i * 0.1);
          transGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
          
          transOsc.connect(transGain);
          transGain.connect(masterGain);
          
          transOsc.start();
          transOsc.stop(audioContext.currentTime + 1);
        });
      }
    
      // ------------------ FONCTIONS D'INTERFACE ------------------
      // Créer les lignes du poème
      function createPoemLines() {
        if (!elements.poemContainer) return;
        
        elements.poemContainer.innerHTML = '';
        
        sceneData.forEach(scene => {
          scene.lines.forEach(line => {
            const lineDiv = document.createElement('div');
            lineDiv.className = 'poem-line';
            lineDiv.textContent = line;
            elements.poemContainer.appendChild(lineDiv);
          });
        });
      }
    
      // Créer la navigation entre les scènes
      function createNavigationDots() {
        if (!elements.controls) return;
        
        elements.controls.innerHTML = '';
        
        sceneData.forEach((scene, index) => {
          const dot = document.createElement('div');
          dot.className = 'control-dot';
          if (index === currentSceneIndex) {
            dot.classList.add('active');
          }
          
          dot.addEventListener('click', () => {
            goToScene(index);
            playClickSound();
          });
          
          elements.controls.appendChild(dot);
        });
      }
    
      // Passer à une scène spécifique
      function goToScene(index) {
        if (isTransitioning || index === currentSceneIndex) return;
        
        isTransitioning = true;
        
        // Masquer la scène actuelle
        fadeOutCurrentScene(() => {
          // Changer l'index de scène
          currentSceneIndex = index;
          
          // Mettre à jour la scène
          updateScene();
          
          // Afficher la nouvelle scène
          fadeInCurrentScene();
          
          // Terminer la transition
          setTimeout(() => {
            isTransitioning = false;
          }, 2000);
          
          // Jouer le son de transition
          playTransitionSound();
        });
      }
    
      // Masquer la scène actuelle
      function fadeOutCurrentScene(callback) {
        // Masquer les lignes du poème
        const poemLines = document.querySelectorAll('.poem-line');
        poemLines.forEach(line => {
          line.classList.remove('visible');
        });
        
        // Masquer le titre de la scène
        if (elements.sceneTitle) {
          elements.sceneTitle.classList.remove('visible');
        }
        
        // Attendre que les animations se terminent
        setTimeout(callback, 1000);
      }
    
      // Afficher la nouvelle scène
      function fadeInCurrentScene() {
        // Mettre à jour le titre de la scène
        if (elements.sceneTitle) {
          elements.sceneTitle.textContent = sceneData[currentSceneIndex].title;
          elements.sceneTitle.classList.add('visible');
        }
        
        // Afficher les lignes du poème correspondantes
        const poemLines = document.querySelectorAll('.poem-line');
        const startIndex = currentSceneIndex * 2;
        
        setTimeout(() => {
          if (poemLines[startIndex]) {
            poemLines[startIndex].classList.add('visible');
          }
          
          setTimeout(() => {
            if (poemLines[startIndex + 1]) {
              poemLines[startIndex + 1].classList.add('visible');
            }
          }, 1000);
        }, 500);
        
        // Jouer l'ambiance sonore
        playAmbientSound();
      }
    
      // Mettre à jour tous les éléments de la scène
      function updateScene() {
        // Mettre à jour les contrôles de navigation
        const dots = document.querySelectorAll('.control-dot');
        dots.forEach((dot, i) => {
          dot.classList.toggle('active', i === currentSceneIndex);
        });
        
        // Dessiner le nouvel arrière-plan
        drawBackground();
        
        // Générer de nouvelles formes
        generateShapes();
        
        // Créer de nouvelles particules
        createParticles();
        
        // Réinitialiser la barre de progression
        if (elements.progressBar) {
          elements.progressBar.style.width = '0%';
        }
        
        // Effacer le timer d'avancement automatique
        if (autoAdvanceTimer) {
          clearInterval(autoAdvanceTimer);
        }
        
        // Configurer le nouvel avancement automatique
        autoAdvanceTimer = setInterval(() => {
          if (!isTransitioning && elements.progressBar) {
            const currentWidth = parseFloat(elements.progressBar.style.width || '0');
            if (currentWidth < 100) {
              elements.progressBar.style.width = (currentWidth + 0.1) + '%';
            } else {
              // Passer à la scène suivante
              goToScene((currentSceneIndex + 1) % sceneData.length);
            }
          }
        }, 50); // ~20 secondes par scène
      }
    
      // Fonction d'animation principale
      function animate(time) {
        // Dessiner les formes principales
        drawShapes(time);
        
        // Dessiner les particules
        drawParticles(time);
        
        // Continuer l'animation
        animationFrame = requestAnimationFrame(animate);
      }
    
      // Démarrer l'expérience
      function startExperience() {
        // Masquer l'introduction
        if (elements.intro) {
          elements.intro.style.opacity = '0';
          setTimeout(() => {
            elements.intro.style.display = 'none';
          }, 1500);
        } if (backgroundMusic) {
    backgroundMusic.play().catch(e => {
      console.warn("Impossible de lancer la musique automatiquement, interaction utilisateur requise:", e);
    });
  }

        
        // Initialiser l'audio
        initAudio();
        
        // Créer les éléments d'interface
        createPoemLines();
        createNavigationDots();
        
        // Afficher les contrôles
        if (elements.controls) {
          elements.controls.style.opacity = '1';
        }
        if (elements.progressContainer) {
          elements.progressContainer.style.opacity = '1';
        }
        if (elements.audioControls) {
          elements.audioControls.style.opacity = '1';
        }
        if (elements.clickHint) {
          elements.clickHint.style.opacity = '1';
          setTimeout(() => {
            elements.clickHint.style.opacity = '0';
          }, 8000);
        }
        
        // Initialiser la première scène
        drawBackground();
        generateShapes();
        createParticles();
        fadeInCurrentScene();
        
        // Démarrer l'animation
        animate(0);
        
        // Configurer l'avancement automatique
        updateScene();
        
        // Jouer un son pour signaler le début
        playTone(220, 0.5, 'sine', 0.3);
        setTimeout(() => {
          playTone(330, 0.5, 'sine', 0.3);
        }, 500);
        setTimeout(() => {
          playTone(440, 0.8, 'sine', 0.3);
        }, 1000);
      }
    
      // Créer un effet ripple
      function createRippleEffect(x, y) {
        const ripple = document.createElement('div');
        ripple.className = 'ripple';
        ripple.style.width = '100px';
        ripple.style.height = '100px';
        ripple.style.left = x + 'px';
        ripple.style.top = y + 'px';
        
        document.body.appendChild(ripple);
        
        setTimeout(() => {
          ripple.remove();
        }, 1000);
      }
    
      // ------------------ ÉCOUTEURS D'ÉVÉNEMENTS ------------------
      // Écouteur pour le bouton de démarrage
      if (elements.startButton) {
        elements.startButton.addEventListener('click', startExperience);
      }
      
      // Écouteur pour le redimensionnement de la fenêtre
      window.addEventListener('resize', resizeCanvases);
      
      // Écouteur pour les clics dans le document
      document.addEventListener('click', function(e) {
        // Ignorer les clics sur les contrôles
        if (e.target.closest('.control-dot') || 
            e.target.closest('#start-button') ||
            e.target.closest('#audio-controls')) {
          return;
        }
        
        // Créer un effet ripple
        createRippleEffect(e.clientX, e.clientY);
        
        // Jouer un son de clic
        playClickSound();
        
        // Masquer l'indice après le premier clic
        if (elements.clickHint && elements.clickHint.style.opacity !== '0') {
          elements.clickHint.style.opacity = '0';
        }
      });
      
      // Écouteur pour le mouvement de la souris
      document.addEventListener('mousemove', function(e) {
        // Mettre à jour la position de la souris
        const mouseX = e.clientX;
        const mouseY = e.clientY;
        
        // Déplacer le cercle magique
        if (elements.magicCircle) {
          elements.magicCircle.style.left = mouseX + 'px';
          elements.magicCircle.style.top = mouseY + 'px';
          elements.magicCircle.style.opacity = '1';
          
          setTimeout(() => {
            elements.magicCircle.style.opacity = '0';
          }, 2000);
        }
      });
      
      // Écouteur pour le contrôle du volume
      if (elements.volumeSlider) {
        elements.volumeSlider.addEventListener('input', function() {
          updateVolume();
        });
      }
      
      // Écouteur pour le bouton de sourdine
      if (elements.muteButton) {
        elements.muteButton.addEventListener('click', function() {
          isMuted = !isMuted;
          updateVolume();
        });
      }
      
      // ------------------ INITIALISATION ------------------
      // Masquer immédiatement l'écran de chargement (sécurité supplémentaire)
      if (loadingScreen) {
        loadingScreen.style.display = 'none';
      }
      
      // Redimensionner les canvas au chargement
      resizeCanvases();
      
      console.log("Animation cubiste initialisée avec succès.");
    });
    </script>
<body>
  <div id="loading">
    <div class="loader"></div>
  </div>

  <div id="intro">
    <h1>Demain, dès l'aube...</h1>
    <p>Une interprétation cubiste du poème de Victor Hugo, évoquant le voyage d'un père vers la tombe de sa fille. Une expérience interactive visuelle et sonore.</p>
    <button id="start-button">COMMENCER LE VOYAGE</button>
  </div>

  <div id="canvas-container">
    <canvas id="bg-canvas"></canvas>
    <canvas id="main-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>
    <canvas id="interactive-canvas"></canvas>
  </div>

  <div id="poem-container"></div>
  
  <div class="scene-title" id="scene-title"></div>
  
  <div class="controls" id="controls"></div>
  
  <div class="progress-container" id="progress-container">
    <div class="progress-bar" id="progress-bar"></div>
  </div>
  
  <div class="audio-controls" id="audio-controls">
    <input type="range" min="0" max="100" value="70" class="volume-slider" id="volume-slider">
    <button class="mute-button" id="mute-button">🔊</button>
  </div>
  
  <div class="click-hint" id="click-hint">Cliquez n'importe où pour interagir</div>
  
  <div id="magic-circle"></div>
  <audio id="background-music" loop preload="auto" style="display:none;">
    <source src="audio/vice_versa.mp3" type="audio/mpeg">
    Votre navigateur ne supporte pas l'élément audio.
  </audio>
  
  <div class="author-credit">Poème "Demain, dès l'aube..." - Victor Hugo (1847)</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Configuration
      const config = {
        scenes: [
          {
            title: "L'Aube",
            lines: [
              "Demain, dès l'aube, à l'heure où blanchit la campagne,",
              "Je partirai. Vois-tu, je sais que tu m'attends."
            ],
            colors: {
              primary: "#3B4D7B",
              secondary: "#A68DAD",
              accent: "#F7C59F",
              background: "#1A1A2E"
            },
            audio: {
              ambient: "aube",
              effects: ["chant_oiseau", "vent_leger"]
            }
          },
          {
            title: "Le Voyage",
            lines: [
              "J'irai par la forêt, j'irai par la montagne.",
              "Je ne puis demeurer loin de toi plus longtemps."
            ],
            colors: {
              primary: "#2C5F60",
              secondary: "#68A691",
              accent: "#E0AB94",
              background: "#1E2639"
            },
            audio: {
              ambient: "foret",
              effects: ["pas_feuilles", "branches"]
            }
          },
          {
            title: "La Solitude",
            lines: [
              "Je marcherai les yeux fixés sur mes pensées,",
              "Sans rien voir au dehors, sans entendre aucun bruit,"
            ],
            colors: {
              primary: "#455561",
              secondary: "#7B6D8D",
              accent: "#D8B4A0",
              background: "#232331"
            },
            audio: {
              ambient: "silence",
              effects: ["battement_coeur", "respiration"]
            }
          },
          {
            title: "Le Cheminement",
            lines: [
              "Seul, inconnu, le dos courbé, les mains croisées,",
              "Triste, et le jour pour moi sera comme la nuit."
            ],
            colors: {
              primary: "#484D6D",
              secondary: "#8A817C",
              accent: "#BCB6FF",
              background: "#28293D"
            },
            audio: {
              ambient: "nuit",
              effects: ["pas_lents", "vent_sombre"]
            }
          },
          {
            title: "L'Indifférence",
            lines: [
              "Je ne regarderai ni l'or du soir qui tombe,",
              "Ni les voiles au loin descendant vers Harfleur,"
            ],
            colors: {
              primary: "#5E4B56",
              secondary: "#9C8CB0",
              accent: "#F1AB86",
              background: "#2A2B3D"
            },
            audio: {
              ambient: "crepuscule",
              effects: ["vagues_distantes", "vent_voiles"]
            }
          },
          {
            title: "L'Arrivée",
            lines: [
              "Et quand j'arriverai, je mettrai sur ta tombe",
              "Un bouquet de houx vert et de bruyère en fleur."
            ],
            colors: {
              primary: "#58355E",
              secondary: "#7D6B7D",
              accent: "#D8A7B0",
              background: "#1D1D2C"
            },
            audio: {
              ambient: "recueillement",
              effects: ["recueillement", "vent_feuilles"]
            }
          }
        ],
        currentScene: 0,
        transition: false,
        animationStarted: false,
        shapes: [],
        particles: [],
        interactiveParticles: [],
        mouseX: 0,
        mouseY: 0,
        lastInteraction: 0,
        audioLoaded: false,
        muted: false,
        volume: 0.7,
        audioElements: {},
        audioSources: {
          // Ambiances
          aube: generateAubeSound,
          foret: generateForetSound,
          silence: generateSilenceSound,
          nuit: generateNuitSound,
          crepuscule: generateCrepusculeSound,
          recueillement: generateRecueillementSound,
          
          // Effets
          chant_oiseau: generateBirdSound,
          vent_leger: generateLightWindSound,
          pas_feuilles: generateFootstepsSound,
          branches: generateBranchesSound,
          battement_coeur: generateHeartbeatSound,
          respiration: generateBreathingSound,
          pas_lents: generateSlowFootstepsSound,
          vent_sombre: generateDarkWindSound,
          vagues_distantes: generateDistantWavesSound,
          vent_voiles: generateSailsWindSound,
          recueillement: generateHumbleSound,
          vent_feuilles: generateLeavesWindSound,
          
          // Interactions
          click: generateClickSound,
          transition: generateTransitionSound,
          hover: generateHoverSound
        }
      };

      // DOM Elements
      const intro = document.getElementById('intro');
      const startButton = document.getElementById('start-button');
      const poemContainer = document.getElementById('poem-container');
      const sceneTitle = document.getElementById('scene-title');
      const controls = document.getElementById('controls');
      const progressContainer = document.getElementById('progress-container');
      const progressBar = document.getElementById('progress-bar');
      const loading = document.getElementById('loading');
      const audioControls = document.getElementById('audio-controls');
      const volumeSlider = document.getElementById('volume-slider');
      const muteButton = document.getElementById('mute-button');
      const clickHint = document.getElementById('click-hint');
      const magicCircle = document.getElementById('magic-circle');
      
      // Canvas setup
      const bgCanvas = document.getElementById('bg-canvas');
      const mainCanvas = document.getElementById('main-canvas');
      const particleCanvas = document.getElementById('particle-canvas');
      const interactiveCanvas = document.getElementById('interactive-canvas');
      const bgCtx = bgCanvas.getContext('2d');
      const ctx = mainCanvas.getContext('2d');
      const particleCtx = particleCanvas.getContext('2d');
      const interactiveCtx = interactiveCanvas.getContext('2d');

      // Audio context
      let audioContext;
      let ambientGainNode;
      let effectsGainNode;
      let interactionGainNode;
      let mainGainNode;
      let currentAmbientSource;
      let ambientAnalyser;

      // Resize function
      function resizeCanvases() {
        const updateCanvas = (canvas) => {
          const dpr = window.devicePixelRatio || 1;
          const rect = canvas.getBoundingClientRect();
          
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          
          const ctx = canvas.getContext('2d');
          ctx.scale(dpr, dpr);
        };
        
        bgCanvas.width = window.innerWidth;
        bgCanvas.height = window.innerHeight;
        mainCanvas.width = window.innerWidth;
        mainCanvas.height = window.innerHeight;
        particleCanvas.width = window.innerWidth;
        particleCanvas.height = window.innerHeight;
        interactiveCanvas.width = window.innerWidth;
        interactiveCanvas.height = window.innerHeight;
        
        // Adjust for high DPI displays
        updateCanvas(bgCanvas);
        updateCanvas(mainCanvas);
        updateCanvas(particleCanvas);
        updateCanvas(interactiveCanvas);
      }

      // Initialize audio
      function initAudio() {
        try {
          // Create audio context
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
          
          // Create gain nodes for different sound categories
          mainGainNode = audioContext.createGain();
          mainGainNode.gain.setValueAtTime(config.volume, audioContext.currentTime);
          mainGainNode.connect(audioContext.destination);
          
          ambientGainNode = audioContext.createGain();
          ambientGainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
          ambientGainNode.connect(mainGainNode);
          
          effectsGainNode = audioContext.createGain();
          effectsGainNode.gain.setValueAtTime(0.7, audioContext.currentTime);
          effectsGainNode.connect(mainGainNode);
          
          interactionGainNode = audioContext.createGain();
          interactionGainNode.gain.setValueAtTime(0.6, audioContext.currentTime);
          interactionGainNode.connect(mainGainNode);
          
          // Create analyser node for visualizations
          ambientAnalyser = audioContext.createAnalyser();
          ambientAnalyser.fftSize = 256;
          ambientGainNode.connect(ambientAnalyser);
          
          config.audioLoaded = true;
          
          // Show audio controls
          setTimeout(() => {
            audioControls.style.opacity = "1";
          }, 2000);
          
        } catch (error) {
          console.error('Web Audio API initialization failed:', error);
        }
      }

      // Audio synthesis functions
      function generateAubeSound() {
        if (!audioContext) return null;
        
        const oscillator1 = audioContext.createOscillator();
        const oscillator2 = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        oscillator1.type = 'sine';
        oscillator1.frequency.setValueAtTime(220, audioContext.currentTime);
        
        oscillator2.type = 'triangle';
        oscillator2.frequency.setValueAtTime(275, audioContext.currentTime);
        oscillator2.detune.setValueAtTime(5, audioContext.currentTime);
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 2);
        
        oscillator1.connect(gain);
        oscillator2.connect(gain);
        
        // Add LFO for subtle movement
        const lfo = audioContext.createOscillator();
        const lfoGain = audioContext.createGain();
        
        lfo.type = 'sine';
        lfo.frequency.value = 0.1;
        lfoGain.gain.value = 5;
        
        lfo.connect(lfoGain);
        lfoGain.connect(oscillator1.frequency);
        lfo.start();
        
        oscillator1.start();
        oscillator2.start();
        
        return {
          sourceNodes: [oscillator1, oscillator2, lfo],
          outputNode: gain,
          stop: function() {
            const now = audioContext.currentTime;
            gain.gain.linearRampToValueAtTime(0, now + 2);
            
            setTimeout(() => {
              oscillator1.stop();
              oscillator2.stop();
              lfo.stop();
            }, 2100);
          }
        };
      }

      function generateForetSound() {
        if (!audioContext) return null;
        
        const whiteNoise = createWhiteNoise();
        const filter = audioContext.createBiquadFilter();
        const gain = audioContext.createGain();
        
        filter.type = 'bandpass';
        filter.frequency.value = 500;
        filter.Q.value = 0.7;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 2);
        
        whiteNoise.connect(filter);
        filter.connect(gain);
        
        // LFO for filter movement
        const lfo = audioContext.createOscillator();
        const lfoGain = audioContext.createGain();
        
        lfo.type = 'sine';
        lfo.frequency.value = 0.05;
        lfoGain.gain.value = 200;
        
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        lfo.start();
        
        // Add occasional bird chirps
        const chirpInterval = setInterval(() => {
          if (Math.random() > 0.7) {
            const chirp = createBirdChirp();
            chirp.connect(gain);
          }
        }, 5000);
        
        return {
          sourceNodes: [whiteNoise, lfo],
          outputNode: gain,
          extras: [chirpInterval],
          stop: function() {
            const now = audioContext.currentTime;
            gain.gain.linearRampToValueAtTime(0, now + 2);
            clearInterval(chirpInterval);
            
            setTimeout(() => {
              lfo.stop();
              whiteNoise.disconnect();
            }, 2100);
          }
        };
      }

      function generateSilenceSound() {
        if (!audioContext) return null;
        
        // Very subtle ambient tone
        const oscillator = audioContext.createOscillator();
        const gain = audioContext.createGain();
        const filter = audioContext.createBiquadFilter();
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(40, audioContext.currentTime);
        
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 2);
        
        oscillator.connect(filter);
        filter.connect(gain);
        
        oscillator.start();
        
        return {
          sourceNodes: [oscillator],
          outputNode: gain,
          stop: function() {
            const now = audioContext.currentTime;
            gain.gain.linearRampToValueAtTime(0, now + 2);
            
            setTimeout(() => {
              oscillator.stop();
            }, 2100);
          }
        };
      }

      function generateNuitSound() {
        if (!audioContext) return null;
        
        const brownNoise = createBrownNoise();
        const filter = audioContext.createBiquadFilter();
        const gain = audioContext.createGain();
        
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 2);
        
        brownNoise.connect(filter);
        filter.connect(gain);
        
        // Add occasional distant sounds
        const soundInterval = setInterval(() => {
          if (Math.random() > 0.8) {
            const distant = createDistantSound();
            distant.connect(gain);
          }
        }, 8000);
        
        return {
          sourceNodes: [brownNoise],
          outputNode: gain,
          extras: [soundInterval],
          stop: function() {
            const now = audioContext.currentTime;
            gain.gain.linearRampToValueAtTime(0, now + 2);
            clearInterval(soundInterval);
            
            setTimeout(() => {
              brownNoise.disconnect();
            }, 2100);
          }
        };
      }

      function generateCrepusculeSound() {
        if (!audioContext) return null;
        
        const oscillator1 = audioContext.createOscillator();
        const oscillator2 = audioContext.createOscillator();
        const filter = audioContext.createBiquadFilter();
        const gain = audioContext.createGain();
        
        oscillator1.type = 'sine';
        oscillator1.frequency.setValueAtTime(146.83, audioContext.currentTime); // D3
        
        oscillator2.type = 'triangle';
        oscillator2.frequency.setValueAtTime(220, audioContext.currentTime); // A3
        
        filter.type = 'lowpass';
        filter.frequency.value = 1000;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 2);
        
        oscillator1.connect(filter);
        oscillator2.connect(filter);
        filter.connect(gain);
        
        // Add LFO for movement
        const lfo = audioContext.createOscillator();
        const lfoGain = audioContext.createGain();
        
        lfo.type = 'sine';
        lfo.frequency.value = 0.1;
        lfoGain.gain.value = 50;
        
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        lfo.start();
        
        oscillator1.start();
        oscillator2.start();
        
        return {
          sourceNodes: [oscillator1, oscillator2, lfo],
          outputNode: gain,
          stop: function() {
            const now = audioContext.currentTime;
            gain.gain.linearRampToValueAtTime(0, now + 2);
            
            setTimeout(() => {
              oscillator1.stop();
              oscillator2.stop();
              lfo.stop();
            }, 2100);
          }
        };
      }

      function generateRecueillementSound() {
        if (!audioContext) return null;
        
        const oscillator1 = audioContext.createOscillator();
        const oscillator2 = audioContext.createOscillator();
        const oscillator3 = audioContext.createOscillator();
        const gain = audioContext.createGain();
        const reverb = createReverb(2);
        
        oscillator1.type = 'sine';
        oscillator1.frequency.setValueAtTime(196, audioContext.currentTime); // G3
        
        oscillator2.type = 'sine';
        oscillator2.frequency.setValueAtTime(293.66, audioContext.currentTime); // D4
        
        oscillator3.type = 'sine';
        oscillator3.frequency.setValueAtTime(392, audioContext.currentTime); // G4
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.12, audioContext.currentTime + 3);
        
        oscillator1.connect(gain);
        oscillator2.connect(gain);
        oscillator3.connect(gain);
        gain.connect(reverb);
        
        oscillator1.start();
        oscillator2.start();
        oscillator3.start();
        
        return {
          sourceNodes: [oscillator1, oscillator2, oscillator3],
          outputNode: reverb,
          stop: function() {
            const now = audioContext.currentTime;
            gain.gain.linearRampToValueAtTime(0, now + 3);
            
            setTimeout(() => {
              oscillator1.stop();
              oscillator2.stop();
              oscillator3.stop();
            }, 3100);
          }
        };
      }

      // Sound effect functions
      function generateBirdSound() {
        if (!audioContext) return null;
        
        const oscillator = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(2000, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(3000, audioContext.currentTime + 0.1);
        oscillator.frequency.exponentialRampToValueAtTime(1500, audioContext.currentTime + 0.2);
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.05);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
        
        oscillator.connect(gain);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
        
        return gain;
      }

      function generateLightWindSound() {
        if (!audioContext) return null;
        
        const whiteNoise = createWhiteNoise();
        const filter = audioContext.createBiquadFilter();
        const gain = audioContext.createGain();
        
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 0.5;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.5);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 3);
        
        whiteNoise.connect(filter);
        filter.connect(gain);
        
        setTimeout(() => {
          whiteNoise.disconnect();
        }, 3100);
        
        return gain;
      }

      function generateFootstepsSound() {
        if (!audioContext) return null;
        
        const gain = audioContext.createGain();
        gain.gain.setValueAtTime(0.2, audioContext.currentTime);
        
        const playStep = () => {
          const noise = createWhiteNoise();
          const filter = audioContext.createBiquadFilter();
          const stepGain = audioContext.createGain();
          
          filter.type = 'bandpass';
          filter.frequency.value = 200 + Math.random() * 100;
          
          stepGain.gain.setValueAtTime(0, audioContext.currentTime);
          stepGain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.05);
          stepGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
          
          noise.connect(filter);
          filter.connect(stepGain);
          stepGain.connect(gain);
          
          setTimeout(() => {
            noise.disconnect();
          }, 300);
        };
        
        // Play a sequence of steps
        playStep();
        setTimeout(playStep, 500);
        setTimeout(playStep, 1000);
        
        return gain;
      }

      function generateBranchesSound() {
        if (!audioContext) return null;
        
        const gain = audioContext.createGain();
        gain.gain.setValueAtTime(0.15, audioContext.currentTime);
        
        const playCrack = () => {
          const noise = createWhiteNoise();
          const filter = audioContext.createBiquadFilter();
          const crackGain = audioContext.createGain();
          
          filter.type = 'highpass';
          filter.frequency.value = 2000;
          
          crackGain.gain.setValueAtTime(0, audioContext.currentTime);
          crackGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.02);
          crackGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
          
          noise.connect(filter);
          filter.connect(crackGain);
          crackGain.connect(gain);
          
          setTimeout(() => {
            noise.disconnect();
          }, 300);
        };
        
        if (Math.random() > 0.7) {
          playCrack();
          setTimeout(playCrack, 200 + Math.random() * 300);
        }
        
        return gain;
      }

      function generateHeartbeatSound() {
        if (!audioContext) return null;
        
        const gain = audioContext.createGain();
        gain.gain.setValueAtTime(0.2, audioContext.currentTime);
        
        const playBeat = () => {
          const oscillator = audioContext.createOscillator();
          const beatGain = audioContext.createGain();
          
          oscillator.type = 'sine';
          oscillator.frequency.value = 60;
          
          beatGain.gain.setValueAtTime(0, audioContext.currentTime);
          beatGain.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
          beatGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
          
          oscillator.connect(beatGain);
          beatGain.connect(gain);
          
          oscillator.start();
          oscillator.stop(audioContext.currentTime + 0.3);
        };
        
        playBeat();
        setTimeout(playBeat, 300);
        
        return gain;
      }

      function generateBreathingSound() {
        if (!audioContext) return null;
        
        const noise = createWhiteNoise();
        const filter = audioContext.createBiquadFilter();
        const gain = audioContext.createGain();
        
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 1);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 3);
        
        noise.connect(filter);
        filter.connect(gain);
        
        setTimeout(() => {
          noise.disconnect();
        }, 3100);
        
        return gain;
      }

      function generateSlowFootstepsSound() {
        if (!audioContext) return null;
        
        const gain = audioContext.createGain();
        gain.gain.setValueAtTime(0.2, audioContext.currentTime);
        
        const playStep = () => {
          const noise = createWhiteNoise();
          const filter = audioContext.createBiquadFilter();
          const stepGain = audioContext.createGain();
          
          filter.type = 'bandpass';
          filter.frequency.value = 150 + Math.random() * 50;
          
          stepGain.gain.setValueAtTime(0, audioContext.currentTime);
          stepGain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.1);
          stepGain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);
          
          noise.connect(filter);
          filter.connect(stepGain);
          stepGain.connect(gain);
          
          setTimeout(() => {
            noise.disconnect();
          }, 500);
        };
        
        // Play slower steps
        playStep();
        setTimeout(playStep, 1000);
        
        return gain;
      }

      function generateDarkWindSound() {
        if (!audioContext) return null;
        
        const brownNoise = createBrownNoise();
        const filter = audioContext.createBiquadFilter();
        const gain = audioContext.createGain();
        
        filter.type = 'bandpass';
        filter.frequency.value = 300;
        filter.Q.value = 0.8;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 1);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 4);
        
        brownNoise.connect(filter);
        filter.connect(gain);
        
        setTimeout(() => {
          brownNoise.disconnect();
        }, 4100);
        
        return gain;
      }

      function generateDistantWavesSound() {
        if (!audioContext) return null;
        
        const noise = createWhiteNoise();
        const filter = audioContext.createBiquadFilter();
        const gain = audioContext.createGain();
        
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 1);
        gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 2);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 4);
        
        noise.connect(filter);
        filter.connect(gain);
        
        // LFO for wave-like effect
        const lfo = audioContext.createOscillator();
        const lfoGain = audioContext.createGain();
        
        lfo.type = 'sine';
        lfo.frequency.value = 0.2;
        lfoGain.gain.value = 0.05;
        
        lfo.connect(lfoGain);
        lfoGain.connect(gain.gain);
        lfo.start();
        
        setTimeout(() => {
          noise.disconnect();
          lfo.stop();
        }, 4100);
        
        return gain;
      }

      function generateSailsWindSound() {
        if (!audioContext) return null;
        
        const whiteNoise = createWhiteNoise();
        const filter = audioContext.createBiquadFilter();
        const gain = audioContext.createGain();
        
        filter.type = 'bandpass';
        filter.frequency.value = 600;
        filter.Q.value = 1;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.5);
        gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 1);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 3);
        
        whiteNoise.connect(filter);
        filter.connect(gain);
        
        setTimeout(() => {
          whiteNoise.disconnect();
        }, 3100);
        
        return gain;
      }

      function generateHumbleSound() {
        if (!audioContext) return null;
        
        const oscillator = audioContext.createOscillator();
        const gain = audioContext.createGain();
        const reverb = createReverb(3);
        
        oscillator.type = 'sine';
        oscillator.frequency.value = 196; // G3
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.5);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 4);
        
        oscillator.connect(gain);
        gain.connect(reverb);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 4);
        
        return reverb;
      }

      function generateLeavesWindSound() {
        if (!audioContext) return null;
        
        const whiteNoise = createWhiteNoise();
        const filter = audioContext.createBiquadFilter();
        const gain = audioContext.createGain();
        
        filter.type = 'highpass';
        filter.frequency.value = 3000;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.5);
        gain.gain.linearRampToValueAtTime(0.08, audioContext.currentTime + 1);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 3);
        
        whiteNoise.connect(filter);
        filter.connect(gain);
        
        setTimeout(() => {
          whiteNoise.disconnect();
        }, 3100);
        
        return gain;
      }

      // Interaction sounds
      function generateClickSound() {
        if (!audioContext) return null;
        
        const oscillator = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.value = 400 + Math.random() * 200;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.01);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);
        
        oscillator.connect(gain);
        gain.connect(interactionGainNode);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.2);
      }

      function generateTransitionSound() {
        if (!audioContext) return null;
        
        const oscillator1 = audioContext.createOscillator();
        const oscillator2 = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        oscillator1.type = 'sine';
        oscillator1.frequency.value = 300;
        oscillator1.frequency.linearRampToValueAtTime(500, audioContext.currentTime + 1);
        
        oscillator2.type = 'sine';
        oscillator2.frequency.value = 400;
        oscillator2.frequency.linearRampToValueAtTime(600, audioContext.currentTime + 1);
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.1);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
        
        oscillator1.connect(gain);
        oscillator2.connect(gain);
        gain.connect(interactionGainNode);
        
        oscillator1.start();
        oscillator1.stop(audioContext.currentTime + 1);
        
        oscillator2.start();
        oscillator2.stop(audioContext.currentTime + 1);
      }

      function generateHoverSound() {
        if (!audioContext) return null;
        
        const oscillator = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.value = 600;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.05);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.1);
        
        oscillator.connect(gain);
        gain.connect(interactionGainNode);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 0.1);
      }

      // Audio utility functions
      function createWhiteNoise() {
        const bufferSize = 2 * audioContext.sampleRate;
        const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        
        const whiteNoise = audioContext.createBufferSource();
        whiteNoise.buffer = noiseBuffer;
        whiteNoise.loop = true;
        whiteNoise.start();
        
        return whiteNoise;
      }

      function createBrownNoise() {
        const bufferSize = 2 * audioContext.sampleRate;
        const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        
        let lastOut = 0;
        for (let i = 0; i < bufferSize; i++) {
          const white = Math.random() * 2 - 1;
          output[i] = (lastOut + (0.02 * white)) / 1.02;
          lastOut = output[i];
          output[i] *= 3.5;
        }
        
        const brownNoise = audioContext.createBufferSource();
        brownNoise.buffer = noiseBuffer;
        brownNoise.loop = true;
        brownNoise.start();
        
        return brownNoise;
      }

      function createBirdChirp() {
        const oscillator = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        const now = audioContext.currentTime;
        const randomFreq = 2000 + Math.random() * 1000;
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(randomFreq, now);
        oscillator.frequency.exponentialRampToValueAtTime(randomFreq * 1.5, now + 0.1);
        oscillator.frequency.exponentialRampToValueAtTime(randomFreq * 0.8, now + 0.2);
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.1, now + 0.05);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        
        oscillator.connect(gain);
        
        oscillator.start();
        oscillator.stop(now + 0.2);
        
        return gain;
      }

      function createDistantSound() {
        const oscillator = audioContext.createOscillator();
        const gain = audioContext.createGain();
        const reverb = createReverb(2);
        
        oscillator.type = 'sine';
        oscillator.frequency.value = 200 + Math.random() * 100;
        
        gain.gain.setValueAtTime(0, audioContext.currentTime);
        gain.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.2);
        gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 1);
        
        oscillator.connect(gain);
        gain.connect(reverb);
        
        oscillator.start();
        oscillator.stop(audioContext.currentTime + 1);
        
        return reverb;
      }

      function createReverb(duration) {
        const sampleRate = audioContext.sampleRate;
        const length = sampleRate * duration;
        const impulse = audioContext.createBuffer(2, length, sampleRate);
        const impulseL = impulse.getChannelData(0);
        const impulseR = impulse.getChannelData(1);
        
        for (let i = 0; i < length; i++) {
          const n = i / length;
          impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, 2);
          impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, 2);
        }
        
        const convolver = audioContext.createConvolver();
        convolver.buffer = impulse;
        
        return convolver;
      }

      // Play ambient sound for current scene
      function playAmbientSound() {
        if (!config.audioLoaded || config.muted) return;
        
        const scene = config.scenes[config.currentScene];
        const ambientType = scene.audio.ambient;
        
        // Stop current ambient if it exists
        if (currentAmbientSource) {
          currentAmbientSource.stop();
        }
        
        // Create new ambient
        const ambientCreator = config.audioSources[ambientType];
        if (typeof ambientCreator === 'function') {
          const ambientSound = ambientCreator();
          
          if (ambientSound) {
            ambientSound.outputNode.connect(ambientGainNode);
            currentAmbientSource = ambientSound;
          }
        }
      }

      // Play random effect sounds from the current scene
      function playEffectSounds() {
        if (!config.audioLoaded || config.muted) return;
        
        const scene = config.scenes[config.currentScene];
        const effects = scene.audio.effects;
        
        // Randomly choose effects and play them
        const effectsInterval = setInterval(() => {
          if (config.currentScene !== scene || config.muted) {
            clearInterval(effectsInterval);
            return;
          }
          
          if (Math.random() > 0.7) {
            const effectType = effects[Math.floor(Math.random() * effects.length)];
            const effectCreator = config.audioSources[effectType];
            
            if (typeof effectCreator === 'function') {
              const effect = effectCreator();
              if (effect) {
                effect.connect(effectsGainNode);
              }
            }
          }
        }, 5000);
        
        return effectsInterval;
      }

      // Update volume
      function updateVolume() {
        if (masterGain) {
    if (isMuted) {
      masterGain.gain.value = 0;
      if (elements.muteButton) {
        elements.muteButton.textContent = '🔇';
      }
    } else {
      const volume = elements.volumeSlider ? elements.volumeSlider.value / 100 : 0.7;
      masterGain.gain.value = volume;
      if (elements.muteButton) {
        elements.muteButton.textContent = '🔊';
      }
    }
  }
  
  // Gérer le volume de la musique de fond
  if (backgroundMusic) {
    if (isMuted) {
      backgroundMusic.volume = 0;
    } else {
      const volume = elements.volumeSlider ? elements.volumeSlider.value / 100 : 0.5;
      backgroundMusic.volume = volume;
    }
  }
}
      

      // Generate cubist background
      function drawBackground() {
        const colors = config.scenes[config.currentScene].colors;
        
        // Clear background
        bgCtx.fillStyle = colors.background;
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        
        // Draw geometric background elements
        const numShapes = 20;
        for (let i = 0; i < numShapes; i++) {
          const size = Math.random() * bgCanvas.width * 0.5 + bgCanvas.width * 0.1;
          const x = Math.random() * bgCanvas.width;
          const y = Math.random() * bgCanvas.height;
          const opacity = Math.random() * 0.2 + 0.05;
          
          // Choose color
          const colorChoice = Math.random();
          let color;
          
          if (colorChoice < 0.4) {
            color = colors.primary;
          } else if (colorChoice < 0.8) {
            color = colors.secondary;
          } else {
            color = colors.accent;
          }
          
          // Draw shape
          bgCtx.fillStyle = `rgba(${hexToRgb(color)}, ${opacity})`;
          bgCtx.beginPath();
          
          if (Math.random() < 0.6) {
            // Polygon
            const sides = Math.floor(Math.random() * 3) + 3; // 3 to 5 sides
            const angleOffset = Math.random() * Math.PI * 2;
            
            bgCtx.moveTo(
              x + size * Math.cos(angleOffset),
              y + size * Math.sin(angleOffset)
            );
            
            for (let j = 1; j <= sides; j++) {
              const angle = j * (Math.PI * 2) / sides + angleOffset;
              const radius = size * (0.7 + Math.random() * 0.3);
              
              bgCtx.lineTo(
                x + radius * Math.cos(angle),
                y + radius * Math.sin(angle)
              );
            }
          } else {
            // Rectangle
            const width = size * (0.5 + Math.random() * 0.5);
            const height = size * (0.5 + Math.random() * 0.5);
            const angle = Math.random() * Math.PI / 4;
            
            bgCtx.save();
            bgCtx.translate(x, y);
            bgCtx.rotate(angle);
            bgCtx.rect(-width/2, -height/2, width, height);
            bgCtx.restore();
          }
          
          bgCtx.fill();
        }
      }

      // Generate cubist shapes for the current scene
      function generateShapes() {
        config.shapes = [];
        const colors = config.scenes[config.currentScene].colors;
        
        // Different shape generation based on scene
        switch(config.currentScene) {
          case 0: // L'Aube - Dawn shapes
            generateDawnShapes(colors);
            break;
          case 1: // Le Voyage - Path and mountain shapes
            generatePathShapes(colors);
            break;
          case 2: // La Solitude - Figure focused on thoughts
            generateThoughtShapes(colors);
            break;
          case 3: // Le Cheminement - Bent figure walking
            generateFigureShapes(colors);
            break;
          case 4: // L'Indifférence - Abstract shapes ignoring beauty
            generateIndifferenceShapes(colors);
            break;
          case 5: // L'Arrivée - Grave and flowers
            generateTombShapes(colors);
            break;
        }
      }

      // Scene-specific shape generators
      function generateDawnShapes(colors) {
        // Sun/dawn shapes
        const centerX = mainCanvas.width * 0.5;
        const horizonY = mainCanvas.height * 0.6;
        
        // Sun
        config.shapes.push({
          type: 'sun',
          x: centerX,
          y: horizonY * 0.5,
          size: mainCanvas.width * 0.15,
          fillColor: colors.accent,
          opacity: 0.9,
          rays: 12,
          animOffset: 0,
          speedFactor: 1
        });
        
        // Horizon shapes (fields)
        for (let i = 0; i < 20; i++) {
          const width = mainCanvas.width * (0.05 + Math.random() * 0.15);
          const height = mainCanvas.height * (0.05 + Math.random() * 0.1);
          const x = mainCanvas.width * Math.random();
          const y = horizonY + Math.random() * (mainCanvas.height - horizonY) * 0.7;
          
          config.shapes.push({
            type: 'field',
            x, y,
            width, height,
            fillColor: Math.random() < 0.5 ? colors.primary : colors.secondary,
            opacity: Math.random() * 0.5 + 0.5,
            angle: Math.random() * 0.1 - 0.05,
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: Math.random() * 0.3 + 0.1
          });
        }
        
        // Person figure (distant)
        config.shapes.push({
          type: 'figure',
          x: centerX,
          y: horizonY * 1.1,
          size: mainCanvas.width * 0.05,
          fillColor: colors.primary,
          opacity: 0.8,
          animOffset: 0,
          speedFactor: 0.3
        });
        
        // Add whiteness to the horizon (blanchit la campagne)
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * mainCanvas.width;
          const y = horizonY + Math.random() * 40 - 20;
          const size = mainCanvas.width * (0.03 + Math.random() * 0.08);
          
          config.shapes.push({
            type: 'light',
            x, y, size,
            fillColor: '#ffffff',
            opacity: Math.random() * 0.3 + 0.1,
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: Math.random() * 0.5 + 0.3
          });
        }
      }

      function generatePathShapes(colors) {
        const centerX = mainCanvas.width * 0.5;
        const horizonY = mainCanvas.height * 0.6;
        
        // Mountains
        for (let i = 0; i < 8; i++) {
          const x = mainCanvas.width * (0.1 + Math.random() * 0.8);
          const y = horizonY - mainCanvas.height * (0.05 + Math.random() * 0.2);
          const size = mainCanvas.width * (0.15 + Math.random() * 0.2);
          
          config.shapes.push({
            type: 'mountain',
            x, y, size,
            fillColor: i % 2 === 0 ? colors.primary : colors.secondary,
            opacity: 0.7 - (i * 0.05),
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: 0.2
          });
        }
        
        // Forest elements
        for (let i = 0; i < 15; i++) {
          const x = mainCanvas.width * (0.1 + Math.random() * 0.8);
          const y = mainCanvas.height * (0.6 + Math.random() * 0.3);
          const size = mainCanvas.height * (0.1 + Math.random() * 0.15);
          
          config.shapes.push({
            type: 'tree',
            x, y, size,
            fillColor: i % 3 === 0 ? colors.accent : colors.secondary,
            opacity: Math.random() * 0.4 + 0.6,
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: Math.random() * 0.3 + 0.2
          });
        }
        
        // Path shapes
        const pathPoints = 10;
        const pathWidth = mainCanvas.width * 0.1;
        
        for (let i = 0; i < pathPoints; i++) {
          const progress = i / (pathPoints - 1);
          const x = centerX + Math.sin(progress * Math.PI * 2) * mainCanvas.width * 0.1;
          const y = horizonY * 0.9 + progress * mainCanvas.height * 0.5;
          
          config.shapes.push({
            type: 'path',
            x, y,
            width: pathWidth * (1 - progress * 0.5),
            height: mainCanvas.height * 0.03,
            fillColor: colors.secondary,
            opacity: 0.6,
            animOffset: progress * Math.PI,
            speedFactor: 0.2
          });
        }
        
        // Figure walking
        config.shapes.push({
          type: 'figure',
          x: centerX,
          y: horizonY * 1.2,
          size: mainCanvas.width * 0.08,
          fillColor: colors.primary,
          opacity: 0.9,
          animOffset: 0,
          speedFactor: 0.5,
          walking: true
        });
      }

      function generateThoughtShapes(colors) {
        const centerX = mainCanvas.width * 0.5;
        const centerY = mainCanvas.height * 0.5;
        
        // Central figure
        config.shapes.push({
          type: 'figure',
          x: centerX,
          y: centerY * 1.2,
          size: mainCanvas.width * 0.12,
          fillColor: colors.primary,
          opacity: 0.9,
          animOffset: 0,
          speedFactor: 0.3
        });
        
        // Thought bubbles/fragments
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * mainCanvas.width * 0.3 + mainCanvas.width * 0.1;
          const x = centerX + Math.cos(angle) * distance;
          const y = centerY + Math.sin(angle) * distance * 0.6;
          const size = mainCanvas.width * (0.02 + Math.random() * 0.05);
          
          config.shapes.push({
            type: 'thought',
            x, y, size,
            fillColor: i % 3 === 0 ? colors.accent : colors.secondary,
            opacity: Math.random() * 0.5 + 0.5,
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: Math.random() * 0.5 + 0.5,
            angle: Math.random() * Math.PI * 2
          });
        }
        
        // Abstract dark shapes (representing blindness to surroundings)
        for (let i = 0; i < 12; i++) {
          const x = Math.random() * mainCanvas.width;
          const y = Math.random() * mainCanvas.height;
          const size = mainCanvas.width * (0.08 + Math.random() * 0.15);
          
          config.shapes.push({
            type: 'void',
            x, y, size,
            fillColor: colors.background,
            opacity: Math.random() * 0.3 + 0.1,
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: Math.random() * 0.2 + 0.1
          });
        }
        
        // Eyes fixed on thoughts visualization
        config.shapes.push({
          type: 'focusedEyes',
          x: centerX,
          y: centerY * 0.9,
          size: mainCanvas.width * 0.1,
          fillColor: colors.primary,
          opacity: 0.7,
          animOffset: 0,
          speedFactor: 0.3
        });
      }

      function generateFigureShapes(colors) {
        const centerX = mainCanvas.width * 0.5;
        const centerY = mainCanvas.height * 0.5;
        
        // Bent figure
        config.shapes.push({
          type: 'bentFigure',
          x: centerX,
          y: centerY * 1.1,
          size: mainCanvas.width * 0.2,
          fillColor: colors.primary,
          opacity: 0.9,
          animOffset: 0,
          speedFactor: 0.3
        });
        
        // Dark surroundings (representing night)
        for (let i = 0; i < 15; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * mainCanvas.width * 0.5 + mainCanvas.width * 0.1;
          const x = centerX + Math.cos(angle) * distance;
          const y = centerY + Math.sin(angle) * distance;
          const size = mainCanvas.width * (0.1 + Math.random() * 0.15);
          
          config.shapes.push({
            type: 'shadow',
            x, y, size,
            fillColor: colors.background,
            opacity: Math.random() * 0.5 + 0.2,
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: Math.random() * 0.2 + 0.1
          });
        }
        
        // Internal thoughts (abstract shapes near the figure)
        for (let i = 0; i < 10; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * mainCanvas.width * 0.15 + mainCanvas.width * 0.05;
          const x = centerX + Math.cos(angle) * distance;
          const y = centerY + Math.sin(angle) * distance;
          const size = mainCanvas.width * (0.03 + Math.random() * 0.05);
          
          config.shapes.push({
            type: 'thought',
            x, y, size,
            fillColor: Math.random() < 0.5 ? colors.secondary : colors.accent,
            opacity: Math.random() * 0.6 + 0.4,
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: Math.random() * 0.5 + 0.5
          });
        }
        
        // Crossed hands visualization
        config.shapes.push({
          type: 'crossedHands',
          x: centerX,
          y: centerY * 1.4,
          size: mainCanvas.width * 0.08,
          fillColor: colors.primary,
          opacity: 0.8,
          animOffset: 0,
          speedFactor: 0.2
        });
      }

      function generateIndifferenceShapes(colors) {
        const centerX = mainCanvas.width * 0.5;
        const centerY = mainCanvas.height * 0.5;
        
        // Walking figure
        config.shapes.push({
          type: 'figure',
          x: centerX,
          y: centerY * 1.2,
          size: mainCanvas.width * 0.15,
          fillColor: colors.primary,
          opacity: 0.9,
          animOffset: 0,
          speedFactor: 0.4,
          walking: true
        });
        
        // Beautiful sunset ignored (dimmed)
        const sunsetY = mainCanvas.height * 0.4;
        
        config.shapes.push({
          type: 'sunset',
          x: mainCanvas.width * 0.7,
          y: sunsetY,
          size: mainCanvas.width * 0.2,
          fillColor: colors.accent,
          opacity: 0.3, // Dimmed because ignored
          animOffset: 0,
          speedFactor: 0.1
        });
        
        // Ships in the distance (Harfleur)
        for (let i = 0; i < 3; i++) {
          const x = mainCanvas.width * (0.6 + i * 0.1);
          const y = mainCanvas.height * 0.55;
          const size = mainCanvas.width * (0.05 - i * 0.01);
          
          config.shapes.push({
            type: 'ship',
            x, y, size,
            fillColor: colors.secondary,
            opacity: 0.25, // Dimmed because ignored
            animOffset: i * Math.PI / 2,
            speedFactor: 0.2
          });
        }
        
        // Barrier shapes between figure and beauty (representing indifference)
        for (let i = 0; i < 8; i++) {
          const progress = i / 7;
          const x = centerX + (mainCanvas.width * 0.3) * progress;
          const y = centerY * (0.8 + progress * 0.4);
          const height = mainCanvas.height * (0.2 + Math.random() * 0.3);
          
          config.shapes.push({
            type: 'barrier',
            x, y,
            width: mainCanvas.width * 0.03,
            height,
            fillColor: colors.primary,
            opacity: 0.7 - progress * 0.3,
            animOffset: progress * Math.PI,
            speedFactor: 0.15
          });
        }
        
        // "L'or du soir" (gold of evening) representation
        config.shapes.push({
          type: 'eveningGold',
          x: mainCanvas.width * 0.8,
          y: mainCanvas.height * 0.3,
          size: mainCanvas.width * 0.1,
          fillColor: '#FFC107',
          opacity: 0.4,
          animOffset: 0,
          speedFactor: 0.2
        });
      }

      function generateTombShapes(colors) {
        const centerX = mainCanvas.width * 0.5;
        const groundY = mainCanvas.height * 0.65;
        
        // Tomb
        config.shapes.push({
          type: 'tomb',
          x: centerX,
          y: groundY,
          width: mainCanvas.width * 0.18,
          height: mainCanvas.height * 0.25,
          fillColor: colors.secondary,
          opacity: 0.9,
          animOffset: 0,
          speedFactor: 0.1
        });
        
        // Figure kneeling/standing at tomb
        config.shapes.push({
          type: 'mourningFigure',
          x: centerX - mainCanvas.width * 0.1,
          y: groundY,
          size: mainCanvas.width * 0.12,
          fillColor: colors.primary,
          opacity: 0.95,
          animOffset: 0,
          speedFactor: 0.2
        });
        
        // Holly and heather flowers
        for (let i = 0; i < 15; i++) {
          const isHolly = i < 7;
          const angle = Math.random() * Math.PI - Math.PI/2; // Top semicircle
          const distance = mainCanvas.width * (0.05 + Math.random() * 0.07);
          const x = centerX + Math.cos(angle) * distance;
          const y = groundY - mainCanvas.height * 0.12 + Math.sin(angle) * distance;
          
          config.shapes.push({
            type: isHolly ? 'holly' : 'heather',
            x, y,
            size: mainCanvas.width * (0.02 + Math.random() * 0.02),
            fillColor: isHolly ? '#30634a' : colors.accent,
            opacity: 0.9,
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: Math.random() * 0.3 + 0.3
          });
        }
        
        // Emotional particles around the scene
        for (let i = 0; i < 20; i++) {
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * mainCanvas.width * 0.4 + mainCanvas.width * 0.1;
          const x = centerX + Math.cos(angle) * distance;
          const y = groundY + Math.sin(angle) * distance * 0.6 - mainCanvas.height * 0.1;
          
          config.shapes.push({
            type: 'emotion',
            x, y,
            size: mainCanvas.width * (0.01 + Math.random() * 0.03),
            fillColor: i % 3 === 0 ? colors.accent : colors.secondary,
            opacity: Math.random() * 0.6 + 0.2,
            animOffset: Math.random() * Math.PI * 2,
            speedFactor: Math.random() * 0.5 + 0.3
          });
        }
        
        // Bouquet detail
        config.shapes.push({
          type: 'bouquet',
          x: centerX + mainCanvas.width * 0.05,
          y: groundY - mainCanvas.height * 0.05,
          size: mainCanvas.width * 0.07,
          fillColor: colors.accent,
          opacity: 0.9,
          animOffset: 0,
          speedFactor: 0.1
        });
      }

      // Draw all shapes
      function drawShapes(time) {
        ctx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
        
        config.shapes.forEach(shape => {
          ctx.globalAlpha = shape.opacity;
          
          // Apply subtle animation based on time
          const animFactor = Math.sin(time * 0.001 * shape.speedFactor + shape.animOffset) * 5;
          
          ctx.save();
          
          // Draw different shapes based on type
          switch(shape.type) {
            case 'polygon':
              drawPolygon(shape, animFactor);
              break;
            case 'rect':
              drawRect(shape, animFactor);
              break;
            case 'sun':
              drawSun(shape, animFactor, time);
              break;
            case 'field':
              drawField(shape, animFactor);
              break;
            case 'figure':
              drawFigure(shape, animFactor, time);
              break;
            case 'mountain':
              drawMountain(shape, animFactor);
              break;
            case 'tree':
              drawTree(shape, animFactor);
              break;
            case 'path':
              drawPath(shape, animFactor);
              break;
            case 'thought':
              drawThought(shape, animFactor, time);
              break;
            case 'void':
              drawVoid(shape, animFactor);
              break;
            case 'bentFigure':
              drawBentFigure(shape, animFactor);
              break;
            case 'shadow':
              drawShadow(shape, animFactor);
              break;
            case 'sunset':
              drawSunset(shape, animFactor, time);
              break;
            case 'ship':
              drawShip(shape, animFactor);
              break;
            case 'barrier':
              drawBarrier(shape, animFactor);
              break;
            case 'tomb':
              drawTomb(shape, animFactor);
              break;
            case 'mourningFigure':
              drawMourningFigure(shape, animFactor, time);
              break;
            case 'holly':
              drawHolly(shape, animFactor, time);
              break;
            case 'heather':
              drawHeather(shape, animFactor, time);
              break;
            case 'emotion':
              drawEmotion(shape, animFactor, time);
              break;
            case 'light':
              drawLight(shape, animFactor, time);
              break;
            case 'focusedEyes':
              drawFocusedEyes(shape, animFactor, time);
              break;
            case 'crossedHands':
              drawCrossedHands(shape, animFactor, time);
              break;
            case 'eveningGold':
              drawEveningGold(shape, animFactor, time);
              break;
            case 'bouquet':
              drawBouquet(shape, animFactor, time);
              break;
          }
          
          ctx.restore();
        });
      }

      // Shape drawing functions
      function drawPolygon(shape, animFactor) {
        const sides = shape.sides;
        const radius = shape.size + animFactor;
        
        ctx.fillStyle = shape.fillColor;
        ctx.beginPath();
        
        for (let i = 0; i <= sides; i++) {
          const angle = i * (Math.PI * 2) / sides + shape.angle;
          const x = shape.x + radius * Math.cos(angle);
          const y = shape.y + radius * Math.sin(angle);
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.closePath();
        ctx.fill();
      }

      function drawRect(shape, animFactor) {
        const width = shape.size + animFactor;
        const height = shape.size * 0.7 + animFactor;
        
        ctx.fillStyle = shape.fillColor;
        ctx.translate(shape.x, shape.y);
        ctx.rotate(shape.angle);
        ctx.fillRect(-width/2, -height/2, width, height);
      }

      function drawSun(shape, animFactor, time) {
        const radius = shape.size + animFactor;
        
        // Main sun circle
        ctx.fillStyle = shape.fillColor;
        ctx.beginPath();
        ctx.arc(shape.x, shape.y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Rays
        ctx.strokeStyle = shape.fillColor;
        ctx.lineWidth = radius * 0.1;
        
        for (let i = 0; i < shape.rays; i++) {
          const angle = i * (Math.PI * 2) / shape.rays + time * 0.0005;
          const innerRadius = radius * 1.2;
          const outerRadius = radius * 1.8 + Math.sin(time * 0.001 + i) * radius * 0.1;
          
          ctx.globalAlpha = shape.opacity * 0.7;
          ctx.beginPath();
          ctx.moveTo(
            shape.x + Math.cos(angle) * innerRadius,
            shape.y + Math.sin(angle) * innerRadius
          );
          ctx.lineTo(
            shape.x + Math.cos(angle) * outerRadius,
            shape.y + Math.sin(angle) * outerRadius
          );
          ctx.stroke();
        }
        
        // Inner glow
        const gradient = ctx.createRadialGradient(
          shape.x, shape.y, 0,
          shape.x, shape.y, radius
        );
        gradient.addColorStop(0, '#ffffff');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(shape.x, shape.y, radius * 0.8, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawField(shape, animFactor) {
        ctx.fillStyle = shape.fillColor;
        ctx.translate(shape.x, shape.y);
        ctx.rotate(shape.angle);
        
        // Draw abstract field shape (trapezoid)
        ctx.beginPath();
        ctx.moveTo(-shape.width/2, -shape.height/2);
        ctx.lineTo(shape.width/2, -shape.height/2);
        ctx.lineTo(shape.width/2 + animFactor, shape.height/2);
        ctx.lineTo(-shape.width/2 + animFactor, shape.height/2);
        ctx.closePath();
        ctx.fill();
      }

      function drawFigure(shape, animFactor, time) {
        ctx.fillStyle = shape.fillColor;
        
        // Head
        ctx.beginPath();
        ctx.arc(shape.x, shape.y - shape.size * 0.5, shape.size * 0.25, 0, Math.PI * 2);
        ctx.fill();
        
        // Body
        ctx.beginPath();
        ctx.moveTo(shape.x, shape.y - shape.size * 0.25);
        ctx.lineTo(shape.x - shape.size * 0.2, shape.y + shape.size * 0.5);
        ctx.lineTo(shape.x + shape.size * 0.2, shape.y + shape.size * 0.5);
        ctx.closePath();
        ctx.fill();
        
        // Arms
        if (shape.walking) {
          // Walking animation
          const armAngle = Math.sin(time * 0.002) * 0.2;
          
          ctx.beginPath();
          ctx.moveTo(shape.x, shape.y - shape.size * 0.1);
          ctx.lineTo(
            shape.x - shape.size * 0.4 * Math.cos(armAngle),
            shape.y + shape.size * 0.4 * Math.sin(armAngle)
          );
          ctx.lineWidth = shape.size * 0.08;
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(shape.x, shape.y - shape.size * 0.1);
          ctx.lineTo(
            shape.x + shape.size * 0.4 * Math.cos(armAngle),
            shape.y + shape.size * 0.4 * Math.sin(armAngle)
          );
          ctx.stroke();
          
          // Legs with walking animation
          const legAngle = Math.sin(time * 0.002 + Math.PI) * 0.3;
          
          ctx.beginPath();
          ctx.moveTo(shape.x - shape.size * 0.1, shape.y + shape.size * 0.4);
          ctx.lineTo(
            shape.x - shape.size * 0.2 + shape.size * 0.3 * Math.sin(legAngle),
            shape.y + shape.size * 0.9
          );
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(shape.x + shape.size * 0.1, shape.y + shape.size * 0.4);
          ctx.lineTo(
            shape.x + shape.size * 0.2 + shape.size * 0.3 * Math.sin(legAngle + Math.PI),
            shape.y + shape.size * 0.9
          );
          ctx.stroke();
        } else {
          // Static figure
          ctx.beginPath();
          ctx.moveTo(shape.x, shape.y - shape.size * 0.1);
          ctx.lineTo(shape.x - shape.size * 0.4, shape.y + shape.size * 0.2);
          ctx.lineWidth = shape.size * 0.08;
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(shape.x, shape.y - shape.size * 0.1);
          ctx.lineTo(shape.x + shape.size * 0.4, shape.y + shape.size * 0.2);
          ctx.stroke();
          
          // Legs
          ctx.beginPath();
          ctx.moveTo(shape.x - shape.size * 0.1, shape.y + shape.size * 0.4);
          ctx.lineTo(shape.x - shape.size * 0.2, shape.y + shape.size * 0.9);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(shape.x + shape.size * 0.1, shape.y + shape.size * 0.4);
          ctx.lineTo(shape.x + shape.size * 0.2, shape.y + shape.size * 0.9);
          ctx.stroke();
        }
      }

      function drawMountain(shape, animFactor) {
        ctx.fillStyle = shape.fillColor;
        
        // Angular mountain shape
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.size, shape.y + shape.size * 0.5);
        ctx.lineTo(shape.x - shape.size * 0.5, shape.y - shape.size * 0.3 + animFactor);
        ctx.lineTo(shape.x, shape.y - shape.size * 0.5 + animFactor * 0.5);
        ctx.lineTo(shape.x + shape.size * 0.4, shape.y - shape.size * 0.2 + animFactor);
        ctx.lineTo(shape.x + shape.size, shape.y + shape.size * 0.5);
        ctx.closePath();
        ctx.fill();
      }

      function drawTree(shape, animFactor) {
        ctx.fillStyle = shape.fillColor;
        
        // Trunk
        ctx.fillRect(
          shape.x - shape.size * 0.1,
          shape.y - shape.size * 0.1,
          shape.size * 0.2,
          shape.size * 0.5
        );
        
        // Abstract foliage (cubist style)
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.size * 0.4, shape.y);
        ctx.lineTo(shape.x - shape.size * 0.2, shape.y - shape.size * 0.4 - animFactor);
        ctx.lineTo(shape.x, shape.y - shape.size * 0.7 - animFactor);
        ctx.lineTo(shape.x + shape.size * 0.2, shape.y - shape.size * 0.4 - animFactor);
        ctx.lineTo(shape.x + shape.size * 0.4, shape.y);
        ctx.closePath();
        ctx.fill();
      }

      function drawPath(shape, animFactor) {
        ctx.fillStyle = shape.fillColor;
        
        // Path segment (trapezoid)
        ctx.beginPath();
        ctx.moveTo(shape.x - shape.width/2, shape.y);
        ctx.lineTo(shape.x + shape.width/2, shape.y);
        ctx.lineTo(shape.x + shape.width/2 + animFactor, shape.y + shape.height);
        ctx.lineTo(shape.x - shape.width/2 + animFactor, shape.y + shape.height);
        ctx.closePath();
        ctx.fill();
      }

      function drawThought(shape, animFactor, time) {
        ctx.fillStyle = shape.fillColor;
        
        // Abstract thought shape
        ctx.translate(shape.x, shape.y);
        ctx.rotate(shape.angle + time * 0.0005 * shape.speedFactor);
        
        ctx.beginPath();
        ctx.moveTo(0, -shape.size);
        ctx.lineTo(shape.size, 0);
        ctx.lineTo(0, shape.size);
        ctx.lineTo(-shape.size, 0);
        ctx.closePath();
        ctx.fill();
        
        // Inner detail
        ctx.globalAlpha = shape.opacity * 0.7;
        ctx.beginPath();
        ctx.arc(0, 0, shape.size * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawVoid(shape, animFactor) {
        // Dark void shape
        ctx.fillStyle = shape.fillColor;
        
        ctx.beginPath();
        ctx.moveTo(shape.x, shape.y - shape.size);
        ctx.lineTo(shape.x + shape.size, shape.y);
        ctx.lineTo(shape.x, shape.y + shape.size);
        ctx.lineTo(shape.x - shape.size, shape.y);
        ctx.closePath();
        ctx.fill();
      }

      function drawBentFigure(shape, animFactor) {
  ctx.fillStyle = shape.fillColor;
  
  // Head (tilted down)
  ctx.beginPath();
  ctx.arc(shape.x, shape.y - shape.size * 0.3, shape.size * 0.15, 0, Math.PI * 2);
  ctx.fill();
  
  // Bent body
  ctx.beginPath();
  ctx.moveTo(shape.x, shape.y - shape.size * 0.15);
  ctx.quadraticCurveTo(
    shape.x, shape.y,
    shape.x - shape.size * 0.2, shape.y + shape.size * 0.2
  );
  ctx.lineTo(shape.x + shape.size * 0.2, shape.y + shape.size * 0.3);
  ctx.quadraticCurveTo(
    shape.x, shape.y,
    shape.x, shape.y - shape.size * 0.15
  );
  ctx.closePath();
  ctx.fill();
  
  // Arms crossed
  ctx.lineWidth = shape.size * 0.06;
  ctx.strokeStyle = shape.fillColor;
  
  // Left arm
  ctx.beginPath();
  ctx.moveTo(shape.x - shape.size * 0.1, shape.y);
  ctx.quadraticCurveTo(
    shape.x - shape.size * 0.2, shape.y + shape.size * 0.1,
    shape.x + shape.size * 0.1, shape.y + shape.size * 0.15 + animFactor * 0.5
  );
  ctx.stroke();
  
  // Right arm
  ctx.beginPath();
  ctx.moveTo(shape.x + shape.size * 0.1, shape.y);
  ctx.quadraticCurveTo(
    shape.x, shape.y + shape.size * 0.1,
    shape.x - shape.size * 0.15, shape.y + shape.size * 0.12 + animFactor * 0.5
  );
  ctx.stroke();
  
  // Legs
  ctx.beginPath();
  ctx.moveTo(shape.x - shape.size * 0.1, shape.y + shape.size * 0.25);
  ctx.lineTo(shape.x - shape.size * 0.2, shape.y + shape.size * 0.6);
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(shape.x + shape.size * 0.1, shape.y + shape.size * 0.25);
  ctx.lineTo(shape.x + shape.size * 0.15, shape.y + shape.size * 0.6);
  ctx.stroke();
  
  // Add subtle shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
  ctx.beginPath();
  ctx.ellipse(shape.x, shape.y + shape.size * 0.65, shape.size * 0.3, shape.size * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawShadow(shape, animFactor) {
  // Abstract darkness shape
  const gradient = ctx.createRadialGradient(
    shape.x, shape.y, 0,
    shape.x, shape.y, shape.size
  );
  gradient.addColorStop(0, shape.fillColor);
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
  
  ctx.fillStyle = gradient;
  ctx.fillRect(
    shape.x - shape.size,
    shape.y - shape.size,
    shape.size * 2,
    shape.size * 2
  );
}

function drawSunset(shape, animFactor, time) {
  // Similar to sun but with more complex gradient
  const gradient = ctx.createRadialGradient(
    shape.x, shape.y, 0,
    shape.x, shape.y, shape.size
  );
  gradient.addColorStop(0, shape.fillColor);
  gradient.addColorStop(0.7, shape.fillColor + '80');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
  
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(shape.x, shape.y, shape.size, 0, Math.PI);
  ctx.fill();
  
  // Sun rays (dimmed)
  ctx.strokeStyle = shape.fillColor;
  ctx.lineWidth = shape.size * 0.03;
  
  for (let i = 0; i < 7; i++) {
    const angle = (i * Math.PI) / 8 + Math.PI / 2;
    const innerRadius = shape.size * 0.8;
    const outerRadius = shape.size * 1.2 + Math.sin(time * 0.001 + i) * shape.size * 0.05;
    
    ctx.globalAlpha = shape.opacity * 0.5;
    ctx.beginPath();
    ctx.moveTo(
      shape.x + Math.cos(angle) * innerRadius,
      shape.y + Math.sin(angle) * innerRadius
    );
    ctx.lineTo(
      shape.x + Math.cos(angle) * outerRadius,
      shape.y + Math.sin(angle) * outerRadius
    );
    ctx.stroke();
  }
}

function drawShip(shape, animFactor, time) {
  ctx.fillStyle = shape.fillColor;
  
  // Abstract ship (from distance)
  ctx.beginPath();
  ctx.moveTo(shape.x - shape.size, shape.y + animFactor);
  ctx.lineTo(shape.x + shape.size, shape.y + animFactor);
  ctx.lineTo(shape.x + shape.size * 0.6, shape.y - shape.size * 0.5 + animFactor);
  ctx.lineTo(shape.x - shape.size * 0.6, shape.y - shape.size * 0.5 + animFactor);
  ctx.closePath();
  ctx.fill();
  
  // Sail
  ctx.beginPath();
  ctx.moveTo(shape.x, shape.y - shape.size * 0.5 + animFactor);
  ctx.lineTo(shape.x, shape.y - shape.size * 2 + animFactor);
  ctx.lineTo(shape.x + shape.size * 0.8, shape.y - shape.size * 0.8 + animFactor);
  ctx.closePath();
  ctx.fill();
  
  // Subtle wave reflection
  ctx.globalAlpha = shape.opacity * 0.5;
  ctx.beginPath();
  ctx.moveTo(shape.x - shape.size * 1.2, shape.y + shape.size * 0.4);
  ctx.quadraticCurveTo(
    shape.x, shape.y + shape.size * 0.2 + Math.sin(time * 0.002) * shape.size * 0.1,
    shape.x + shape.size * 1.2, shape.y + shape.size * 0.4
  );
  ctx.stroke();
}

function drawBarrier(shape, animFactor) {
  ctx.fillStyle = shape.fillColor;
  
  // Abstract barrier shape
  ctx.fillRect(
    shape.x - shape.width/2,
    shape.y - shape.height/2 + animFactor,
    shape.width,
    shape.height
  );
  
  // Details
  const stripeCount = 3;
  const stripeHeight = shape.height / (stripeCount * 2 - 1);
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
  for (let i = 0; i < stripeCount; i++) {
    ctx.fillRect(
      shape.x - shape.width/2,
      shape.y - shape.height/2 + animFactor + i * stripeHeight * 2,
      shape.width,
      stripeHeight
    );
  }
}

function drawTomb(shape, animFactor) {
  ctx.fillStyle = shape.fillColor;
  
  // Tomb base
  ctx.beginPath();
  ctx.moveTo(shape.x - shape.width/2, shape.y - shape.height * 0.1);
  ctx.lineTo(shape.x + shape.width/2, shape.y - shape.height * 0.1);
  ctx.lineTo(shape.x + shape.width/2, shape.y + shape.height * 0.25);
  ctx.lineTo(shape.x - shape.width/2, shape.y + shape.height * 0.25);
  ctx.closePath();
  ctx.fill();
  
  // Tomb stone (cubist style)
  ctx.beginPath();
  ctx.moveTo(shape.x - shape.width * 0.4, shape.y - shape.height * 0.1);
  ctx.lineTo(shape.x + shape.width * 0.4, shape.y - shape.height * 0.1);
  ctx.lineTo(shape.x + shape.width * 0.3, shape.y - shape.height * 0.8 + animFactor);
  ctx.lineTo(shape.x - shape.width * 0.3, shape.y - shape.height * 0.8 + animFactor);
  ctx.closePath();
  ctx.fill();
  
  // Shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
  ctx.beginPath();
  ctx.moveTo(shape.x - shape.width/2, shape.y + shape.height * 0.25);
  ctx.lineTo(shape.x + shape.width/2, shape.y + shape.height * 0.25);
  ctx.lineTo(shape.x + shape.width * 0.7, shape.y + shape.height * 0.4);
  ctx.lineTo(shape.x - shape.width * 0.7, shape.y + shape.height * 0.4);
  ctx.closePath();
  ctx.fill();
}

function drawMourningFigure(shape, animFactor, time) {
  ctx.fillStyle = shape.fillColor;
  
  // Kneeling figure
  // Head
  ctx.beginPath();
  ctx.arc(shape.x, shape.y - shape.size * 0.6, shape.size * 0.15, 0, Math.PI * 2);
  ctx.fill();
  
  // Body (kneeling)
  ctx.beginPath();
  ctx.moveTo(shape.x, shape.y - shape.size * 0.45);
  ctx.lineTo(shape.x - shape.size * 0.25, shape.y - shape.size * 0.1);
  ctx.lineTo(shape.x - shape.size * 0.35, shape.y + shape.size * 0.2);
  ctx.lineTo(shape.x + shape.size * 0.35, shape.y + shape.size * 0.2);
  ctx.lineTo(shape.x + shape.size * 0.25, shape.y - shape.size * 0.1);
  ctx.closePath();
  ctx.fill();
  
  // Arms (offering flowers)
  ctx.strokeStyle = shape.fillColor;
  ctx.lineWidth = shape.size * 0.08;
  
  // Animate slight movement
  const armOffset = Math.sin(time * 0.001) * shape.size * 0.02;
  
  // Left arm
  ctx.beginPath();
  ctx.moveTo(shape.x - shape.size * 0.1, shape.y - shape.size * 0.3);
  ctx.quadraticCurveTo(
    shape.x - shape.size * 0.3, shape.y - shape.size * 0.1,
    shape.x - shape.size * 0.1, shape.y + armOffset
  );
  ctx.stroke();
  
  // Right arm
  ctx.beginPath();
  ctx.moveTo(shape.x + shape.size * 0.1, shape.y - shape.size * 0.3);
  ctx.quadraticCurveTo(
    shape.x + shape.size * 0.3, shape.y - shape.size * 0.1,
    shape.x + shape.size * 0.1, shape.y + armOffset
  );
  ctx.stroke();
  
  // Subtle shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
  ctx.beginPath();
  ctx.ellipse(shape.x, shape.y + shape.size * 0.25, shape.size * 0.4, shape.size * 0.1, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawHolly(shape, animFactor, time) {
  ctx.fillStyle = shape.fillColor;
  
  // Holly leaves (pointed)
  const angle = time * 0.001 * shape.speedFactor + shape.animOffset;
  
  // Stem
  ctx.strokeStyle = '#5d4037';
  ctx.lineWidth = shape.size * 0.1;
  ctx.beginPath();
  ctx.moveTo(shape.x, shape.y);
  ctx.lineTo(shape.x, shape.y + shape.size * 0.8);
  ctx.stroke();
  
  // First leaf
  ctx.translate(shape.x, shape.y);
  ctx.rotate(angle * 0.1);
  
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(shape.size, -shape.size * 0.5);
  ctx.lineTo(shape.size * 1.5, 0);
  ctx.lineTo(shape.size, shape.size * 0.5);
  ctx.closePath();
  ctx.fill();
  
  // Second leaf
  ctx.rotate(Math.PI * 0.6);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(shape.size, -shape.size * 0.5);
  ctx.lineTo(shape.size * 1.5, 0);
  ctx.lineTo(shape.size, shape.size * 0.5);
  ctx.closePath();
  ctx.fill();
  
  // Red berries
  ctx.rotate(-Math.PI * 0.6);
  ctx.fillStyle = '#d32f2f';
  ctx.beginPath();
  ctx.arc(shape.size * 0.4, 0, shape.size * 0.25, 0, Math.PI * 2);
  ctx.fill();
}

function drawHeather(shape, animFactor, time) {
  // Heather flower cluster
  const stemColor = '#5d4037';
  const flowerCount = 5;
  
  // Stem
  ctx.strokeStyle = stemColor;
  ctx.lineWidth = shape.size * 0.1;
  ctx.beginPath();
  ctx.moveTo(shape.x, shape.y);
  ctx.lineTo(shape.x, shape.y + shape.size);
  ctx.stroke();
  
  // Flowers
  ctx.fillStyle = shape.fillColor;
  
  for (let i = 0; i < flowerCount; i++) {
    const angle = (i / flowerCount) * Math.PI + 
                  Math.sin(time * 0.001 * shape.speedFactor + i) * 0.2;
    const distance = shape.size * 0.5;
    
    const fx = shape.x + Math.cos(angle) * distance;
    const fy = shape.y - shape.size * 0.3 + Math.sin(angle) * distance;
    
    // Small flower bell shape
    ctx.beginPath();
    ctx.arc(fx, fy, shape.size * 0.2, 0, Math.PI * 2);
    ctx.fill();
    
    // Connect to stem
    ctx.strokeStyle = stemColor;
    ctx.lineWidth = shape.size * 0.05;
    ctx.beginPath();
    ctx.moveTo(shape.x, shape.y);
    ctx.lineTo(fx, fy);
    ctx.stroke();
  }
}

function drawEmotion(shape, animFactor, time) {
  // Abstract emotion particle
  ctx.fillStyle = shape.fillColor;
  
  // Pulsing effect
  const pulseSize = shape.size * (1 + Math.sin(time * 0.002 * shape.speedFactor) * 0.2);
  
  ctx.beginPath();
  ctx.arc(shape.x, shape.y, pulseSize, 0, Math.PI * 2);
  ctx.fill();
}

function drawLight(shape, animFactor, time) {
  // Light flare representing the whitening of dawn
  const gradient = ctx.createRadialGradient(
    shape.x, shape.y, 0,
    shape.x, shape.y, shape.size
  );
  gradient.addColorStop(0, `rgba(255, 255, 255, ${shape.opacity + Math.sin(time * 0.001) * 0.05})`);
  gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
  
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(shape.x, shape.y, shape.size + animFactor, 0, Math.PI * 2);
  ctx.fill();
}

function drawFocusedEyes(shape, animFactor, time) {
  ctx.fillStyle = shape.fillColor;
  
  // Eyes
  const eyeSpacing = shape.size * 0.3;
  
  // Left eye
  ctx.beginPath();
  ctx.ellipse(
    shape.x - eyeSpacing, 
    shape.y, 
    shape.size * 0.2, 
    shape.size * 0.3, 
    Math.PI * 0.1, 
    0, 
    Math.PI * 2
  );
  ctx.fill();
  
  // Right eye
  ctx.beginPath();
  ctx.ellipse(
    shape.x + eyeSpacing, 
    shape.y, 
    shape.size * 0.2, 
    shape.size * 0.3, 
    -Math.PI * 0.1, 
    0, 
    Math.PI * 2
  );
  ctx.fill();
  
  // Focus direction
  ctx.fillStyle = '#ffffff';
  
  // Focus points
  const focusAngle = time * 0.0005;
  const focusDistance = shape.size * 0.1;
  
  // Left eye focus
  ctx.beginPath();
  ctx.arc(
    shape.x - eyeSpacing, 
    shape.y - focusDistance,
    shape.size * 0.08, 
    0, 
    Math.PI * 2
  );
  ctx.fill();
  
  // Right eye focus
  ctx.beginPath();
  ctx.arc(
    shape.x + eyeSpacing, 
    shape.y - focusDistance,
    shape.size * 0.08, 
    0, 
    Math.PI * 2
  );
  ctx.fill();
  
  // Eyebrows focused inward
  ctx.strokeStyle = shape.fillColor;
  ctx.lineWidth = shape.size * 0.05;
  
  // Left eyebrow
  ctx.beginPath();
  ctx.moveTo(shape.x - eyeSpacing - shape.size * 0.25, shape.y - shape.size * 0.3);
  ctx.lineTo(shape.x - eyeSpacing + shape.size * 0.15, shape.y - shape.size * 0.4);
  ctx.stroke();
  
  // Right eyebrow
  ctx.beginPath();
  ctx.moveTo(shape.x + eyeSpacing + shape.size * 0.25, shape.y - shape.size * 0.3);
  ctx.lineTo(shape.x + eyeSpacing - shape.size * 0.15, shape.y - shape.size * 0.4);
  ctx.stroke();
}

function drawCrossedHands(shape, animFactor, time) {
  ctx.fillStyle = shape.fillColor;
  
  // Arms
  ctx.lineWidth = shape.size * 0.2;
  ctx.strokeStyle = shape.fillColor;
  
  // Subtle animation
  const armOffset = Math.sin(time * 0.001) * shape.size * 0.02;
  
  // Left arm crossing over right
  ctx.beginPath();
  ctx.moveTo(shape.x - shape.size, shape.y - shape.size * 0.3);
  ctx.quadraticCurveTo(
    shape.x - shape.size * 0.5, 
    shape.y, 
    shape.x + shape.size * 0.5 + armOffset, 
    shape.y
  );
  ctx.stroke();
  
  // Right arm crossing under left
  ctx.beginPath();
  ctx.moveTo(shape.x + shape.size, shape.y - shape.size * 0.3);
  ctx.quadraticCurveTo(
    shape.x, 
    shape.y - shape.size * 0.1, 
    shape.x - shape.size * 0.3 + armOffset, 
    shape.y + shape.size * 0.1
  );
  ctx.stroke();
  
  // Hands
  ctx.beginPath();
  ctx.arc(
    shape.x + shape.size * 0.5 + armOffset, 
    shape.y, 
    shape.size * 0.15, 
    0, 
    Math.PI * 2
  );
  ctx.fill();
  
  ctx.beginPath();
  ctx.arc(
    shape.x - shape.size * 0.3 + armOffset, 
    shape.y + shape.size * 0.1, 
    shape.size * 0.15, 
    0, 
    Math.PI * 2
  );
  ctx.fill();
}

function drawEveningGold(shape, animFactor, time) {
  // Evening gold representing "l'or du soir"
  const gradient = ctx.createRadialGradient(
    shape.x, shape.y, 0,
    shape.x, shape.y, shape.size
  );
  gradient.addColorStop(0, 'rgba(255, 215, 0, 0.6)');
  gradient.addColorStop(0.6, 'rgba(218, 165, 32, 0.3)');
  gradient.addColorStop(1, 'rgba(205, 133, 63, 0)');
  
  ctx.fillStyle = gradient;
  ctx.beginPath();
  ctx.arc(shape.x, shape.y, shape.size + animFactor, 0, Math.PI * 2);
  ctx.fill();
  
  // Light rays
  ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
  ctx.lineWidth = shape.size * 0.02;
  
  for (let i = 0; i < 8; i++) {
    const angle = i * Math.PI / 4 + time * 0.0002;
    const innerRadius = shape.size * 0.8;
    const outerRadius = shape.size * 1.5 + Math.sin(time * 0.001 + i) * shape.size * 0.1;
    
    ctx.beginPath();
    ctx.moveTo(
      shape.x + Math.cos(angle) * innerRadius,
      shape.y + Math.sin(angle) * innerRadius
    );
    ctx.lineTo(
      shape.x + Math.cos(angle) * outerRadius,
      shape.y + Math.sin(angle) * outerRadius
    );
    ctx.stroke();
  }
}

function drawBouquet(shape, animFactor, time) {
  // Bouquet base
  ctx.fillStyle = '#5d4037';
  ctx.beginPath();
  ctx.moveTo(shape.x, shape.y);
  ctx.lineTo(shape.x - shape.size * 0.3, shape.y - shape.size * 0.8);
  ctx.lineTo(shape.x + shape.size * 0.3, shape.y - shape.size * 0.8);
  ctx.closePath();
  ctx.fill();
  
  // Holly leaves
  ctx.fillStyle = '#30634a';
  
  for (let i = 0; i < 5; i++) {
    const angle = i * Math.PI * 0.4 - Math.PI * 0.8 + Math.sin(time * 0.001) * 0.1;
    const x = shape.x + Math.cos(angle) * shape.size * 0.3;
    const y = shape.y - shape.size * 0.6 + Math.sin(angle) * shape.size * 0.2;
    
    // Draw pointed leaf
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle + Math.PI * 0.5);
    
    ctx.beginPath();
    ctx.moveTo(0, -shape.size * 0.2);
    ctx.lineTo(shape.size * 0.1, -shape.size * 0.05);
    ctx.lineTo(shape.size * 0.2, -shape.size * 0.2);
    ctx.lineTo(shape.size * 0.1, 0);
    ctx.lineTo(shape.size * 0.2, shape.size * 0.2);
    ctx.lineTo(0, shape.size * 0.05);
    ctx.lineTo(-shape.size * 0.2, shape.size * 0.2);
    ctx.lineTo(-shape.size * 0.1, 0);
    ctx.lineTo(-shape.size * 0.2, -shape.size * 0.2);
    ctx.lineTo(-shape.size * 0.1, -shape.size * 0.05);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  }
  
  // Heather flowers
  ctx.fillStyle = shape.fillColor;
  
  for (let i = 0; i < 8; i++) {
    const angle = i * Math.PI * 0.25 + Math.sin(time * 0.001 + i) * 0.1;
    const distance = shape.size * 0.3;
    const x = shape.x + Math.cos(angle) * distance;
    const y = shape.y - shape.size * 0.5 + Math.sin(angle) * distance * 0.5;
    
    ctx.beginPath();
    ctx.arc(x, y, shape.size * 0.1, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Red holly berries
  ctx.fillStyle = '#d32f2f';
  
  for (let i = 0; i < 3; i++) {
    const angle = i * Math.PI * 0.5 - Math.PI * 0.5;
    const x = shape.x + Math.cos(angle) * shape.size * 0.15;
    const y = shape.y - shape.size * 0.4 + Math.sin(angle) * shape.size * 0.15;
    
    ctx.beginPath();
    ctx.arc(x, y, shape.size * 0.08, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Generate particles
function generateParticles() {
  config.particles = [];
  const colors = config.scenes[config.currentScene].colors;
  const numParticles = 50;
  
  for (let i = 0; i < numParticles; i++) {
    const x = Math.random() * particleCanvas.width;
    const y = Math.random() * particleCanvas.height;
    const size = Math.random() * 3 + 1;
    const speedX = (Math.random() - 0.5) * 0.5;
    const speedY = (Math.random() - 0.5) * 0.5;
    
    // Choose color
    let color;
    const colorChoice = Math.random();
    if (colorChoice < 0.4) {
      color = colors.primary;
    } else if (colorChoice < 0.8) {
      color = colors.secondary;
    } else {
      color = colors.accent;
    }
    
    config.particles.push({
      x, y, size, speedX, speedY, color,
      opacity: Math.random() * 0.5 + 0.2
    });
  }
}

// Initialize interactive particles
function generateInteractiveParticles() {
  config.interactiveParticles = [];
}

// Update and draw particles
function updateAndDrawParticles(time) {
  particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
  
  config.particles.forEach(p => {
    // Update position
    p.x += p.speedX;
    p.y += p.speedY;
    
    // Wrap around edges
    if (p.x < 0) p.x = particleCanvas.width;
    if (p.x > particleCanvas.width) p.x = 0;
    if (p.y < 0) p.y = particleCanvas.height;
    if (p.y > particleCanvas.height) p.y = 0;
    
    // Influence by mouse position
    const dx = config.mouseX - p.x;
    const dy = config.mouseY - p.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance < 100) {
      p.x -= dx * 0.01;
      p.y -= dy * 0.01;
    }
    
    // Subtle pulsing
    const pulseSize = p.size * (1 + Math.sin(time * 0.001) * 0.2);
    
    // Draw particle
    particleCtx.globalAlpha = p.opacity;
    particleCtx.fillStyle = p.color;
    particleCtx.beginPath();
    particleCtx.arc(p.x, p.y, pulseSize, 0, Math.PI * 2);
    particleCtx.fill();
  });
}

// Update and draw interactive particles
function updateAndDrawInteractiveParticles(time) {
  interactiveCtx.clearRect(0, 0, interactiveCanvas.width, interactiveCanvas.height);
  
  // Remove old particles
  config.interactiveParticles = config.interactiveParticles.filter(p => {
    return p.life > 0;
  });
  
  // Draw and update remaining particles
  config.interactiveParticles.forEach(p => {
    p.x += p.speedX;
    p.y += p.speedY;
    p.size *= 0.98;
    p.life -= 1;
    
    const colors = config.scenes[config.currentScene].colors;
    const gradient = interactiveCtx.createRadialGradient(
      p.x, p.y, 0,
      p.x, p.y, p.size
    );
    gradient.addColorStop(0, `rgba(${hexToRgb(colors.accent)}, ${p.opacity * (p.life / p.maxLife)})`);
    gradient.addColorStop(1, `rgba(${hexToRgb(colors.accent)}, 0)`);
    
    interactiveCtx.fillStyle = gradient;
    interactiveCtx.beginPath();
    interactiveCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    interactiveCtx.fill();
  });
}

// Create interactive particles on click
function createInteractiveParticlesOnClick(x, y) {
  const colors = config.scenes[config.currentScene].colors;
  const particleCount = 15;
  
  for (let i = 0; i < particleCount; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 2 + 1;
    const size = Math.random() * 20 + 10;
    
    config.interactiveParticles.push({
      x: x,
      y: y,
      size: size,
      speedX: Math.cos(angle) * speed,
      speedY: Math.sin(angle) * speed,
      opacity: Math.random() * 0.5 + 0.5,
      life: Math.random() * 40 + 30,
      maxLife: 70
    });
  }
}

// Create ripple effect
function createRipple(x, y) {
  const ripple = document.createElement('div');
  ripple.className = 'ripple';
  ripple.style.left = `${x}px`;
  ripple.style.top = `${y}px`;
  ripple.style.width = '100px';
  ripple.style.height = '100px';
  
  document.body.appendChild(ripple);
  
  setTimeout(() => {
    ripple.remove();
  }, 1000);
}

// Create the poem text elements
function createPoemLines() {
  poemContainer.innerHTML = '';
  
  config.scenes.forEach(scene => {
    scene.lines.forEach(line => {
      const lineElement = document.createElement('div');
      lineElement.className = 'poem-line';
      lineElement.textContent = line;
      poemContainer.appendChild(lineElement);
    });
  });
}

// Create navigation dots
function createNavigationDots() {
  controls.innerHTML = '';
  
  config.scenes.forEach((scene, index) => {
    const dot = document.createElement('div');
    dot.className = 'control-dot';
    if (index === config.currentScene) {
      dot.classList.add('active');
    }
    
    dot.addEventListener('click', () => {
      goToScene(index);
    });
    
    // Hover effect
    dot.addEventListener('mouseenter', () => {
      if (config.audioLoaded && !config.muted) {
        generateHoverSound();
      }
    });
    
    controls.appendChild(dot);
  });
}

// Go to specific scene
function goToScene(index) {
  if (config.transition || index === config.currentScene) return;
  
  config.transition = true;
  fadeOutCurrentScene(() => {
    config.currentScene = index;
    updateScene();
    fadeInCurrentScene();
    config.transition = false;
    
    // Play transition sound
    if (config.audioLoaded && !config.muted) {
      generateTransitionSound();
    }
    
    // Start ambient sound
    playAmbientSound();
    
    // Play effect sounds
    playEffectSounds();
  });
}

// Update scene content
function updateScene() {
  // Update controls
  document.querySelectorAll('.control-dot').forEach((dot, i) => {
    dot.classList.toggle('active', i === config.currentScene);
  });
  
  // Update title
  sceneTitle.textContent = config.scenes[config.currentScene].title;
  
  // Update background
  drawBackground();
  
  // Update shapes
  generateShapes();
  
  // Update particles
  generateParticles();
}

// Fade out current scene
function fadeOutCurrentScene(callback) {
  // Hide poem lines
  document.querySelectorAll('.poem-line').forEach(line => {
    line.classList.remove('visible');
  });
  
  // Hide scene title
  sceneTitle.classList.remove('visible');
  
  // Transition delay before callback
  setTimeout(callback, 1000);
}

// Fade in current scene
function fadeInCurrentScene() {
  // Get current scene's poem lines
  const startIndex = config.currentScene * 2;
  const poemLines = document.querySelectorAll('.poem-line');
  
  // Show scene title
  sceneTitle.classList.add('visible');
  
  // Show lines with staggered timing
  setTimeout(() => {
    poemLines[startIndex].classList.add('visible');
    
    setTimeout(() => {
      poemLines[startIndex + 1].classList.add('visible');
    }, 1000);
  }, 500);
}

// Animation function
function animate(time) {
  if (!config.animationStarted) return;
  
  // Draw shapes
  drawShapes(time);
  
  // Update and draw particles
  updateAndDrawParticles(time);
  
  // Update and draw interactive particles
  updateAndDrawInteractiveParticles(time);
  
  // Update progress bar
  if (!config.transition) {
    const progress = (time % 20000) / 20000 * 100;
    progressBar.style.width = `${progress}%`;
    
    // Auto-advance scenes
    if (progress > 99 && !config.transition) {
      const nextScene = (config.currentScene + 1) % config.scenes.length;
      goToScene(nextScene);
    }
  }
  
  // Move magic circle if mouse has moved recently
  if (time - config.lastInteraction < 2000) {
    magicCircle.style.left = `${config.mouseX}px`;
    magicCircle.style.top = `${config.mouseY}px`;
    magicCircle.style.opacity = '1';
  } else {
    magicCircle.style.opacity = '0';
  }
  
  requestAnimationFrame(animate);
}

// Start animation
function startAnimation() {
  // Hide the intro overlay
  gsap.to(intro, {
    opacity: 0,
    duration: 2,
    onComplete: () => {
      intro.style.display = 'none';
    }
  });
  
  // Initialize audio (needs user interaction)
  initAudio();
  
  // Show controls and progress
  setTimeout(() => {
    controls.style.opacity = '1';
    progressContainer.style.opacity = '1';
    clickHint.style.opacity = '1';
    
    // Play welcome tones
    if (audioContext) {
      playTone(220, 1, 'sine', 0);
      playTone(330, 1, 'sine', 0.5);
      playTone(440, 1.5, 'sine', 1);
    }
  }, 1000);
  
  // Initial scene setup
  drawBackground();
  generateShapes();
  generateParticles();
  generateInteractiveParticles();
  createPoemLines();
  createNavigationDots();
  
  // Show the first scene content
  setTimeout(() => {
    fadeInCurrentScene();
    
    // Start ambient sound
    playAmbientSound();
    
    // Play effect sounds
    playEffectSounds();
  }, 1500);
  
  // Start the animation loop
  config.animationStarted = true;
  animate(0);
}

// Mouse move event for interactive effects
function handleMouseMove(e) {
  config.mouseX = e.clientX;
  config.mouseY = e.clientY;
  config.lastInteraction = performance.now();
}

// Touch move event (mobile)
function handleTouchMove(e) {
  if (e.touches.length > 0) {
    config.mouseX = e.touches[0].clientX;
    config.mouseY = e.touches[0].clientY;
    config.lastInteraction = performance.now();
  }
}

// Click event
function handleClick(e) {
  if (!config.animationStarted || config.transition) return;
  
  // Create interactive particles
  createInteractiveParticlesOnClick(e.clientX, e.clientY);
  
  // Create ripple
  createRipple(e.clientX, e.clientY);
  
  // Play click sound
  if (config.audioLoaded && !config.muted) {
    generateClickSound();
  }
  
  // Hide the hint after first interaction
  if (clickHint.style.opacity !== '0') {
    clickHint.style.opacity = '0';
  }
}

// Play tone function
function playTone(freq, duration, type = 'sine', delay = 0) {
  if (!audioContext || config.muted) return;
  
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  
  oscillator.type = type;
  oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
  
  gainNode.gain.setValueAtTime(0, audioContext.currentTime);
  gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05 + delay);
  gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration + delay);
  
  oscillator.connect(gainNode);
  gainNode.connect(interactionGainNode);
  
  oscillator.start(audioContext.currentTime + delay);
  oscillator.stop(audioContext.currentTime + duration + delay + 0.1);
}

// Toggle mute
function toggleMute() {
  config.muted = !config.muted;
  updateVolume();
}

// Helper function: Convert hex to RGB
function hexToRgb(hex) {
  // Remove # if present
  hex = hex.replace('#', '');
  
  // Convert 3-digit hex to 6-digits
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  
  // Parse
  const r = parseInt(hex.substring(0, 2), 16);
  const g = parseInt(hex.substring(2, 4), 16);
  const b = parseInt(hex.substring(4, 6), 16);
  
  return `${r}, ${g}, ${b}`;
}

// Set up event listeners
window.addEventListener('mousemove', handleMouseMove);
window.addEventListener('touchmove', handleTouchMove, { passive: true });
window.addEventListener('resize', resizeCanvases);
window.addEventListener('click', handleClick);

startButton.addEventListener('click', startAnimation);

// Volume control
volumeSlider.addEventListener('input', function() {
  config.volume = this.value / 100;
  updateVolume();
});

// Mute button
muteButton.addEventListener('click', toggleMute);

// Initialize
resizeCanvases();

// Hide loading screen
setTimeout(() => {
  loading.style.opacity = '0';
  setTimeout(() => {
    loading.style.display = 'none';
  }, 1000);
}, 1500);
});