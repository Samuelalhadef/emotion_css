<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Histoires Émotionnelles Animées</title>
    <style>
        /* ---------- STYLES DE BASE ---------- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow-x: hidden;
            background-color: #000;
            color: #fff;
        }

        main {
            scroll-snap-type: y mandatory;
            overflow-y: scroll;
            height: 100vh;
        }

        /* ---------- CONTENEURS D'ÉMOTIONS ---------- */
        .emotion-container {
            width: 100%;
            height: 100vh;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            scroll-snap-align: start;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* ---------- TEXTES ET NARRATION ---------- */
        .emotion-text {
            position: absolute;
            bottom: 5%;
            left: 0;
            width: 100%;
            text-align: center;
            padding: 20px;
            z-index: 10;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s, transform 0.8s;
        }

        .emotion-text.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .emotion-title {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .emotion-title.visible {
            opacity: 1;
        }

        .emotion-narration {
            font-size: 1.5rem;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        .emotion-narration.visible {
            opacity: 1;
        }

        /* Couleurs spécifiques pour chaque émotion */
        #tristesse .emotion-title {
            color: #6495ED;
            text-shadow: 0 0 10px rgba(100, 149, 237, 0.7);
        }

        #colere .emotion-title {
            color: #FF4500;
            text-shadow: 0 0 10px rgba(255, 69, 0, 0.7);
        }

        #degout .emotion-title {
            color: #9ACD32;
            text-shadow: 0 0 10px rgba(154, 205, 50, 0.7);
        }

        /* ---------- NAVIGATION ---------- */
        .nav {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
        }

        .nav-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .nav-dot.active {
            background-color: white;
            transform: scale(1.3);
        }

        /* ---------- ÉCRAN DE CHARGEMENT ---------- */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            font-size: 24px;
            flex-direction: column;
        }
        
        #loading-progress {
            width: 300px;
            height: 10px;
            background-color: #333;
            margin-top: 20px;
            border-radius: 5px;
            overflow: hidden;
        }
        
        #loading-bar {
            height: 100%;
            width: 0%;
            background-color: #6495ED;
            transition: width 0.3s;
        }

        .progress-text {
            margin-top: 10px;
            font-size: 14px;
        }

        .loading-title {
            font-size: 28px;
            margin-bottom: 20px;
            color: #6495ED;
            text-shadow: 0 0 10px rgba(100, 149, 237, 0.7);
            animation: colorPulse 3s infinite;
        }
        
        @keyframes colorPulse {
            0%, 100% { color: #6495ED; text-shadow: 0 0 10px rgba(100, 149, 237, 0.7); }
            33% { color: #FF4500; text-shadow: 0 0 10px rgba(255, 69, 0, 0.7); }
            66% { color: #9ACD32; text-shadow: 0 0 10px rgba(154, 205, 50, 0.7); }
        }
        
        .loading-subtitle {
            margin-top: 15px;
            font-style: italic;
            opacity: 0.8;
        }

        /* ---------- CONTRÔLES AUDIO ---------- */
        .audio-toggle {
            position: fixed;
            left: 20px;
            bottom: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            transition: background-color 0.3s;
        }

        .audio-toggle:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .audio-toggle svg {
            width: 24px;
            height: 24px;
            fill: white;
        }

        /* ---------- ÉLÉMENTS NARRATIFS POUR TRISTESSE ---------- */
        .photo-frame {
            position: absolute;
            width: 200px;
            height: 250px;
            border: 10px solid #8a5a2b;
            background: #f0f0f0;
            z-index: 5;
            opacity: 0;
            transition: opacity 1.5s;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .photo {
            position: absolute;
            width: 180px;
            height: 230px;
            left: 0;
            top: 0;
            background: linear-gradient(to bottom right, #7a94c9, #3a5c8c);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .photo-silhouette {
            width: 100px;
            height: 150px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50% 50% 20% 20% / 30% 30% 70% 70%;
        }

        /* ---------- ÉLÉMENTS NARRATIFS POUR COLÈRE ---------- */
        .broken-object {
            position: absolute;
            width: 120px;
            height: 120px;
            background-size: cover;
            opacity: 0;
            transition: all 0.3s;
            z-index: 2;
        }

        /* ---------- ÉLÉMENTS NARRATIFS POUR DÉGOÛT ---------- */
        .food-plate {
            position: absolute;
            width: 200px;
            height: 200px;
            background: #f0f0f0;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5;
            opacity: 0;
            transition: opacity 1s;
        }

        .food {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: linear-gradient(to bottom right, #8a9a5b, #5e6d3e);
            position: relative;
            overflow: hidden;
        }

        .food::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            background: #9aB86b;
            border-radius: 50%;
            top: 30px;
            left: 40px;
        }

        .food::after {
            content: '';
            position: absolute;
            width: 40px;
            height: 20px;
            background: #7a8a4b;
            border-radius: 50%;
            bottom: 30px;
            right: 30px;
        }

        .fly {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #000;
            border-radius: 50%;
            opacity: 0;
        }

        @keyframes flutter {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1, 0.9) rotate(10deg); }
            50% { transform: scale(0.9, 1.1) rotate(-10deg); }
            75% { transform: scale(1.05, 0.95) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        /* ---------- TIMELINE ET PROGRESSION ---------- */
        .timeline {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            height: 3px;
            width: 200px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            z-index: 100;
        }

        .timeline-progress {
            height: 100%;
            width: 0%;
            background: white;
            border-radius: 3px;
            transition: width 0.5s;
        }

        .timeline-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: background 0.3s;
        }

        .timeline-marker.active {
            background: white;
        }

        /* ---------- TOOLTIP DES CONTRÔLES ---------- */
        #controls-tooltip {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #controls-tooltip .tooltip-title {
            margin-bottom: 5px;
            font-weight: bold;
        }

        /* Bouton de démarrage d'urgence */
        #start-button {
            padding: 10px 20px;
            margin-top: 20px;
            font-size: 16px;
            background-color: #6495ED;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #start-button:hover {
            background-color: #4169E1;
        }
    </style>
</head>
<body>
    <!-- Écran de chargement -->
    <div id="loading">
        <div class="loading-title">Émotions en Animation</div>
        <div>Chargement des animations narratives...</div>
        <div id="loading-progress">
            <div id="loading-bar"></div>
        </div>
        <div class="loading-subtitle">Préparation d'une expérience émotionnelle immersive...</div>
        <div class="progress-text">Préparation des histoires émotionnelles...</div>
        <button id="start-button">Démarrer l'expérience</button>
    </div>

    <!-- Contrôles audio -->
    <div class="audio-toggle">
        <svg viewBox="0 0 24 24">
            <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
    </div>

    <!-- Navigation par points -->
    <div class="nav">
        <div class="nav-dot active" data-section="tristesse"></div>
        <div class="nav-dot" data-section="colere"></div>
        <div class="nav-dot" data-section="degout"></div>
    </div>

    <!-- Tooltip des contrôles -->
    <div id="controls-tooltip">
        <div class="tooltip-title">Contrôles:</div>
        <div>↑/↓ : Naviguer entre émotions</div>
        <div>Espace : Avancer dans l'histoire</div>
    </div>

    <!-- Contenu principal -->
    <main>
        <!-- Section Tristesse -->
        <section id="tristesse" class="emotion-container">
            <canvas id="tristesse-canvas"></canvas>
            <div class="timeline">
                <div class="timeline-progress" id="tristesse-progress"></div>
                <div class="timeline-marker" style="left: 0%"></div>
                <div class="timeline-marker" style="left: 33%"></div>
                <div class="timeline-marker" style="left: 66%"></div>
                <div class="timeline-marker" style="left: 100%"></div>
            </div>
            <div class="emotion-text">
                <h2 class="emotion-title">Tristesse</h2>
                <p class="emotion-narration">Le cœur lourd, je contemple nos souvenirs qui s'effacent doucement dans la pluie. Chaque goutte qui tombe emporte avec elle un fragment de notre histoire, comme mes larmes emportent un peu de mon âme.</p>
            </div>
        </section>
        
        <!-- Section Colère -->
        <section id="colere" class="emotion-container">
            <canvas id="colere-canvas"></canvas>
            <div class="timeline">
                <div class="timeline-progress" id="colere-progress"></div>
                <div class="timeline-marker" style="left: 0%"></div>
                <div class="timeline-marker" style="left: 33%"></div>
                <div class="timeline-marker" style="left: 66%"></div>
                <div class="timeline-marker" style="left: 100%"></div>
            </div>
            <div class="emotion-text">
                <h2 class="emotion-title">Colère</h2>
                <p class="emotion-narration">D'abord un murmure d'irritation, puis un grondement sourd, et enfin cette EXPLOSION qui ravage tout sur son passage. Ma rage est un feu qui consume toute raison, laissant derrière elle un champ de ruines.</p>
            </div>
        </section>
        
        <!-- Section Dégoût -->
        <section id="degout" class="emotion-container">
            <canvas id="degout-canvas"></canvas>
            <div class="timeline">
                <div class="timeline-progress" id="degout-progress"></div>
                <div class="timeline-marker" style="left: 0%"></div>
                <div class="timeline-marker" style="left: 33%"></div>
                <div class="timeline-marker" style="left: 66%"></div>
                <div class="timeline-marker" style="left: 100%"></div>
            </div>
            <div class="emotion-text">
                <h2 class="emotion-title">Dégoût</h2>
                <p class="emotion-narration">Ce n'était qu'une simple assiette, jusqu'à ce que je remarque ces mouvements. Chaque seconde révèle de nouveaux détails répugnants qui font frémir mon estomac et plisser mon visage d'horreur.</p>
            </div>
        </section>
    </main>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /**
         * ======================================
         * SYSTÈME DE GESTION DES RESSOURCES
         * ======================================
         */
        let resourcesLoaded = 0;
        const totalResources = 15; // Nombre total de ressources à charger
        let loadingForceComplete = false; // Indicateur pour forcer la fin du chargement
        
        function updateLoadingProgress() {
            resourcesLoaded++;
            const percentage = (resourcesLoaded / totalResources) * 100;
            const loadingBar = document.getElementById('loading-bar');
            
            if (loadingBar) {
                loadingBar.style.width = percentage + '%';
            }
            
            console.log(`Chargement: ${resourcesLoaded}/${totalResources} (${percentage.toFixed(2)}%)`);
            
            if (resourcesLoaded >= totalResources || loadingForceComplete) {
                console.log("Chargement terminé, affichage du contenu...");
                completeLoading();
            }
        }
        
        // Fonction pour terminer le chargement et afficher le contenu
        function completeLoading() {
            const loadingElement = document.getElementById('loading');
            if (loadingElement && loadingElement.style.display !== 'none') {
                setTimeout(() => {
                    loadingElement.style.display = 'none';
                    
                    // Activation manuelle de la première section
                    const tristesse = document.getElementById('tristesse');
                    if (tristesse) {
                        tristesse.classList.add('active');
                        showEmotionTextElements('tristesse');
                        resetStoryProgress('tristesse');
                    }
                }, 500);
            }
        }
        
        // Bouton de démarrage d'urgence
        document.getElementById('start-button').addEventListener('click', function() {
            loadingForceComplete = true;
            completeLoading();
        });

        /**
         * ======================================
         * SYSTÈME AUDIO
         * ======================================
         */
        let audioEnabled = false;
        const audioToggle = document.querySelector('.audio-toggle');
        const audioElements = {
            tristesse: new Audio(),
            colere: new Audio(),
            degout: new Audio()
        };
        
        // Configuration des éléments audio avec des sons factices
        audioElements.tristesse.src = 'data:audio/mp3;base64,SUQzAwAAAAAAIlRJVDIAAAAZAAAASW1hZ2luYXJ5IFJhaW4gQW1iaWVuY2UAAAAAAAAAAAA=';
        audioElements.tristesse.loop = true;
        audioElements.tristesse.volume = 0.4;
        
        audioElements.colere.src = 'data:audio/mp3;base64,SUQzAwAAAAAAIlRJVDIAAAAZAAAASW1hZ2luYXJ5IEZpcmUgQ3JhY2tsaW5nAAAAAAAAAAAAA=';
        audioElements.colere.loop = true;
        audioElements.colere.volume = 0.4;
        
        audioElements.degout.src = 'data:audio/mp3;base64,SUQzAwAAAAAAIlRJVDIAAAAZAAAASW1hZ2luYXJ5IEZsaWVzIEJ1enppbmcAAAAAAAAAAAAA=';
        audioElements.degout.loop = true;
        audioElements.degout.volume = 0.4;
        
        // Gestionnaires d'événements pour l'audio
        audioToggle.addEventListener('click', toggleAudio);
        
        function toggleAudio() {
            audioEnabled = !audioEnabled;
            
            // Mise à jour de l'icône
            audioToggle.innerHTML = audioEnabled ? 
                '<svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>' : 
                '<svg viewBox="0 0 24 24"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z"/></svg>';
            
            // Gestion des éléments audio
            if (audioEnabled) {
                // Détermine quel audio jouer en fonction de la section visible actuelle
                const activeSection = document.querySelector('.emotion-container.active');
                if (activeSection) {
                    const id = activeSection.id;
                    audioElements[id].play().catch(e => console.warn("Erreur lecture audio:", e));
                }
            } else {
                // Pause de tous les audios
                Object.values(audioElements).forEach(audio => {
                    try {
                        audio.pause();
                    } catch(e) {
                        console.warn("Erreur pause audio:", e);
                    }
                });
            }
        }
        
        function switchAudio(sectionId) {
            if (!audioEnabled) return;
            
            // Pause de tous les audios
            Object.values(audioElements).forEach(audio => {
                try {
                    audio.pause();
                } catch(e) {
                    console.warn("Erreur pause audio:", e);
                }
            });
            
            // Lecture de l'audio approprié
            if (audioElements[sectionId]) {
                audioElements[sectionId].play().catch(e => console.warn("Erreur lecture audio:", e));
            }
        }

        /**
         * ======================================
         * SYSTÈME DE GESTION DES SECTIONS ET NAVIGATION
         * ======================================
         */
        const observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.5
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                    showEmotionTextElements(entry.target.id);
                    updateActiveNavDot(entry.target.id);
                    switchAudio(entry.target.id);
                    resetStoryProgress(entry.target.id);
                } else {
                    entry.target.classList.remove('active');
                    hideEmotionTextElements(entry.target.id);
                }
            });
        }, observerOptions);

        // Observez les sections une fois que le document est chargé
        document.querySelectorAll('.emotion-container').forEach(section => {
            observer.observe(section);
        });

        function showEmotionTextElements(id) {
            const container = document.querySelector(`#${id} .emotion-text`);
            if (!container) return;
            
            container.classList.add('visible');
            
            setTimeout(() => {
                const title = container.querySelector('.emotion-title');
                if (title) title.classList.add('visible');
            }, 500);
            
            setTimeout(() => {
                const narration = container.querySelector('.emotion-narration');
                if (narration) narration.classList.add('visible');
            }, 1000);
        }
        
        function hideEmotionTextElements(id) {
            const container = document.querySelector(`#${id} .emotion-text`);
            if (!container) return;
            
            const title = container.querySelector('.emotion-title');
            const narration = container.querySelector('.emotion-narration');
            
            if (title) title.classList.remove('visible');
            if (narration) narration.classList.remove('visible');
            container.classList.remove('visible');
        }

        function updateActiveNavDot(sectionId) {
            document.querySelectorAll('.nav-dot').forEach(dot => {
                dot.classList.remove('active');
                if (dot.dataset.section === sectionId) {
                    dot.classList.add('active');
                }
            });
        }

        document.querySelectorAll('.nav-dot').forEach(dot => {
            dot.addEventListener('click', () => {
                const sectionId = dot.dataset.section;
                const section = document.getElementById(sectionId);
                if (section) {
                    section.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });
        
        function resetStoryProgress(sectionId) {
            try {
                // Réinitialisation de la progression de la timeline
                const progressElement = document.getElementById(`${sectionId}-progress`);
                if (progressElement) {
                    progressElement.style.width = '0%';
                }
                
                // Réinitialisation des marqueurs de timeline
                const markers = document.querySelectorAll(`#${sectionId} .timeline-marker`);
                markers.forEach(marker => marker.classList.remove('active'));
                if (markers.length > 0) {
                    markers[0].classList.add('active');
                }
                
                // Redémarrage de l'histoire
                if (storyStates[sectionId]) {
                    storyStates[sectionId].currentPhase = 0;
                    storyStates[sectionId].phaseTime = 0;
                    storyStates[sectionId].narrationPhase = 0;
                }
                
                // Réinitialisation des éléments spécifiques à l'histoire
                if (sectionId === 'tristesse') {
                    resetTristesseStory();
                } else if (sectionId === 'colere') {
                    resetColereStory();
                } else if (sectionId === 'degout') {
                    resetDegoutStory();
                }
                
                // Mise à jour du texte de narration basé sur la réinitialisation
                updateNarrationText(sectionId, 0);
            } catch (error) {
                console.error("Erreur dans resetStoryProgress:", error);
            }
        }

        /**
         * ======================================
         * SYSTÈME DE NARRATION DES HISTOIRES
         * ======================================
         */
        const narrations = {
            tristesse: [
                "Le cœur lourd, je contemple nos souvenirs qui s'effacent doucement dans la pluie. Chaque goutte qui tombe emporte avec elle un fragment de notre histoire.",
                "Les photos jaunies par le temps reflètent des moments qui ne reviendront jamais. Je sens ma poitrine se serrer tandis que les souvenirs s'estompent lentement.",
                "L'absence creuse un vide que rien ne semble pouvoir combler. Je suis seul face à ce monde devenu gris, où les couleurs se sont évanouies avec toi.",
                "Mes larmes se mêlent à la pluie dans un dernier adieu silencieux. La tristesse n'est plus une émotion, elle est devenue mon univers tout entier."
            ],
            colere: [
                "Une légère contrariété, un simple agacement. Je sens mon rythme cardiaque s'accélérer tandis que mes poings se serrent imperceptiblement.",
                "L'irritation grandit, comme un feu qui trouve son combustible. Ma respiration devient saccadée, mes pensées se brouillent sous l'effet de cette tension croissante.",
                "La colère prend le contrôle. COMMENT ONT-ILS OSÉ?! Je ne vois plus que rouge, mes mains tremblent d'une rage que je peine à contenir!",
                "Les dégâts sont faits. Autour de moi, les débris de ce que j'ai détruit dans ma fureur. La colère se dissipe, laissant place à un vide épuisant."
            ],
            degout: [
                "Au premier regard, rien d'anormal dans cette assiette. Puis, un détail attire mon attention, quelque chose d'inhabituel qui fait plisser mes yeux.",
                "Mon nez détecte une odeur étrange, légèrement âcre. Je remarque alors de minuscules mouvements à la surface. Est-ce mon imagination?",
                "La réalité s'impose avec horreur - l'assiette est infestée! Je sens mon estomac se nouer, ma gorge se contracte, et une vague nauséeuse me submerge.",
                "L'écœurement est total. Je ne peux plus regarder sans ressentir cette répulsion viscérale qui fait frissonner chaque parcelle de mon corps."
            ]
        };
        
        // Suivi de l'état de l'histoire
        const storyStates = {
            tristesse: {
                currentPhase: 0,
                phaseTime: 0,
                phaseDuration: 8000, // millisecondes par phase
                narrationPhase: 0
            },
            colere: {
                currentPhase: 0,
                phaseTime: 0,
                phaseDuration: 8000,
                narrationPhase: 0
            },
            degout: {
                currentPhase: 0,
                phaseTime: 0,
                phaseDuration: 8000,
                narrationPhase: 0
            }
        };
        
        function updateStoryProgress(sectionId, deltaTime) {
            try {
                const state = storyStates[sectionId];
                if (!state) return 0;
                
                // Mise à jour du temps de phase
                state.phaseTime += deltaTime;
                
                // Vérification s'il faut passer à la phase suivante
                if (state.phaseTime >= state.phaseDuration) {
                    state.currentPhase = Math.min(state.currentPhase + 1, 3);
                    state.phaseTime = 0;
                    
                    // Mise à jour des marqueurs de timeline
                    updateTimelineMarkers(sectionId, state.currentPhase);
                    
                    // Mise à jour du texte de narration si nécessaire
                    if (state.narrationPhase !== state.currentPhase) {
                        state.narrationPhase = state.currentPhase;
                        updateNarrationText(sectionId, state.narrationPhase);
                    }
                }
                
                // Mise à jour de la barre de progression
                const progressElement = document.getElementById(`${sectionId}-progress`);
                if (progressElement) {
                    const progressPercent = (state.currentPhase * state.phaseDuration + state.phaseTime) / (4 * state.phaseDuration) * 100;
                    progressElement.style.width = `${Math.min(progressPercent, 100)}%`;
                }
                
                return state.currentPhase;
            } catch (error) {
                console.error("Erreur dans updateStoryProgress:", error);
                return 0;
            }
        }
        
        function updateTimelineMarkers(sectionId, phase) {
            try {
                const markers = document.querySelectorAll(`#${sectionId} .timeline-marker`);
                
                markers.forEach((marker, index) => {
                    if (index <= phase) {
                        marker.classList.add('active');
                    } else {
                        marker.classList.remove('active');
                    }
                });
            } catch (error) {
                console.error("Erreur dans updateTimelineMarkers:", error);
            }
        }
        
        function updateNarrationText(sectionId, phase) {
            try {
                const narrationElement = document.querySelector(`#${sectionId} .emotion-narration`);
                if (!narrationElement) return;
                
                // Vérification que les narrations existent
                if (!narrations[sectionId] || !narrations[sectionId][phase]) return;
                
                // Fondu sortant
                narrationElement.classList.remove('visible');
                
                // Mise à jour du texte et fondu entrant
                setTimeout(() => {
                    narrationElement.textContent = narrations[sectionId][phase];
                    narrationElement.classList.add('visible');
                }, 500);
            } catch (error) {
                console.error("Erreur dans updateNarrationText:", error);
            }
        }

        /**
         * ======================================
         * ANIMATION DE TRISTESSE
         * ======================================
         */
 /**
 * ======================================
 * ANIMATION DE TRISTESSE AMÉLIORÉE
 * ======================================
 */
let photoFrames = [];
let memoryParticles = [];
let raindrops = [];
let puddles = [];
let reflections = [];

// Fonction pour réinitialiser l'histoire de tristesse
function resetTristesseStory() {
    try {
        // Suppression des cadres photo existants
        photoFrames.forEach(frame => {
            if (frame && frame.element && frame.element.parentNode) {
                frame.element.parentNode.removeChild(frame.element);
            }
        });
        photoFrames = [];
        
        // Réinitialisation des autres éléments
        memoryParticles = [];
        raindrops = [];
        puddles = [];
        reflections = [];
    } catch (error) {
        console.error("Erreur dans resetTristesseStory:", error);
    }
}

// Fonction pour créer un cadre photo plus élaboré
function createPhotoFrame(container, x, y, delay = 0, imageType = 'silhouette') {
    try {
        if (!container) return null;
        
        const frame = document.createElement('div');
        frame.className = 'photo-frame';
        frame.style.left = `${x}px`;
        frame.style.top = `${y}px`;
        frame.style.transform = `rotate(${(Math.random() - 0.5) * 20}deg)`;
        frame.style.boxShadow = '0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 5px rgba(0, 0, 0, 0.3)';
        frame.style.borderRadius = '5px';
        
        // Ajout de texture au cadre
        frame.style.borderImage = 'linear-gradient(45deg, #8a5a2b, #b8860b, #cd853f, #8a5a2b) 1';
        frame.style.borderWidth = '10px';
        frame.style.borderStyle = 'solid';
        
        const photo = document.createElement('div');
        photo.className = 'photo';
        
        // Différents types d'images dans les cadres
        if (imageType === 'silhouette') {
            // Silhouettes de personnes
            const silhouette = document.createElement('div');
            silhouette.className = 'photo-silhouette';
            
            // Style amélioré pour la silhouette
            silhouette.style.background = 'rgba(255, 255, 255, 0.2)';
            silhouette.style.width = '100px';
            silhouette.style.height = '150px';
            silhouette.style.borderRadius = '50% 50% 20% 20% / 30% 30% 70% 70%';
            silhouette.style.position = 'relative';
            
            // Ajout d'une deuxième silhouette pour créer une scène
            if (Math.random() > 0.5) {
                const silhouette2 = document.createElement('div');
                silhouette2.style.background = 'rgba(255, 255, 255, 0.15)';
                silhouette2.style.width = '80px';
                silhouette2.style.height = '130px';
                silhouette2.style.borderRadius = '50% 50% 20% 20% / 30% 30% 70% 70%';
                silhouette2.style.position = 'absolute';
                silhouette2.style.left = '60px';
                silhouette2.style.top = '10px';
                silhouette.appendChild(silhouette2);
            }
            
            photo.appendChild(silhouette);
        } else if (imageType === 'landscape') {
            // Photo de paysage
            photo.style.background = `linear-gradient(to bottom, 
                rgba(${100 + Math.random() * 50}, ${150 + Math.random() * 50}, ${200 + Math.random() * 55}, 0.7), 
                rgba(${30 + Math.random() * 40}, ${70 + Math.random() * 50}, ${100 + Math.random() * 55}, 0.8))`;
            
            // Ajouter des éléments de paysage
            const horizon = document.createElement('div');
            horizon.style.position = 'absolute';
            horizon.style.bottom = '40%';
            horizon.style.width = '100%';
            horizon.style.height = '1px';
            horizon.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
            photo.appendChild(horizon);
            
            // Ajouter des montagnes
            for (let i = 0; i < 3; i++) {
                const mountain = document.createElement('div');
                mountain.style.position = 'absolute';
                mountain.style.bottom = '40%';
                mountain.style.left = `${20 + i * 50}px`;
                mountain.style.width = '80px';
                mountain.style.height = '60px';
                mountain.style.backgroundColor = 'transparent';
                mountain.style.borderRadius = '50%';
                mountain.style.boxShadow = `0 -20px 0 0 rgba(${30 + i * 20}, ${40 + i * 10}, ${60 + i * 15}, 0.6)`;
                mountain.style.transform = 'rotate(45deg)';
                photo.appendChild(mountain);
            }
        } else if (imageType === 'abstract') {
            // Image abstraite
            photo.style.background = `radial-gradient(circle, 
                rgba(${150 + Math.random() * 105}, ${100 + Math.random() * 155}, ${150 + Math.random() * 105}, 0.7), 
                rgba(${50 + Math.random() * 100}, ${20 + Math.random() * 80}, ${100 + Math.random() * 155}, 0.8))`;
            
            // Ajouter des formes abstraites
            for (let i = 0; i < 5; i++) {
                const shape = document.createElement('div');
                shape.style.position = 'absolute';
                shape.style.width = `${10 + Math.random() * 50}px`;
                shape.style.height = `${10 + Math.random() * 50}px`;
                shape.style.borderRadius = `${Math.random() * 50}%`;
                shape.style.backgroundColor = `rgba(255, 255, 255, ${0.1 + Math.random() * 0.2})`;
                shape.style.left = `${Math.random() * 100}px`;
                shape.style.top = `${Math.random() * 150}px`;
                shape.style.transform = `rotate(${Math.random() * 360}deg)`;
                photo.appendChild(shape);
            }
        }
        
        // Ajout d'un effet de grain pour faire plus vintage
        const grain = document.createElement('div');
        grain.style.position = 'absolute';
        grain.style.top = '0';
        grain.style.left = '0';
        grain.style.width = '100%';
        grain.style.height = '100%';
        grain.style.background = 'url("data:image/svg+xml,%3Csvg viewBox=\'0 0 200 200\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cfilter id=\'a\'%3E%3CfeTurbulence type=\'fractalNoise\' baseFrequency=\'.65\' numOctaves=\'3\' stitchTiles=\'stitch\'/%3E%3C/filter%3E%3Crect width=\'100%25\' height=\'100%25\' filter=\'url(%23a)\'/%3E%3C/svg%3E")';
        grain.style.opacity = '0.1';
        grain.style.mixBlendMode = 'multiply';
        
        photo.appendChild(grain);
        frame.appendChild(photo);
        container.appendChild(frame);
        
        // Créer des particules de mémoire liées au cadre
        for (let i = 0; i < 10; i++) {
            memoryParticles.push({
                x: x + Math.random() * 200 - 100,
                y: y + Math.random() * 200 - 100,
                size: 2 + Math.random() * 3,
                speedX: (Math.random() - 0.5) * 0.2,
                speedY: (Math.random() - 0.5) * 0.2,
                opacity: 0.1 + Math.random() * 0.3,
                linkedFrame: frame,
                hue: Math.random() * 60 + 180, // Bleu clair à bleu foncé
                baseX: x + Math.random() * 200 - 100,
                baseY: y + Math.random() * 200 - 100,
                pulseFactor: Math.random() * 20,
                pulseSpeed: 0.005 + Math.random() * 0.01
            });
        }
        
        // Création d'un objet frame pour l'animation
        const frameObj = {
            element: frame,
            x: x,
            y: y,
            opacity: 0,
            rotation: (Math.random() - 0.5) * 20,
            delay: delay,
            floatOffset: 0,
            floatSpeed: 0.5 + Math.random() * 0.5,
            visible: false,
            imageType: imageType,
            // Paramètres pour l'animation de désintégration
            disintegrating: false,
            particleSystem: null,
            // Nouvelle propriété pour l'angle d'oscillation
            oscillationAngle: Math.random() * Math.PI * 2,
            oscillationSpeed: 0.001 + Math.random() * 0.002,
            oscillationAmplitude: 2 + Math.random() * 3
        };
        
        photoFrames.push(frameObj);
        return frameObj;
    } catch (error) {
        console.error("Erreur dans createPhotoFrame:", error);
        return null;
    }
}

// Création de particules de pluie améliorées
function createRaindrop(canvas, phase) {
    const drop = {
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        length: Math.random() * 20 + 10,
        speed: Math.random() * 10 + 5 + phase * 2, // La pluie s'intensifie avec les phases
        thickness: Math.random() * 2 + 1,
        active: true,
        // Propriétés pour l'effet de splash
        splashed: false,
        splashSize: 0,
        splashOpacity: 0.7,
        // Propriétés pour l'effet de trainée
        trail: [],
        // Propriété pour l'effet de distorsion
        distortion: Math.random() * 0.3,
        // Variation de couleur pour donner plus de profondeur
        color: `rgba(${180 + Math.random() * 30}, ${200 + Math.random() * 20}, ${250 + Math.random() * 5}, ${0.5 + Math.random() * 0.3})`
    };
    
    return drop;
}

// Fonction pour créer un effet de flaque plus réaliste
function createPuddle(canvas) {
    const puddle = {
        x: Math.random() * canvas.width,
        y: canvas.height * 0.85 + (Math.random() - 0.5) * 100,
        radiusX: 50 + Math.random() * 100,
        radiusY: 20 + Math.random() * 30,
        alpha: 0.1 + Math.random() * 0.3,
        // Propriétés pour l'animation d'ondulation
        ripples: [],
        // Propriétés pour la réflexion
        reflectionOpacity: 0.2 + Math.random() * 0.2,
        // Propriétés pour l'animation de la taille
        pulseTime: 0,
        pulseSpeed: 0.001 + Math.random() * 0.002,
        pulseAmount: 0.05 + Math.random() * 0.05
    };
    
    return puddle;
}

// Fonction pour créer une réflexion floue
function createReflection(x, y, width, height, type = 'light') {
    const reflection = {
        x: x,
        y: y,
        width: width,
        height: height,
        opacity: 0.1 + Math.random() * 0.1,
        type: type,
        pulseTime: 0,
        pulseSpeed: 0.001 + Math.random() * 0.002,
        color: type === 'light' 
            ? `rgba(255, 255, 255, 0.2)` 
            : `rgba(${100 + Math.random() * 30}, ${150 + Math.random() * 30}, ${200 + Math.random() * 30}, 0.15)`
    };
    
    return reflection;
}

function initTristesseCanvas() {
    try {
        const canvas = document.getElementById('tristesse-canvas');
        if (!canvas) {
            console.error("Canvas tristesse non trouvé");
            updateLoadingProgress(); // Continuer malgré l'erreur
            return;
        }
        
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('tristesse');
        
        // Définition du canvas à pleine taille
        function resizeCanvas() {
            if (canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Création des gouttes de pluie améliorées
        raindrops = [];
        const maxRaindrops = 200; // Plus de gouttes pour un effet plus dense
        
        for (let i = 0; i < maxRaindrops; i++) {
            raindrops.push(createRaindrop(canvas, 0));
        }
        
        // Création du personnage triste amélioré
        const character = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            size: 100,
            tears: [],
            tearTimer: 0,
            targetX: canvas.width / 2,
            targetY: canvas.height / 2,
            facingLeft: false,
            moveSpeed: 0.05,
            shoulderDrop: 0,
            expressionLevel: 0, // 0 = neutre, 1 = triste, 2 = très triste, 3 = dévasté
            // Nouvelles propriétés pour l'animation améliorée
            breatheCycle: 0,
            breatheSpeed: 0.02,
            shakeIntensity: 0,
            shakeDecay: 0.95,
            color: {
                body: { r: 100, g: 120, b: 160 },
                face: { r: 220, g: 220, b: 240 }
            },
            // Amélioration du visage
            face: {
                eyeBrowHeight: 0,
                eyeSize: 1,
                mouthCurve: 0,
                blinkTimer: 0,
                blinkInterval: Math.random() * 100 + 100,
                isBlinking: false,
                blinkDuration: 10,
                tearsWelling: 0,
                nose: { x: 0, y: -0.8, size: 0.05 },
                wrinkles: []
            },
            // Propriétés pour les animations corporelles
            body: {
                sway: 0,
                swaySpeed: 0.02,
                swayAmount: 0.1
            },
            // Ombre sous le personnage
            shadow: {
                x: 0,
                y: 0,
                size: 50,
                opacity: 0.3
            },
            // Effet de particules autour du personnage
            aura: {
                particles: [],
                maxParticles: 20,
                color: 'rgba(100, 150, 200, 0.2)',
                size: 120
            },
            // Posture qui change avec le niveau de tristesse
            posture: {
                slump: 0, // Le personnage s'affaisse avec la tristesse
                shoulderWidth: 100
            }
        };
        
        // Création des rides du visage qui apparaissent avec la tristesse
        for (let i = 0; i < 5; i++) {
            character.face.wrinkles.push({
                x: (Math.random() - 0.5) * 0.3,
                y: -0.9 + Math.random() * 0.2,
                length: 0.05 + Math.random() * 0.1,
                angle: (Math.random() - 0.5) * Math.PI / 6,
                opacity: 0
            });
        }
        
        // Initialisation des particules de l'aura
        for (let i = 0; i < character.aura.maxParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * character.aura.size;
            character.aura.particles.push({
                x: Math.cos(angle) * dist,
                y: Math.sin(angle) * dist,
                size: 1 + Math.random() * 3,
                opacity: Math.random() * 0.5,
                speedX: (Math.random() - 0.5) * 0.3,
                speedY: (Math.random() - 0.5) * 0.3,
                hue: 180 + Math.random() * 60, // Bleu clair à bleu foncé
                pulseSpeed: 0.01 + Math.random() * 0.02,
                pulseTime: Math.random() * Math.PI * 2
            });
        }
        
        // Création des cadres photo pour l'histoire avec des styles variés
        if (container) {
            createPhotoFrame(container, canvas.width * 0.2, canvas.height * 0.3, 0, 'silhouette');
            createPhotoFrame(container, canvas.width * 0.7, canvas.height * 0.25, 200, 'landscape');
            createPhotoFrame(container, canvas.width * 0.3, canvas.height * 0.6, 400, 'abstract');
            createPhotoFrame(container, canvas.width * 0.8, canvas.height * 0.55, 600, 'silhouette');
            createPhotoFrame(container, canvas.width * 0.15, canvas.height * 0.1, 800, 'landscape');
        }
        
        // Création de flaques améliorées
        puddles = [];
        const maxPuddles = 8; // Plus de flaques pour un meilleur effet
        
        for (let i = 0; i < maxPuddles; i++) {
            puddles.push(createPuddle(canvas));
        }
        
        // Création de réflexions pour ajouter de la profondeur
        reflections = [];
        for (let i = 0; i < 10; i++) {
            reflections.push(createReflection(
                Math.random() * canvas.width,
                Math.random() * canvas.height * 0.7 + canvas.height * 0.3,
                20 + Math.random() * 100,
                5 + Math.random() * 20,
                Math.random() > 0.5 ? 'light' : 'color'
            ));
        }
        
        // Éclairage du ciel pour le tonnerre
        let skyLightning = {
            active: false,
            intensity: 0,
            duration: 0,
            maxDuration: 0,
            // Paramètres améliorés pour l'éclair
            x: 0,
            width: 0,
            branches: []
        };
        
        // Suivi du temps
        let lastTime = 0;
        let elapsedTime = 0;
        
        function animate(time) {
            try {
                // Calcul du delta de temps
                const deltaTime = Math.min(50, time - lastTime); // Limiter le deltaTime pour éviter les saccades
                lastTime = time;
                elapsedTime += deltaTime;
                
                // Mise à jour de la progression de l'histoire
                const phase = updateStoryProgress('tristesse', deltaTime);
                
                // Mises à jour spécifiques à la phase
                updatePhaseElements(phase, deltaTime, elapsedTime);
                
                // Effacement du canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Dessin de l'arrière-plan amélioré avec un dégradé basé sur la phase de l'histoire
                const skyDarkness = 0.2 + (phase * 0.2);
                drawSkyBackground(ctx, canvas, phase, skyDarkness, elapsedTime);
                
                // Effet de brouillard/brume qui se déplace lentement
                drawMovingFog(ctx, canvas, phase, elapsedTime);
                
                // Dessin des réflexions (avant les éléments qui les projettent)
                drawReflections(ctx, reflections, elapsedTime);
                
                // Effet d'éclair amélioré
                if (skyLightning.active) {
                    drawLightning(ctx, canvas, skyLightning, deltaTime);
                } else if (phase >= 2 && Math.random() < 0.002) {
                    // Éclair aléatoire dans les phases ultérieures
                    initiateLightning(canvas, skyLightning);
                }
                
                // Dessin des particules de mémoire liées aux cadres photo
                drawMemoryParticles(ctx, phase, elapsedTime);
                
                // Dessin de la pluie avec une intensité et des effets basés sur la phase de l'histoire
                drawEnhancedRain(ctx, canvas, raindrops, phase, deltaTime, elapsedTime);
                
                // Dessin des flaques améliorées
                drawEnhancedPuddles(ctx, puddles, phase, deltaTime, elapsedTime);
                
                // Mise à jour et dessin du personnage amélioré
                updateCharacter(character, phase, deltaTime, elapsedTime, canvas);
                drawEnhancedCharacter(ctx, character, phase, elapsedTime);
                
                requestAnimationFrame(animate);
            } catch (error) {
                console.error("Erreur dans animate de tristesse:", error);
                requestAnimationFrame(animate); // Continuer l'animation malgré l'erreur
            }
        }
        
        function drawSkyBackground(ctx, canvas, phase, skyDarkness, time) {
            // Dégradé principal du ciel
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, `rgba(${30 - phase * 8}, ${58 - phase * 15}, ${90 - phase * 20}, 1)`);
            gradient.addColorStop(1, `rgba(${15 - phase * 4}, ${29 - phase * 8}, ${45 - phase * 10}, 1)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ajouter des nuages dynamiques en arrière-plan
            const cloudCount = 5 + phase * 2; // Plus de nuages dans les phases avancées
            
            for (let i = 0; i < cloudCount; i++) {
                const cloudX = ((time * 0.02 * (i * 0.1 + 0.1)) % (canvas.width + 500)) - 250;
                const cloudY = canvas.height * (0.1 + (i * 0.15));
                const cloudWidth = 200 + i * 50 + Math.sin(time * 0.001 + i) * 20;
                const cloudHeight = 80 + i * 15 + Math.cos(time * 0.001 + i) * 10;
                const cloudOpacity = 0.1 + (phase * 0.03) + (i * 0.02);
                
                // Créer un dégradé pour le nuage
                const cloudGradient = ctx.createRadialGradient(
                    cloudX + cloudWidth/2, cloudY + cloudHeight/2, 0,
                    cloudX + cloudWidth/2, cloudY + cloudHeight/2, cloudWidth/2
                );
                cloudGradient.addColorStop(0, `rgba(${40 - phase * 8}, ${50 - phase * 10}, ${70 - phase * 15}, ${cloudOpacity})`);
                cloudGradient.addColorStop(1, `rgba(${40 - phase * 8}, ${50 - phase * 10}, ${70 - phase * 15}, 0)`);
                
                ctx.fillStyle = cloudGradient;
                ctx.beginPath();
                ctx.ellipse(cloudX + cloudWidth/2, cloudY + cloudHeight/2, cloudWidth/2, cloudHeight/2, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawMovingFog(ctx, canvas, phase, time) {
            // Ajouter du brouillard qui se déplace lentement
            const fogOpacity = 0.1 + phase * 0.05;
            const fogLayerCount = 3;
            
            for (let i = 0; i < fogLayerCount; i++) {
                // Calculer le décalage en fonction du temps et de la couche
                const fogSpeed = 0.2 + i * 0.1;
                const xOffset = (time * fogSpeed * 0.01) % canvas.width;
                
                // Créer un dégradé pour le brouillard
                const fogGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                fogGradient.addColorStop(0, `rgba(${100 - phase * 10}, ${120 - phase * 15}, ${150 - phase * 20}, 0)`);
                fogGradient.addColorStop(0.2, `rgba(${100 - phase * 10}, ${120 - phase * 15}, ${150 - phase * 20}, ${fogOpacity * (i+1) / fogLayerCount})`);
                fogGradient.addColorStop(0.8, `rgba(${100 - phase * 10}, ${120 - phase * 15}, ${150 - phase * 20}, ${fogOpacity * (i+1) / fogLayerCount})`);
                fogGradient.addColorStop(1, `rgba(${100 - phase * 10}, ${120 - phase * 15}, ${150 - phase * 20}, 0)`);
                
                // Dessiner le brouillard avec un effet ondulant
                ctx.fillStyle = fogGradient;
                ctx.beginPath();
                
                // Départ du chemin
                ctx.moveTo(-100, canvas.height * (0.6 + i * 0.1));
                
                // Créer une ligne ondulante
                for (let x = 0; x <= canvas.width + 200; x += 100) {
                    const waveY = Math.sin((x + xOffset) * 0.01 + i) * 20;
                    const y = canvas.height * (0.6 + i * 0.1) + waveY;
                    ctx.lineTo(x - 100, y);
                }
                
                // Fermer le chemin
                ctx.lineTo(canvas.width + 100, canvas.height);
                ctx.lineTo(-100, canvas.height);
                ctx.closePath();
                ctx.fill();
            }
        }
        
        function initiateLightning(canvas, lightning) {
            lightning.active = true;
            lightning.duration = 0;
            lightning.maxDuration = 10 + Math.random() * 20;
            lightning.x = Math.random() * canvas.width;
            lightning.width = 5 + Math.random() * 10;
            lightning.branches = [];
            
            // Générer des branches pour l'éclair
            const branchCount = 2 + Math.floor(Math.random() * 3);
            for (let i = 0; i < branchCount; i++) {
                lightning.branches.push({
                    x: lightning.x + (Math.random() - 0.5) * 200,
                    y: Math.random() * canvas.height * 0.4,
                    width: 2 + Math.random() * 4,
                    segments: 4 + Math.floor(Math.random() * 4),
                    points: []
                });
                
                // Générer les points du tracé de la branche
                const branch = lightning.branches[i];
                let currentX = branch.x;
                let currentY = 0;
                branch.points.push({ x: currentX, y: currentY });
                
                for (let j = 0; j < branch.segments; j++) {
                    currentX += (Math.random() - 0.5) * 100;
                    currentY += canvas.height * 0.4 / branch.segments;
                    branch.points.push({ x: currentX, y: currentY });
                }
            }
        }
        
        function drawLightning(ctx, canvas, lightning, deltaTime) {
            lightning.duration++;
            
            if (lightning.duration < lightning.maxDuration / 2) {
                lightning.intensity = lightning.duration / (lightning.maxDuration / 2);
            } else {
                lightning.intensity = 1 - ((lightning.duration - lightning.maxDuration / 2) / (lightning.maxDuration / 2));
            }
            
            if (lightning.duration >= lightning.maxDuration) {
                lightning.active = false;
            }
            
            // Éclairer tout l'écran avec l'éclair
            ctx.fillStyle = `rgba(255, 255, 255, ${lightning.intensity * 0.2})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Dessiner le corps principal de l'éclair
            ctx.strokeStyle = `rgba(255, 255, 255, ${lightning.intensity * 0.9})`;
            ctx.lineWidth = lightning.width * lightning.intensity;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'rgba(200, 220, 255, 0.8)';
            
            // Dessiner les branches de l'éclair
            for (const branch of lightning.branches) {
                ctx.beginPath();
                for (let i = 0; i < branch.points.length; i++) {
                    const point = branch.points[i];
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.stroke();
                
                // Dessiner un halo autour de l'éclair
                ctx.save();
                ctx.strokeStyle = `rgba(200, 220, 255, ${lightning.intensity * 0.5})`;
                ctx.lineWidth = branch.width * 3 * lightning.intensity;
                ctx.beginPath();
                for (let i = 0; i < branch.points.length; i++) {
                    const point = branch.points[i];
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }
            
            // Réinitialiser les ombres
            ctx.shadowBlur = 0;
        }
        
        function drawMemoryParticles(ctx, phase, time) {
            for (let i = 0; i < memoryParticles.length; i++) {
                const particle = memoryParticles[i];
                
                // Ne dessiner que si le cadre associé est visible
                const frame = photoFrames.find(f => f.element === particle.linkedFrame);
                if (!frame || !frame.visible) continue;
                
                // Si le cadre est en train de se désintégrer, les particules deviennent plus vives
                const extraOpacity = frame.disintegrating ? 0.5 : 0;
                const extraSize = frame.disintegrating ? 2 : 0;
                
                // Calculer la position avec un effet d'oscillation
                const oscillation = Math.sin(time * particle.pulseSpeed) * particle.pulseFactor;
                const x = particle.baseX + oscillation * (Math.random() - 0.5);
                const y = particle.baseY + oscillation * (Math.random() - 0.5);
                
                // Dessiner la particule
                ctx.fillStyle = `hsla(${particle.hue}, 80%, 70%, ${particle.opacity + extraOpacity})`;
                ctx.beginPath();
                ctx.arc(x, y, particle.size + extraSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Dessiner un halo autour de la particule
                ctx.fillStyle = `hsla(${particle.hue}, 80%, 70%, ${(particle.opacity + extraOpacity) * 0.5})`;
                ctx.beginPath();
                ctx.arc(x, y, (particle.size + extraSize) * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Mouvement des particules
                particle.baseX += particle.speedX * (1 + phase * 0.5); // Accélération basée sur la phase
                particle.baseY += particle.speedY * (1 + phase * 0.5);
                
                // Attirer les particules vers le cadre lorsqu'il se désintègre
                if (frame.disintegrating) {
                    const dx = frame.x - particle.baseX;
                    const dy = frame.y - particle.baseY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 10) {
                        particle.speedX += dx / dist * 0.05;
                        particle.speedY += dy / dist * 0.05;
                    }
                }
                
                // Appliquer une résistance pour ralentir les particules
                particle.speedX *= 0.99;
                particle.speedY *= 0.99;
                
                // Mettre à jour la couleur en fonction de la phase
                particle.hue = 180 + phase * 20 + Math.sin(time * 0.001) * 10;
            }
        }
        
        function drawEnhancedRain(ctx, canvas, raindrops, phase, deltaTime, time) {
            const activeDrops = raindrops.length * (0.3 + phase * 0.2);
            
            // Ajuster l'intensité de la pluie en fonction de la phase
            if (Math.random() < 0.1 * phase && raindrops.length < 300) {
                raindrops.push(createRaindrop(canvas, phase));
            }
            
            for (let i = 0; i < raindrops.length; i++) {
                const drop = raindrops[i];
                
                // Activation/désactivation des gouttes en fonction de la phase actuelle
                if (i < activeDrops) {
                    drop.active = true;
                } else {
                    drop.active = false;
                }
                
                if (!drop.active) continue;
                
                // Effet de distorsion de la goutte
                const distortion = Math.sin(time * 0.001 + i) * drop.distortion;
                
                // Dessiner la goutte avec une légère distorsion
                ctx.strokeStyle = drop.color;
                ctx.beginPath();
                ctx.moveTo(drop.x + distortion, drop.y);
                ctx.lineTo(drop.x + distortion, drop.y + drop.length);
                ctx.lineWidth = drop.thickness;
                ctx.stroke();
                
                // Effet de trainée/reflet sur les gouttes
                if (drop.trail.length > 0) {
                    for (let j = 0; j < drop.trail.length; j++) {
                        const trailSegment = drop.trail[j];
                        ctx.strokeStyle = `rgba(200, 220, 255, ${trailSegment.opacity})`;
                        ctx.beginPath();
                        ctx.moveTo(trailSegment.x, trailSegment.y);
                        ctx.lineTo(trailSegment.x, trailSegment.y + trailSegment.length);
                        ctx.lineWidth = trailSegment.thickness * 0.5;
                        ctx.stroke();
                        
                        // Faire disparaître progressivement la trainée
                        trailSegment.opacity -= 0.05;
                    }
                    
                    // Supprimer les segments de trainée qui ne sont plus visibles
                    drop.trail = drop.trail.filter(segment => segment.opacity > 0);
                }
                
                // Ajouter occasionnellement un segment de trainée
                if (Math.random() < 0.1 && drop.length > 12) {
                    drop.trail.push({
                        x: drop.x + (Math.random() - 0.5) * 2, // Légère variation de position
                        y: drop.y,
                        length: drop.length * 0.7,
                        thickness: drop.thickness * 0.7,
                        opacity: 0.3 + Math.random() * 0.2
                    });
                }
                
                // Mise à jour de la position
                drop.y += drop.speed * (deltaTime / 16);
                
                // Gestion des collisions avec le sol ou les flaques
                if (drop.y > canvas.height) {
                    // Créer un effet de splash lors de l'impact
                    if (!drop.splashed) {
                        drop.splashed = true;
                        drop.splashSize = drop.thickness * 3;
                        drop.splashOpacity = 0.7;
                        
                        // Ajouter une ondulation à une flaque proche si possible
                        let nearestPuddle = null;
                        let nearestDistance = Infinity;
                        
                        for (const puddle of puddles) {
                            const dx = puddle.x - drop.x;
                            const dy = puddle.y - drop.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < nearestDistance && distance < puddle.radiusX) {
                                nearestDistance = distance;
                                nearestPuddle = puddle;
                            }
                        }
                        
                        if (nearestPuddle) {
                            nearestPuddle.ripples.push({
                                x: drop.x + (Math.random() - 0.5) * 10,
                                y: nearestPuddle.y + (Math.random() - 0.5) * 10,
                                radius: 2,
                                maxRadius: 10 + Math.random() * 10,
                                opacity: 0.5 + Math.random() * 0.3,
                                speed: 0.2 + Math.random() * 0.3
                            });
                        }
                    }
                    
                    // Dessiner le splash
                    if (drop.splashOpacity > 0) {
                        ctx.fillStyle = `rgba(180, 200, 255, ${drop.splashOpacity})`;
                        ctx.beginPath();
                        ctx.arc(drop.x, canvas.height, drop.splashSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Faire disparaître progressivement le splash
                        drop.splashSize += 0.2;
                        drop.splashOpacity -= 0.05;
                    } else {
                        // Réinitialiser la goutte pour la réutiliser
                        drop.y = -drop.length;
                        drop.x = Math.random() * canvas.width;
                        drop.splashed = false;
                        
                        // Variation légère de la vitesse et de l'apparence
                        drop.speed = Math.random() * 10 + 5 + phase * 2;
                        drop.thickness = Math.random() * 2 + 1;
                        drop.length = Math.random() * 20 + 10;
                    }
                }
            }
        }
        
        function drawEnhancedPuddles(ctx, puddles, phase, deltaTime, time) {
            for (let puddle of puddles) {
                // Animation de "respiration" pour la flaque
                puddle.pulseTime += puddle.pulseSpeed * deltaTime;
                const pulseFactor = 1 + Math.sin(puddle.pulseTime) * puddle.pulseAmount;
                
                // Dessiner la flaque de base avec un dégradé plus complexe
                const gradient = ctx.createRadialGradient(
                    puddle.x, 
                    puddle.y, 
                    5, 
                    puddle.x, 
                    puddle.y, 
                    puddle.radiusX * pulseFactor
                );
                gradient.addColorStop(0, `rgba(100, 150, 255, ${puddle.alpha * (1 + phase * 0.1)})`);
                gradient.addColorStop(0.7, `rgba(80, 120, 200, ${puddle.alpha * 0.8 * (1 + phase * 0.1)})`);
                gradient.addColorStop(1, `rgba(100, 150, 255, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(
                    puddle.x, 
                    puddle.y, 
                    puddle.radiusX * pulseFactor, 
                    puddle.radiusY * pulseFactor, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                
                // Ajouter un contour subtil
                ctx.strokeStyle = `rgba(150, 180, 255, ${puddle.alpha * 0.5})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Dessiner les ondulations existantes
                for (let i = 0; i < puddle.ripples.length; i++) {
                    const ripple = puddle.ripples[i];
                    
                    ctx.strokeStyle = `rgba(180, 220, 255, ${ripple.opacity})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Agrandir et faire disparaître l'ondulation
                    ripple.radius += ripple.speed * (deltaTime / 16);
                    ripple.opacity -= 0.01 * (deltaTime / 16);
                    
                    // Supprimer si complètement disparu ou trop grand
                    if (ripple.opacity <= 0 || ripple.radius >= ripple.maxRadius) {
                        puddle.ripples.splice(i, 1);
                        i--;
                    }
                }
                
                // Ajouter occasionnellement une ondulation spontanée
                if (Math.random() < 0.01 * (1 + phase * 0.5)) {
                    puddle.ripples.push({
                        x: puddle.x + (Math.random() - 0.5) * puddle.radiusX * 0.8,
                        y: puddle.y + (Math.random() - 0.5) * puddle.radiusY * 0.8,
                        radius: 2,
                        maxRadius: 10 + Math.random() * 10,
                        opacity: 0.3 + Math.random() * 0.2,
                        speed: 0.1 + Math.random() * 0.2
                    });
                }
                
                // Réflexions scintillantes dans la flaque
                const reflectionCount = 3 + Math.floor(phase * 2);
                for (let i = 0; i < reflectionCount; i++) {
                    const reflectionX = puddle.x + (Math.random() - 0.5) * puddle.radiusX * 0.6;
                    const reflectionY = puddle.y + (Math.random() - 0.5) * puddle.radiusY * 0.6;
                    const reflectionSize = 1 + Math.random() * 3;
                    const reflectionOpacity = (0.1 + Math.random() * 0.3) * 
                                             Math.sin(time * 0.002 + i * 5);
                    
                    if (reflectionOpacity > 0) {
                        ctx.fillStyle = `rgba(200, 220, 255, ${reflectionOpacity})`;
                        ctx.beginPath();
                        ctx.arc(reflectionX, reflectionY, reflectionSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        function drawReflections(ctx, reflections, time) {
            for (const reflection of reflections) {
                reflection.pulseTime += reflection.pulseSpeed;
                const opacity = reflection.opacity * (0.7 + Math.sin(reflection.pulseTime) * 0.3);
                
                // Dégradé pour la réflexion
                const gradient = ctx.createLinearGradient(
                    reflection.x, 
                    reflection.y - reflection.height/2, 
                    reflection.x, 
                    reflection.y + reflection.height/2
                );
                gradient.addColorStop(0, `${reflection.color.replace(/[\d.]+\)$/g, '0)')}`);
                gradient.addColorStop(0.5, reflection.color.replace(/[\d.]+\)$/g, `${opacity})`));
                gradient.addColorStop(1, `${reflection.color.replace(/[\d.]+\)$/g, '0)')}`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.ellipse(
                    reflection.x, 
                    reflection.y, 
                    reflection.width/2, 
                    reflection.height/2, 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            }
        }
        
        function updateCharacter(character, phase, deltaTime, time, canvas) {
            // Mise à jour du mouvement et des émotions en fonction de la phase
            switch (phase) {
                case 0:
                    character.targetX = canvas.width * 0.7;
                    character.targetY = canvas.height * 0.4;
                    character.expressionLevel = 0.5;
                    character.facingLeft = true;
                    character.shakeIntensity = 0;
                    break;
                case 1:
                    character.targetX = canvas.width * 0.3;
                    character.targetY = canvas.height * 0.45;
                    character.expressionLevel = 1;
                    character.facingLeft = false;
                    character.shakeIntensity = Math.random() < 0.02 ? 5 : character.shakeIntensity * character.shakeDecay;
                    break;
                case 2:
                    character.targetX = canvas.width * 0.5;
                    character.targetY = canvas.height * 0.5;
                    character.expressionLevel = 2;
                    character.facingLeft = false;
                    character.shakeIntensity = Math.random() < 0.05 ? 10 : character.shakeIntensity * character.shakeDecay;
                    break;
                case 3:
                    character.targetX = canvas.width * 0.5;
                    character.targetY = canvas.height * 0.55;
                    character.expressionLevel = 3;
                    character.shoulderDrop = Math.min(character.shoulderDrop + 0.01, 0.3);
                    character.shakeIntensity = Math.random() < 0.1 ? 15 : character.shakeIntensity * character.shakeDecay;
                    break;
            }
            
            // Animation de respiration
            character.breatheCycle += character.breatheSpeed * deltaTime;
            
            // Animation de balancement du corps
            character.body.sway += character.body.swaySpeed * deltaTime;
            
            // Mise à jour du clignement des yeux
            character.face.blinkTimer += 1;
            if (character.face.blinkTimer >= character.face.blinkInterval) {
                character.face.isBlinking = true;
                character.face.blinkTimer = 0;
                character.face.blinkInterval = Math.random() * 100 + 100;
            }
            
            if (character.face.isBlinking) {
                character.face.blinkDuration -= 1;
                if (character.face.blinkDuration <= 0) {
                    character.face.isBlinking = false;
                    character.face.blinkDuration = 10;
                }
            }
            
            // Interpolation de la position du personnage avec effet de tremblement
            const shakeX = (Math.random() - 0.5) * character.shakeIntensity;
            const shakeY = (Math.random() - 0.5) * character.shakeIntensity;
            
            character.x += ((character.targetX - character.x) * character.moveSpeed + shakeX) * (deltaTime / 16);
            character.y += ((character.targetY - character.y) * character.moveSpeed + shakeY) * (deltaTime / 16);
            
            // Mise à jour de la position de l'ombre
            character.shadow.x = character.x;
            character.shadow.y = character.y + character.size * 1.2;
            
            // Mise à jour des paramètres du visage en fonction du niveau d'expression
            character.face.eyeBrowHeight = 0.1 + character.expressionLevel * 0.15;
            character.face.eyeSize = 1 - character.expressionLevel * 0.3;
            character.face.mouthCurve = 0.2 + character.expressionLevel * 0.3;
            character.face.tearsWelling = Math.min(1, character.expressionLevel);
            
            // Mise à jour de l'affaissement en fonction du niveau de tristesse
            character.posture.slump = character.expressionLevel * 0.15;
            
            // Mise à jour des rides du visage
            for (const wrinkle of character.face.wrinkles) {
                wrinkle.opacity = Math.max(0, character.expressionLevel - 1) * 0.7;
            }
            
            // Animation des larmes - plus fréquentes en fonction de la phase
            character.tearTimer += 1;
            const tearInterval = Math.max(30 - phase * 8, 10);
            
            if (character.tearTimer > tearInterval) {
                character.tearTimer = 0;
                character.tears.push({
                    x: character.x - character.size * 0.2,
                    y: character.y - character.size * 0.9,
                    size: 5,
                    speed: 2 + phase * 0.5,
                    alpha: 0.7,
                    // Propriétés supplémentaires
                    wobble: Math.random() * Math.PI * 2,
                    wobbleSpeed: 0.1 + Math.random() * 0.1,
                    wobbleAmount: 0.5 + Math.random() * 1,
                    trail: []
                });
                character.tears.push({
                    x: character.x + character.size * 0.2,
                    y: character.y - character.size * 0.9,
                    size: 5,
                    speed: 2 + phase * 0.5,
                    alpha: 0.7,
                    wobble: Math.random() * Math.PI * 2,
                    wobbleSpeed: 0.1 + Math.random() * 0.1,
                    wobbleAmount: 0.5 + Math.random() * 1,
                    trail: []
                });
            }
            
            // Mise à jour des particules de l'aura
            for (const particle of character.aura.particles) {
                // Mise à jour de la position
                particle.x += particle.speedX * (deltaTime / 16);
                particle.y += particle.speedY * (deltaTime / 16);
                
                // Pulsation de l'opacité
                particle.pulseTime += particle.pulseSpeed * (deltaTime / 16);
                particle.opacity = 0.1 + Math.sin(particle.pulseTime) * 0.1;
                
                // Effet d'attraction vers le personnage proportionnel à la distance
                const distX = particle.x;
                const distY = particle.y;
                const distance = Math.sqrt(distX * distX + distY * distY);
                
                if (distance > character.aura.size * 0.8) {
                    particle.speedX -= distX * 0.001;
                    particle.speedY -= distY * 0.001;
                } else if (distance < character.aura.size * 0.2) {
                    particle.speedX += distX * 0.001;
                    particle.speedY += distY * 0.001;
                }
                
                // Limiter la vitesse
                const speed = Math.sqrt(particle.speedX * particle.speedX + particle.speedY * particle.speedY);
                if (speed > 0.5) {
                    particle.speedX = (particle.speedX / speed) * 0.5;
                    particle.speedY = (particle.speedY / speed) * 0.5;
                }
                
                // Augmenter l'intensité de l'aura avec la phase
                particle.hue = 180 + phase * 15;
            }
        }
        
        function drawEnhancedCharacter(ctx, character, phase, time) {
            // Dessiner l'ombre sous le personnage
            ctx.fillStyle = `rgba(0, 0, 30, ${character.shadow.opacity})`;
            ctx.beginPath();
            ctx.ellipse(
                character.shadow.x, 
                character.shadow.y, 
                character.shadow.size * 1.2, 
                character.shadow.size * 0.3, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Dessiner l'aura triste autour du personnage
            if (phase >= 1) {
                const auraIntensity = (phase - 1) * 0.1;
                const auraRadius = character.aura.size * (1 + Math.sin(time * 0.001) * 0.1);
                
                // Aura principale
                const auraGradient = ctx.createRadialGradient(
                    character.x, character.y,
                    0,
                    character.x, character.y,
                    auraRadius
                );
                auraGradient.addColorStop(0, `rgba(100, 150, 200, ${0.05 + auraIntensity})`);
                auraGradient.addColorStop(0.7, `rgba(80, 120, 180, ${0.03 + auraIntensity * 0.5})`);
                auraGradient.addColorStop(1, 'rgba(100, 150, 200, 0)');
                
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(character.x, character.y, auraRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Dessiner les particules de l'aura
                for (const particle of character.aura.particles) {
                    ctx.fillStyle = `hsla(${particle.hue}, 70%, 60%, ${particle.opacity})`;
                    ctx.beginPath();
                    ctx.arc(
                        character.x + particle.x, 
                        character.y + particle.y, 
                        particle.size, 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            // Calculer l'effet de respiration
            const breatheEffect = Math.sin(character.breatheCycle) * 0.05;
            
            // Calcul de l'effet d'épaule tombante
            const swayEffect = Math.sin(character.body.sway) * character.body.swayAmount;
            const actualShoulderDrop = character.shoulderDrop * (1 + Math.sin(time * 0.001) * 0.3) + swayEffect;
            
            // Ajuster les couleurs en fonction de la phase
            const blueLevel = Math.max(138 - phase * 20, 80);
            const bodyColor = `rgb(${blueLevel * 0.6}, ${blueLevel * 0.8}, ${blueLevel})`;
            
            // Corps avec épaules tombantes et affaissement
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            
            if (character.facingLeft) {
                // Version de face, avec un effet de respiration
                ctx.ellipse(
                    character.x, 
                    character.y, 
                    character.size / 2 * (1 + breatheEffect), 
                    character.size * (1 - breatheEffect), 
                    0, 0, Math.PI * 2
                );
            } else {
                // Corps asymétrique avec épaule tombante et affaissement basé sur la tristesse
                const slumpFactor = 1 - character.posture.slump;
                
                // Point de départ - épaule gauche
                ctx.moveTo(
                    character.x - character.posture.shoulderWidth / 2 * slumpFactor, 
                    character.y - character.size * 0.8 + actualShoulderDrop * character.size
                );
                
                // Courbe vers le haut et la droite pour le dessus du corps
                ctx.quadraticCurveTo(
                    character.x, 
                    character.y - character.size * (1 - character.posture.slump), 
                    character.x + character.posture.shoulderWidth / 2 * slumpFactor, 
                    character.y - character.size * 0.8
                );
                
                // Courbe vers le bas pour le côté droit
                ctx.quadraticCurveTo(
                    character.x + character.size / 2 * (1 + breatheEffect), 
                    character.y, 
                    character.x + character.size / 2 * slumpFactor, 
                    character.y + character.size * 0.8
                );
                
                // Courbe pour le bas du corps
                ctx.quadraticCurveTo(
                    character.x, 
                    character.y + character.size * (1 - breatheEffect), 
                    character.x - character.size / 2 * slumpFactor, 
                    character.y + character.size * 0.8
                );
                
                // Courbe pour fermer le côté gauche
                ctx.quadraticCurveTo(
                    character.x - character.size / 2 * (1 + breatheEffect), 
                    character.y, 
                    character.x - character.posture.shoulderWidth / 2 * slumpFactor, 
                    character.y - character.size * 0.8 + actualShoulderDrop * character.size
                );
            }
            ctx.fill();
            
            // Ajouter un léger contour au corps
            ctx.strokeStyle = `rgba(${blueLevel * 0.4}, ${blueLevel * 0.6}, ${blueLevel * 0.8}, 0.5)`;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Tête
            ctx.fillStyle = `rgb(${character.face.face.r}, ${character.face.face.g}, ${character.face.face.b})`;
            ctx.beginPath();
            ctx.arc(
                character.x, 
                character.y - character.size * 0.9 + swayEffect * 10, 
                character.size / 2, 
                0, Math.PI * 2
            );
            ctx.fill();
            
            // Contour subtil de la tête
            ctx.strokeStyle = `rgba(${character.face.face.r * 0.7}, ${character.face.face.g * 0.7}, ${character.face.face.b * 0.7}, 0.5)`;
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // Visage
            // Rides de tristesse autour des yeux et de la bouche
            if (phase >= 2) {
                ctx.strokeStyle = `rgba(${character.face.face.r * 0.7}, ${character.face.face.g * 0.7}, ${character.face.face.b * 0.7}, ${0.3 + phase * 0.1})`;
                ctx.lineWidth = 1;
                
                // Rides autour des yeux
                for (const wrinkle of character.face.wrinkles) {
                    if (wrinkle.opacity <= 0) continue;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        character.x + (wrinkle.x - wrinkle.length/2) * character.size,
                        character.y + wrinkle.y * character.size
                    );
                    ctx.lineTo(
                        character.x + (wrinkle.x + wrinkle.length/2) * character.size,
                        character.y + (wrinkle.y + Math.sin(wrinkle.angle) * wrinkle.length) * character.size
                    );
                    ctx.strokeStyle = `rgba(${character.face.face.r * 0.7}, ${character.face.face.g * 0.7}, ${character.face.face.b * 0.7}, ${wrinkle.opacity})`;
                    ctx.stroke();
                }
            }
            
            // Nez
            if (phase >= 1) {
                ctx.fillStyle = `rgba(${character.face.face.r * 0.9}, ${character.face.face.g * 0.9}, ${character.face.face.b * 0.9}, 0.5)`;
                ctx.beginPath();
                ctx.arc(
                    character.x + character.face.nose.x * character.size, 
                    character.y + character.face.nose.y * character.size, 
                    character.face.nose.size * character.size, 
                    0, Math.PI * 2
                );
                ctx.fill();
            }
            
            // Yeux - plus larges ou plus fermés en fonction du niveau de tristesse
            const blinking = character.face.isBlinking ? 0.9 : 0;
            const eyeWidthFactor = character.face.eyeSize - blinking;
            const eyeHeightFactor = character.face.eyeSize - blinking;
            
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(
                character.x - character.size * 0.2, 
                character.y - character.size * 1, 
                character.size * 0.08 * eyeWidthFactor, 
                character.size * 0.08 * eyeHeightFactor, 
                0, 0, Math.PI * 2
            );
            ctx.ellipse(
                character.x + character.size * 0.2, 
                character.y - character.size * 1, 
                character.size * 0.08 * eyeWidthFactor, 
                character.size * 0.08 * eyeHeightFactor, 
                0, 0, Math.PI * 2
            );
            ctx.fill();
            
            // Iris et pupilles
            if (!character.face.isBlinking) {
                const gazeOffset = phase > 1 ? (Math.sin(time * 0.001) * 2) : 0; // Regard qui erre aux phases avancées
                
                // Iris (couleur des yeux)
                ctx.fillStyle = `rgba(${70 - phase * 10}, ${100 - phase * 10}, ${150 - phase * 10}, 1)`;
                ctx.beginPath();
                ctx.arc(
                    character.x - character.size * 0.2 + gazeOffset, 
                    character.y - character.size * 1, 
                    character.size * 0.05 * eyeWidthFactor, 
                    0, Math.PI * 2
                );
                ctx.arc(
                    character.x + character.size * 0.2 + gazeOffset, 
                    character.y - character.size * 1, 
                    character.size * 0.05 * eyeWidthFactor, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Pupilles
                ctx.fillStyle = "rgba(30, 30, 40, 1)";
                ctx.beginPath();
                ctx.arc(
                    character.x - character.size * 0.2 + gazeOffset, 
                    character.y - character.size * 1, 
                    character.size * 0.025 * eyeWidthFactor, 
                    0, Math.PI * 2
                );
                ctx.arc(
                    character.x + character.size * 0.2 + gazeOffset, 
                    character.y - character.size * 1, 
                    character.size * 0.025 * eyeWidthFactor, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Reflet des yeux
                ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                ctx.beginPath();
                ctx.arc(
                    character.x - character.size * 0.22 + gazeOffset, 
                    character.y - character.size * 1.02, 
                    character.size * 0.01, 
                    0, Math.PI * 2
                );
                ctx.arc(
                    character.x + character.size * 0.18 + gazeOffset, 
                    character.y - character.size * 1.02, 
                    character.size * 0.01, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Larmes qui s'accumulent dans les yeux
                if (character.face.tearsWelling > 0.5) {
                    ctx.fillStyle = `rgba(120, 180, 255, ${(character.face.tearsWelling - 0.5) * 0.8})`;
                    ctx.beginPath();
                    // Larme qui s'accumule dans l'œil gauche
                    ctx.ellipse(
                        character.x - character.size * 0.2, 
                        character.y - character.size * 0.98, 
                        character.size * 0.08 * 0.8, 
                        character.size * 0.03, 
                        0, 0, Math.PI * 2
                    );
                    // Larme qui s'accumule dans l'œil droit
                    ctx.ellipse(
                        character.x + character.size * 0.2, 
                        character.y - character.size * 0.98, 
                        character.size * 0.08 * 0.8, 
                        character.size * 0.03, 
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }
            
            // Sourcils - plus inclinés en fonction de la tristesse
            const eyebrowAngle = character.face.eyeBrowHeight;
            
            ctx.strokeStyle = `rgba(${character.face.face.r * 0.7}, ${character.face.face.g * 0.7}, ${character.face.face.b * 0.7}, 0.8)`;
            ctx.lineWidth = 3;
            
            // Sourcil gauche
            ctx.beginPath();
            ctx.moveTo(
                character.x - character.size * 0.3,
                character.y - character.size * 1.1
            );
            ctx.lineTo(
                character.x - character.size * 0.1,
                character.y - character.size * (1.1 - eyebrowAngle)
            );
            ctx.stroke();
            
            // Sourcil droit
            ctx.beginPath();
            ctx.moveTo(
                character.x + character.size * 0.3,
                character.y - character.size * 1.1
            );
            ctx.lineTo(
                character.x + character.size * 0.1,
                character.y - character.size * (1.1 - eyebrowAngle)
            );
            ctx.stroke();
            
            // Bouche triste - plus inclinée vers le bas en fonction de la tristesse
            const mouthCurvature = character.face.mouthCurve;
            
            ctx.strokeStyle = `rgba(${character.face.face.r * 0.7}, ${character.face.face.g * 0.7}, ${character.face.face.b * 0.7}, 0.9)`;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.arc(
                character.x, 
                character.y - character.size * 0.7, 
                character.size * 0.2, 
                Math.PI * (0.5 - mouthCurvature), 
                Math.PI * (0.5 + mouthCurvature), 
                true
            );
            ctx.stroke();
            
            // Ajouter une lèvre inférieure quand le personnage est très triste
            if (phase >= 2) {
                ctx.beginPath();
                ctx.moveTo(
                    character.x - character.size * 0.1, 
                    character.y - character.size * 0.65
                );
                ctx.quadraticCurveTo(
                    character.x, 
                    character.y - character.size * (0.6 - phase * 0.02), 
                    character.x + character.size * 0.1, 
                    character.y - character.size * 0.65
                );
                ctx.stroke();
            }
            
            // Animation améliorée des larmes
            for (let i = 0; i < character.tears.length; i++) {
                const tear = character.tears[i];
                
                // Calculer la position avec wobble
                tear.wobble += tear.wobbleSpeed;
                const wobbleX = Math.sin(tear.wobble) * tear.wobbleAmount;
                
                // Dégradé pour donner un effet plus réaliste
                const tearGradient = ctx.createRadialGradient(
                    tear.x + wobbleX, tear.y, 0,
                    tear.x + wobbleX, tear.y, tear.size
                );
                tearGradient.addColorStop(0, `rgba(120, 200, 255, ${tear.alpha})`);
                tearGradient.addColorStop(0.8, `rgba(100, 180, 255, ${tear.alpha * 0.9})`);
                tearGradient.addColorStop(1, `rgba(100, 180, 255, 0)`);
                
                ctx.fillStyle = tearGradient;
                ctx.beginPath();
                
                // Forme de larme plus réaliste
                if (tear.speed > 3) {
                    // Larme en mouvement, forme de goutte
                    ctx.moveTo(tear.x + wobbleX, tear.y - tear.size);
                    ctx.quadraticCurveTo(
                        tear.x + wobbleX + tear.size, tear.y,
                        tear.x + wobbleX, tear.y + tear.size
                    );
                    ctx.quadraticCurveTo(
                        tear.x + wobbleX - tear.size, tear.y,
                        tear.x + wobbleX, tear.y - tear.size
                    );
                } else {
                    // Larme plus ronde quand elle est lente
                    ctx.arc(tear.x + wobbleX, tear.y, tear.size, 0, Math.PI * 2);
                }
                
                ctx.fill();
                
                // Ajouter un reflet à la larme
                ctx.fillStyle = `rgba(200, 230, 255, ${tear.alpha * 0.7})`;
                ctx.beginPath();
                ctx.arc(
                    tear.x + wobbleX - tear.size * 0.3, 
                    tear.y - tear.size * 0.3, 
                    tear.size * 0.3, 
                    0, Math.PI * 2
                );
                ctx.fill();
                
                // Mise à jour de la position et de la traînée
                tear.y += tear.speed;
                
                // Ajouter à la traînée
                if (tear.speed > 3 && Math.random() < 0.3) {
                    tear.trail.push({
                        x: tear.x + wobbleX,
                        y: tear.y,
                        size: tear.size * 0.7,
                        alpha: tear.alpha * 0.3
                    });
                }
                
                // Dessiner la traînée
                for (let j = 0; j < tear.trail.length; j++) {
                    const segment = tear.trail[j];
                    ctx.fillStyle = `rgba(120, 200, 255, ${segment.alpha})`;
                    ctx.beginPath();
                    ctx.arc(segment.x, segment.y, segment.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Faire disparaître la traînée
                    segment.size *= 0.9;
                    segment.alpha *= 0.8;
                    
                    if (segment.alpha < 0.05) {
                        tear.trail.splice(j, 1);
                        j--;
                    }
                }
                
                // Effet de larme qui tombe - étirement vertical et accélération
                if (tear.y > character.y - character.size * 0.5) {
                    tear.speed += 0.1;
                    tear.size *= 0.99;
                }
                
                // Effet de splash à l'atterrissage
                if (tear.y > character.y + character.size * 1.2 && !tear.splash) {
                    tear.splash = true;
                    tear.splashSize = tear.size * 2;
                    tear.splashOpacity = tear.alpha;
                    tear.splashGrowing = true;
                }
                
                // Dessiner le splash
                if (tear.splash) {
                    ctx.fillStyle = `rgba(120, 200, 255, ${tear.splashOpacity})`;
                    ctx.beginPath();
                    ctx.arc(
                        tear.x + wobbleX, 
                        character.y + character.size * 1.2, 
                        tear.splashSize, 
                        0, Math.PI * 2
                    );
                    ctx.fill();
                    
                    if (tear.splashGrowing) {
                        tear.splashSize += 0.3;
                        tear.splashOpacity *= 0.95;
                        
                        if (tear.splashSize > tear.size * 4) {
                            tear.splashGrowing = false;
                        }
                    } else {
                        tear.splashOpacity *= 0.9;
                    }
                }
                
                // Suppression des larmes qui sont tombées trop loin ou dont le splash est terminé
                if ((tear.y > character.y + character.size * 2 && tear.splashOpacity < 0.05) || tear.size < 1) {
                    character.tears.splice(i, 1);
                    i--;
                }
            }
        }
        
        function updatePhaseElements(phase, deltaTime, time) {
            try {
                // Mise à jour des cadres photo en fonction de la phase actuelle
                photoFrames.forEach((frame, index) => {
                    if (!frame || !frame.element) return;
                    
                    // Détermination de quand chaque cadre doit apparaître
                    let shouldBeVisible = false;
                    let shouldFade = false;
                    
                    switch (index) {
                        case 0: // Affichage en phase 0, fondu en phase 1
                            shouldBeVisible = phase >= 0;
                            shouldFade = phase >= 1;
                            break;
                        case 1: // Affichage en phase 0, fondu en phase 1.5
                            shouldBeVisible = phase >= 0;
                            shouldFade = phase >= 1.5;
                            break;
                        case 2: // Affichage en phase 1, fondu en phase 2.2
                            shouldBeVisible = phase >= 1;
                            shouldFade = phase >= 2.2;
                            break;
                        case 3: // Affichage en phase 1, fondu en phase 2.5
                            shouldBeVisible = phase >= 1;
                            shouldFade = phase >= 2.5;
                            break;
                        case 4: // Affichage en phase 1.5, fondu en phase 3
                            shouldBeVisible = phase >= 1.5;
                            shouldFade = phase >= 3;
                            break;
                    }
                    
                    // Gestion de la visibilité
                    if (shouldBeVisible && !frame.visible) {
                        frame.visible = true;
                        frame.element.style.transition = 'opacity 1.5s, transform 2s';
                        
                        setTimeout(() => {
                            if (frame.element) {
                                frame.element.style.opacity = '1';
                                frame.opacity = 1;
                            }
                        }, frame.delay);
                    }
                    
                    // Gestion du fondu
                    if (shouldFade && frame.opacity > 0) {
                        const fadeSpeed = 0.003 * (deltaTime / 16) * (1 + (phase - 1) * 0.5); // Plus rapide aux phases avancées
                        frame.opacity -= fadeSpeed;
                        
                        if (frame.opacity < 0) frame.opacity = 0;
                        frame.element.style.opacity = frame.opacity.toString();
                        
                        // Initialiser la désintégration lorsque l'opacité est suffisamment basse
                        if (frame.opacity < 0.7 && !frame.disintegrating) {
                            frame.disintegrating = true;
                        }
                    }
                    
                    // Animation flottante
                    if (frame.visible) {
                        frame.floatOffset += 0.01 * frame.floatSpeed * (deltaTime / 16);
                        frame.oscillationAngle += frame.oscillationSpeed * (deltaTime / 16);
                        
                        const floatY = Math.sin(frame.floatOffset) * 10;
                        const oscillationX = Math.cos(frame.oscillationAngle) * frame.oscillationAmplitude;
                        const oscillationY = Math.sin(frame.oscillationAngle) * frame.oscillationAmplitude;
                        
                        frame.element.style.transform = `rotate(${frame.rotation}deg) translate(${oscillationX}px, ${floatY + oscillationY}px)`;
                    }
                });
                
                // Mise à jour des éléments de fond en fonction de la phase
                switch (phase) {
                    case 1:
                        // Ajouter plus de flaques au sol
                        if (Math.random() < 0.01 && puddles.length < 12) {
                            puddles.push(createPuddle(canvas));
                        }
                        break;
                    case 2:
                        // Ajouter plus de flaques et réflexions
                        if (Math.random() < 0.02 && puddles.length < 15) {
                            puddles.push(createPuddle(canvas));
                        }
                        if (Math.random() < 0.01 && reflections.length < 15) {
                            reflections.push(createReflection(
                                Math.random() * canvas.width,
                                Math.random() * canvas.height * 0.7 + canvas.height * 0.3,
                                20 + Math.random() * 100,
                                5 + Math.random() * 20,
                                Math.random() > 0.4 ? 'light' : 'color'
                            ));
                        }
                        break;
                    case 3:
                        // Environnement très pluvieux
                        if (Math.random() < 0.05 && puddles.length < 20) {
                            puddles.push(createPuddle(canvas));
                        }
                        if (Math.random() < 0.02 && reflections.length < 20) {
                            reflections.push(createReflection(
                                Math.random() * canvas.width,
                                Math.random() * canvas.height * 0.7 + canvas.height * 0.3,
                                20 + Math.random() * 100,
                                5 + Math.random() * 20,
                                Math.random() > 0.3 ? 'light' : 'color'
                            ));
                        }
                        // Fusionner certaines flaques pour créer des flaques plus grandes
                        if (Math.random() < 0.01 && puddles.length > 2) {
                            const idx1 = Math.floor(Math.random() * puddles.length);
                            let idx2 = Math.floor(Math.random() * puddles.length);
                            while (idx2 === idx1) idx2 = Math.floor(Math.random() * puddles.length);
                            
                            const p1 = puddles[idx1];
                            const p2 = puddles[idx2];
                            
                            // Calculer la distance entre les flaques
                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            // Si elles sont assez proches, les fusionner
                            if (dist < p1.radiusX + p2.radiusX) {
                                // Créer une nouvelle flaque plus grande
                                const mergedPuddle = {
                                    x: (p1.x + p2.x) / 2,
                                    y: (p1.y + p2.y) / 2,
                                    radiusX: Math.max(p1.radiusX, p2.radiusX) * 1.5,
                                    radiusY: Math.max(p1.radiusY, p2.radiusY) * 1.5,
                                    alpha: Math.max(p1.alpha, p2.alpha),
                                    ripples: [...p1.ripples, ...p2.ripples],
                                    reflectionOpacity: Math.max(p1.reflectionOpacity, p2.reflectionOpacity),
                                    pulseTime: p1.pulseTime,
                                    pulseSpeed: (p1.pulseSpeed + p2.pulseSpeed) / 2,
                                    pulseAmount: Math.max(p1.pulseAmount, p2.pulseAmount)
                                };
                                
                                // Remplacer les deux flaques par la nouvelle
                                puddles.splice(Math.max(idx1, idx2), 1);
                                puddles.splice(Math.min(idx1, idx2), 1);
                                puddles.push(mergedPuddle);
                            }
                        }
                        break;
                }
            } catch (error) {
                console.error("Erreur dans updatePhaseElements de tristesse:", error);
            }
        }
        
        animate(0);
        updateLoadingProgress();
    } catch (error) {
        console.error("Erreur globale dans initTristesseCanvas:", error);
        updateLoadingProgress(); // Continuer malgré l'erreur
    }
}

/**
 * ======================================
 * ANIMATION DE COLÈRE EXTRAORDINAIRE
 * ======================================
 * Cette animation utilise THREE.js pour créer une expérience visuelle intense
 * qui évolue en quatre phases, chacune représentant un stade croissant de colère.
 */

// Variables principales pour l'animation
let angerScene, angerCamera, angerRenderer;
let angerCharacter, angerEnvironment;
let fireParticles, smokeParticles, emberParticles, shockwaveParticles;
let angerLights = [];
let destructibleObjects = [];
let postProcessing = {};
let audioReactiveElements = [];
let timeElapsed = 0;
let pulsatingElements = [];
let currentIntensity = 0;

// Système de particules et effets
let particleSystems = {};
let effectComposer;

// Paramètres de configuration
const CONFIG = {
    colors: {
        baseRed: 0xff3d00,
        deepRed: 0xc30000,
        brightRed: 0xff5252,
        orangeRed: 0xff7043,
        yellowOrange: 0xffab40,
        darkPurple: 0x4a148c,
        whiteHot: 0xffffff
    },
    phases: [
        { name: "irritation", duration: 7000, intensity: 0.25 },
        { name: "frustration", duration: 7000, intensity: 0.5 },
        { name: "rage", duration: 7000, intensity: 0.8 },
        { name: "fury", duration: 7000, intensity: 1.0 }
    ],
    particles: {
        fire: { count: 2000, size: 3.0, speed: 0.8 },
        embers: { count: 500, size: 2.0, speed: 1.2 },
        smoke: { count: 300, size: 5.0, speed: 0.3 },
        shockwave: { count: 1000, size: 2.0, speed: 2.0 }
    },
    camera: {
        fov: 75,
        distance: 5,
        minDistance: 3,
        maxDistance: 8,
        shakeIntensity: 0.1
    },
    destruction: {
        objectCount: 12,
        minSize: 30,
        maxSize: 120,
        breakableThreshold: 0.4
    }
};

// Utilitaires pour effets dynamiques
const AngerUtils = {
    randomInRange: (min, max) => Math.random() * (max - min) + min,
    lerp: (start, end, t) => start * (1 - t) + end * t,
    clamp: (value, min, max) => Math.min(Math.max(value, min), max),
    easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
    colorToHex: (r, g, b) => (r << 16) | (g << 8) | b,
    hexToRgb: hex => {
        return {
            r: (hex >> 16) & 255,
            g: (hex >> 8) & 255,
            b: hex & 255
        };
    },
    lerpColor: (color1, color2, t) => {
        const rgb1 = AngerUtils.hexToRgb(color1);
        const rgb2 = AngerUtils.hexToRgb(color2);
        
        return AngerUtils.colorToHex(
            Math.round(AngerUtils.lerp(rgb1.r, rgb2.r, t)),
            Math.round(AngerUtils.lerp(rgb1.g, rgb2.g, t)),
            Math.round(AngerUtils.lerp(rgb1.b, rgb2.b, t))
        );
    },
    createExplosion: (position, size, intensity) => {
        // Crée une explosion de particules au point spécifié
        const particleCount = Math.floor(200 * intensity);
        const explosionParticles = [];
        
        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * size;
            const speed = 0.05 + Math.random() * 0.15 * intensity;
            
            explosionParticles.push({
                position: new THREE.Vector3(
                    position.x + Math.cos(angle) * radius * 0.2,
                    position.y + Math.random() * radius * 0.2,
                    position.z + Math.sin(angle) * radius * 0.2
                ),
                velocity: new THREE.Vector3(
                    Math.cos(angle) * speed,
                    (Math.random() - 0.3) * speed * 2,
                    Math.sin(angle) * speed
                ),
                size: 3 + Math.random() * 7 * intensity,
                life: 1.0,
                decay: 0.01 + Math.random() * 0.03,
                color: new THREE.Color(
                    AngerUtils.lerpColor(
                        CONFIG.colors.orangeRed,
                        CONFIG.colors.whiteHot,
                        Math.random() * 0.5 + 0.5
                    )
                )
            });
        }
        
        return {
            particles: explosionParticles,
            update: (deltaTime) => {
                for (let i = 0; i < explosionParticles.length; i++) {
                    const p = explosionParticles[i];
                    p.life -= p.decay * deltaTime;
                    if (p.life <= 0) {
                        // Réinitialiser la particule
                        p.life = 0;
                    } else {
                        // Mettre à jour la position
                        p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
                        // Ralentir la particule
                        p.velocity.multiplyScalar(0.98);
                        // Ajouter de la gravité
                        p.velocity.y -= 0.001 * deltaTime;
                    }
                }
                
                // Supprimer l'explosion si toutes les particules sont mortes
                return explosionParticles.some(p => p.life > 0);
            },
            draw: (scene) => {
                // Créer des meshes pour chaque particule toujours en vie
                for (let i = 0; i < explosionParticles.length; i++) {
                    const p = explosionParticles[i];
                    if (p.life <= 0) continue;
                    
                    const geometry = new THREE.SphereGeometry(p.size * p.life, 8, 8);
                    const material = new THREE.MeshBasicMaterial({
                        color: p.color,
                        transparent: true,
                        opacity: p.life
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.copy(p.position);
                    scene.add(mesh);
                    
                    // Ajouter à la liste des meshes à supprimer à la prochaine frame
                    particleSystems.explosionMeshes.push({
                        mesh: mesh,
                        lifetime: p.life
                    });
                }
            }
        };
    }
};

// Variables pour le suivi des explosions et démolitions
let activeExplosions = [];
let explosionParticles = [];
particleSystems.explosionMeshes = [];

// Système de post-traitement et effets visuels
class PostProcessor {
    constructor(renderer, scene, camera) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;
        
        this.composer = null;
        this.effects = {};
        
        this.initialize();
    }
    
    initialize() {
        const renderPass = new THREE.RenderPass(this.scene, this.camera);
        
        // Définir l'effet de vignetage qui s'intensifie avec la colère
        this.effects.vignette = new THREE.ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                offset: { value: 0.8 },
                darkness: { value: 1.0 },
                intensity: { value: 0.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float offset;
                uniform float darkness;
                uniform float intensity;
                varying vec2 vUv;
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    vec2 uv = (vUv - 0.5) * 2.0;
                    float vignetteAmount = 1.0 - dot(uv, uv) * intensity;
                    vignetteAmount = pow(vignetteAmount, offset) * darkness;
                    color.rgb *= vignetteAmount;
                    gl_FragColor = color;
                }
            `
        });
        
        // Effet de déformation de chaleur qui s'intensifie
        this.effects.heatDistortion = new THREE.ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                amount: { value: 0.02 },
                time: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float amount;
                uniform float time;
                varying vec2 vUv;
                
                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                }
                
                void main() {
                    vec2 uv = vUv;
                    float noise = random(uv + time * 0.1) * 2.0 - 1.0;
                    float distortionX = sin(uv.y * 10.0 + time * 2.0) * amount;
                    float distortionY = cos(uv.x * 10.0 + time * 2.0) * amount;
                    uv.x += distortionX;
                    uv.y += distortionY;
                    gl_FragColor = texture2D(tDiffuse, uv);
                }
            `
        });
        
        // Effet de saturation qui augmente avec la colère
        this.effects.saturation = new THREE.ShaderPass({
            uniforms: {
                tDiffuse: { value: null },
                saturation: { value: 1.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float saturation;
                varying vec2 vUv;
                
                void main() {
                    vec4 color = texture2D(tDiffuse, vUv);
                    float intensity = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                    vec3 grayscale = vec3(intensity);
                    color.rgb = mix(grayscale, color.rgb, saturation);
                    gl_FragColor = color;
                }
            `
        });
        
        // Effet de lueur pour les objets en feu
        this.effects.glow = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.5,  // Intensité
            0.8,  // Rayon
            0.35  // Seuil
        );
        
        // Assembler le pipeline de rendu
        this.composer = new THREE.EffectComposer(this.renderer);
        this.composer.addPass(renderPass);
        this.composer.addPass(this.effects.heatDistortion);
        this.composer.addPass(this.effects.saturation);
        this.composer.addPass(this.effects.glow);
        this.composer.addPass(this.effects.vignette);
    }
    
    update(deltaTime, intensity) {
        // Mettre à jour les effets en fonction de l'intensité de la colère
        this.effects.vignette.uniforms.offset.value = AngerUtils.lerp(0.8, 1.8, intensity);
        this.effects.vignette.uniforms.darkness.value = AngerUtils.lerp(1.0, 1.5, intensity);
        this.effects.vignette.uniforms.intensity.value = AngerUtils.lerp(0.2, 0.9, intensity);
        
        this.effects.heatDistortion.uniforms.amount.value = AngerUtils.lerp(0.0, 0.05, intensity);
        this.effects.heatDistortion.uniforms.time.value += deltaTime;
        
        this.effects.saturation.uniforms.saturation.value = AngerUtils.lerp(1.0, 1.5, intensity);
        
        this.effects.glow.strength = AngerUtils.lerp(0.3, 1.5, intensity);
        this.effects.glow.radius = AngerUtils.lerp(0.5, 1.0, intensity);
        this.effects.glow.threshold = AngerUtils.lerp(0.4, 0.2, intensity);
    }
    
    render() {
        this.composer.render();
    }
    
    resize(width, height) {
        this.composer.setSize(width, height);
    }
}

// Classe pour gérer la création, l'animation et la destruction des objets
class DestructibleObject {
    constructor(scene, position, size, type = 'cube', material = null) {
        this.scene = scene;
        this.position = position.clone();
        this.size = size;
        this.type = type;
        
        this.broken = false;
        this.pieces = [];
        this.animationState = {
            hover: 0,
            rotation: Math.random() * Math.PI * 2,
            rotationSpeed: (Math.random() - 0.5) * 0.01,
            wobblePhase: Math.random() * Math.PI * 2,
            wobbleFrequency: 0.5 + Math.random() * 1.5,
            wobbleAmplitude: 0.05 + Math.random() * 0.1
        };
        
        // Matériau par défaut si aucun n'est fourni
        if (!material) {
            // Créer un matériau qui change avec l'intensité de la colère
            this.material = new THREE.MeshStandardMaterial({
                color: 0xe0e0e0,
                roughness: 0.4,
                metalness: 0.6,
                emissive: 0x000000
            });
        } else {
            this.material = material;
        }
        
        this.createObject();
    }
    
    createObject() {
        let geometry;
        
        // Créer différentes formes d'objets pour la variété
        switch (this.type) {
            case 'cube':
                geometry = new THREE.BoxGeometry(this.size, this.size, this.size);
                break;
            case 'sphere':
                geometry = new THREE.SphereGeometry(this.size / 2, 32, 32);
                break;
            case 'cylinder':
                geometry = new THREE.CylinderGeometry(this.size / 2, this.size / 2, this.size, 32);
                break;
            case 'torus':
                geometry = new THREE.TorusGeometry(this.size / 2, this.size / 6, 16, 32);
                break;
            case 'pyramid':
                geometry = new THREE.ConeGeometry(this.size / 2, this.size, 4);
                break;
            default:
                geometry = new THREE.BoxGeometry(this.size, this.size, this.size);
        }
        
        this.mesh = new THREE.Mesh(geometry, this.material);
        this.mesh.position.copy(this.position);
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        
        // Ajouter une propriété pour référencer l'objet destructible
        this.mesh.userData.destructible = this;
        
        this.scene.add(this.mesh);
    }
    
    update(deltaTime, intensity) {
        if (!this.broken) {
            // Animation de flottement et rotation
            this.animationState.hover += 0.01 * deltaTime;
            this.animationState.rotation += this.animationState.rotationSpeed * deltaTime;
            this.animationState.wobblePhase += this.animationState.wobbleFrequency * 0.01 * deltaTime;
            
            const hoverHeight = Math.sin(this.animationState.hover) * 0.2;
            const wobble = Math.sin(this.animationState.wobblePhase) * this.animationState.wobbleAmplitude;
            
            // Appliquer l'animation
            this.mesh.position.y = this.position.y + hoverHeight;
            this.mesh.rotation.x = this.animationState.rotation * 0.5 + wobble;
            this.mesh.rotation.y = this.animationState.rotation;
            this.mesh.rotation.z = this.animationState.rotation * 0.3 - wobble;
            
            // Faire rougeoyer les objets à mesure que la colère augmente
            const emissiveIntensity = Math.pow(intensity, 2) * 0.5;
            this.material.emissive.setHex(
                AngerUtils.lerpColor(0x000000, CONFIG.colors.brightRed, emissiveIntensity)
            );
            
            // Faire vibrer les objets plus intensément avec la colère
            if (intensity > 0.5) {
                const vibrateIntensity = (intensity - 0.5) * 2 * 0.05;
                this.mesh.position.x += (Math.random() - 0.5) * vibrateIntensity * this.size;
                this.mesh.position.z += (Math.random() - 0.5) * vibrateIntensity * this.size;
            }
        } else {
            // Mettre à jour les fragments si l'objet est cassé
            for (let i = 0; i < this.pieces.length; i++) {
                const piece = this.pieces[i];
                
                // Appliquer la gravité et le mouvement
                piece.velocity.y -= 0.01 * deltaTime;
                piece.position.add(piece.velocity.clone().multiplyScalar(deltaTime));
                
                // Rotation des fragments
                piece.rotation.x += piece.rotationSpeed.x * deltaTime;
                piece.rotation.y += piece.rotationSpeed.y * deltaTime;
                piece.rotation.z += piece.rotationSpeed.z * deltaTime;
                
                // Ralentissement
                piece.velocity.multiplyScalar(0.98);
                
                // Vérifier la collision avec le sol
                if (piece.position.y < -10 && piece.velocity.y < 0) {
                    // Rebond avec perte d'énergie
                    piece.velocity.y *= -0.5;
                    // Réduire également la vitesse horizontale (friction)
                    piece.velocity.x *= 0.7;
                    piece.velocity.z *= 0.7;
                    
                    // Arrêter de rebondir si la vitesse est trop faible
                    if (Math.abs(piece.velocity.y) < 0.02) {
                        piece.velocity.y = 0;
                    }
                }
            }
        }
    }
    
    break(intensity = 1.0) {
        if (this.broken) return;
        
        this.broken = true;
        
        // Nombre de fragments basé sur l'intensité et la taille
        const fragmentCount = Math.floor(6 + intensity * 10 + this.size / 20);
        
        // Supprimer l'objet original
        this.scene.remove(this.mesh);
        
        // Créer la géométrie pour chaque fragment
        for (let i = 0; i < fragmentCount; i++) {
            // Créer une géométrie de fragment plus intéressante en utilisant différentes formes
            let geometry;
            const fragmentSize = this.size * (0.2 + Math.random() * 0.3);
            
            switch (Math.floor(Math.random() * 5)) {
                case 0:
                    geometry = new THREE.BoxGeometry(fragmentSize, fragmentSize, fragmentSize);
                    break;
                case 1:
                    geometry = new THREE.TetrahedronGeometry(fragmentSize / 2);
                    break;
                case 2:
                    geometry = new THREE.OctahedronGeometry(fragmentSize / 2);
                    break;
                case 3:
                    geometry = new THREE.IcosahedronGeometry(fragmentSize / 2, 0);
                    break;
                case 4:
                    geometry = new THREE.DodecahedronGeometry(fragmentSize / 2, 0);
                    break;
            }
            
            // Matériau du fragment avec une teinte de la colère
            const material = this.material.clone();
            
            // Créer le mesh du fragment
            const fragment = new THREE.Mesh(geometry, material);
            
            // Position initiale près du centre de l'objet original
            const randomOffset = new THREE.Vector3(
                (Math.random() - 0.5) * this.size * 0.5,
                (Math.random() - 0.5) * this.size * 0.5,
                (Math.random() - 0.5) * this.size * 0.5
            );
            fragment.position.copy(this.position).add(randomOffset);
            
            // Ajouter une vitesse et une rotation aléatoires
            const angle = Math.random() * Math.PI * 2;
            const upwardBias = 0.5 + Math.random() * 0.5; // Ajouter une composante vers le haut
            
            const velocity = new THREE.Vector3(
                Math.cos(angle) * (0.05 + Math.random() * 0.10 * intensity),
                upwardBias * (0.05 + Math.random() * 0.15 * intensity),
                Math.sin(angle) * (0.05 + Math.random() * 0.10 * intensity)
            );
            
            const rotationSpeed = new THREE.Vector3(
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1
            );
            
            // Stocker les propriétés nécessaires à l'animation
            fragment.velocity = velocity;
            fragment.rotationSpeed = rotationSpeed;
            
            // Ajouteur des ombres
            fragment.castShadow = true;
            fragment.receiveShadow = true;
            
            // Ajouter le fragment à la scène et à la liste
            this.scene.add(fragment);
            this.pieces.push(fragment);
        }
        
        // Créer un effet d'explosion au point de rupture
        const explosionEffect = AngerUtils.createExplosion(
            this.position,
            this.size,
            intensity
        );
        activeExplosions.push(explosionEffect);
        
        return this.pieces;
    }
    
    clean() {
        // Nettoyer les fragments
        for (const piece of this.pieces) {
            if (piece.geometry) piece.geometry.dispose();
            if (piece.material) piece.material.dispose();
            this.scene.remove(piece);
        }
        
        // Nettoyer le mesh principal s'il existe encore
        if (!this.broken && this.mesh) {
            if (this.mesh.geometry) this.mesh.geometry.dispose();
            if (this.mesh.material) this.mesh.material.dispose();
            this.scene.remove(this.mesh);
        }
        
        this.pieces = [];
    }
}

// Classe pour le personnage principal de la colère
class AngerCharacter {
    constructor(scene, position = new THREE.Vector3(0, 0, 0)) {
        this.scene = scene;
        this.position = position.clone();
        this.initialScale = 1.0;
        
        // Propriétés d'animation
        this.animationState = {
            breathCycle: 0,
            breathSpeed: 0.005,
            pulsePhase: 0,
            pulseSpeed: 0.01,
            shakeIntensity: 0,
            eyeBrowRaise: 0,
            mouthOpenness: 0.2,
            teethVisibility: 0,
            currentColor: CONFIG.colors.baseRed,
            targetColor: CONFIG.colors.baseRed,
            colorTransitionSpeed: 0.02
        };
        
        // Groupe pour tout le personnage
        this.group = new THREE.Group();
        this.group.position.copy(this.position);
        this.scene.add(this.group);
        
        // Créer les différentes parties du personnage
        this.createBody();
        this.createFace();
        this.createEffects();
    }
    
    createBody() {
        // Tête/Corps principal - forme expressive qui évoluera avec la colère
        const headGeometry = new THREE.SphereGeometry(1, 32, 32);
        this.bodyMaterial = new THREE.MeshStandardMaterial({
            color: this.animationState.currentColor,
            roughness: 0.7,
            metalness: 0.3,
            emissive: 0x000000,
            emissiveIntensity: 0
        });
        
        this.body = new THREE.Mesh(headGeometry, this.bodyMaterial);
        this.body.castShadow = true;
        this.body.receiveShadow = true;
        this.group.add(this.body);
        
        // Ajouter une aura de chaleur autour du corps (visible dans les phases avancées)
        const auraGeometry = new THREE.SphereGeometry(1.2, 32, 32);
        this.auraMaterial = new THREE.MeshBasicMaterial({
            color: CONFIG.colors.brightRed,
            transparent: true,
            opacity: 0,
            side: THREE.BackSide
        });
        
        this.aura = new THREE.Mesh(auraGeometry, this.auraMaterial);
        this.group.add(this.aura);
        
        // Système d'émission de particules
        this.emissionPoints = [];
        
        // Ajouter des points d'émission de particules autour du corps
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            this.emissionPoints.push({
                position: new THREE.Vector3(
                    Math.cos(angle) * 1.2,
                    0.5 + Math.random() * 0.5,
                    Math.sin(angle) * 1.2
                ),
                intensity: 0,
                pulseFactor: 0.5 + Math.random() * 0.5,
                phase: Math.random() * Math.PI * 2
            });
        }
    }
    
    createFace() {
        // Yeux - ils deviendront plus intenses et lumineux avec la colère
        const eyeGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        
        // Matériau blanc pour les yeux
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        // Œil gauche
        this.leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        this.leftEye.position.set(-0.4, 0.3, 0.85);
        this.body.add(this.leftEye);
        
        // Œil droit
        this.rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        this.rightEye.position.set(0.4, 0.3, 0.85);
        this.body.add(this.rightEye);
        
        // Pupilles - elles se contracteront avec la colère
        const pupilGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        // Pupille gauche
        this.leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        this.leftPupil.position.set(0, 0, 0.1);
        this.leftEye.add(this.leftPupil);
        
        // Pupille droite
        this.rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        this.rightPupil.position.set(0, 0, 0.1);
        this.rightEye.add(this.rightPupil);
        
        // Sourcils - ils se déformeront et se plieront davantage avec la colère
        const eyebrowGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.1);
        const eyebrowMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        
        // Sourcil gauche
        this.leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
        this.leftEyebrow.position.set(-0.4, 0.5, 0.9);
        this.leftEyebrow.rotation.z = -0.3;
        this.body.add(this.leftEyebrow);
        
        // Sourcil droit
        this.rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
        this.rightEyebrow.position.set(0.4, 0.5, 0.9);
        this.rightEyebrow.rotation.z = 0.3;
        this.body.add(this.rightEyebrow);
        
        // Bouche - elle s'ouvrira davantage avec la colère
        const mouthGeometry = new THREE.BoxGeometry(0.8, 0.2, 0.1);
        const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        this.mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
        this.mouth.position.set(0, -0.3, 0.9);
        this.body.add(this.mouth);
        
        // Dents - elles deviendront visibles dans les phases avancées
        const teethGeometry = new THREE.BoxGeometry(0.7, 0.1, 0.05);
        const teethMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        this.teeth = new THREE.Mesh(teethGeometry, teethMaterial);
        this.teeth.position.set(0, -0.1, 0);
        this.teeth.visible = false;
        this.mouth.add(this.teeth);
    }
    
    createEffects() {
        // Créer les systèmes de particules pour le feu, la fumée, etc.
        this.fireParticles = this.createParticleSystem(
            300,
            new THREE.Color(CONFIG.colors.orangeRed),
            0.1,
            2.0
        );
        this.group.add(this.fireParticles);
        
        // Particules d'étincelles
        this.emberParticles = this.createParticleSystem(
            150,
            new THREE.Color(CONFIG.colors.yellowOrange),
            0.05,
            1.5
        );
        this.group.add(this.emberParticles);
        
        // Particules de fumée
        this.smokeParticles = this.createParticleSystem(
            100,
            new THREE.Color(0x444444),
            0.15,
            1.0
        );
        this.smokeParticles.position.y = 1.5;
        this.group.add(this.smokeParticles);
    }
    
    createParticleSystem(count, color, size, speed) {
        // Crée un système de particules générique
        const particleGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const velocities = []; // Stocké séparément car non utilisé par le shader
        const colors = new Float32Array(count * 3);
        const sizes = new Float32Array(count);
        const lifetimes = new Float32Array(count);
        
        for (let i = 0; i < count; i++) {
            // Initialiser les positions autour du personnage
            const angle = Math.random() * Math.PI * 2;
            const radius = 1.0 + Math.random() * 0.5;
            positions[i * 3] = Math.cos(angle) * radius;
            positions[i * 3 + 1] = Math.random() * 2 - 1; // y
            positions[i * 3 + 2] = Math.sin(angle) * radius;
            
            // Vélocité vers le haut, légèrement aléatoire
            velocities.push(
                new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01 * speed,
                    0.01 * speed + Math.random() * 0.01 * speed,
                    (Math.random() - 0.5) * 0.01 * speed
                )
            );
            
            // Couleur légèrement variée
            colors[i * 3] = color.r + Math.random() * 0.1;
            colors[i * 3 + 1] = color.g + Math.random() * 0.1;
            colors[i * 3 + 2] = color.b + Math.random() * 0.1;
            
            // Tailles aléatoires
            sizes[i] = (0.5 + Math.random() * 0.5) * size;
            
            // Durée de vie aléatoire
            lifetimes[i] = Math.random();
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        particleGeometry.setAttribute('lifetime', new THREE.BufferAttribute(lifetimes, 1));
        
        // Matériau pour les particules
        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                pointTexture: { value: null }, // Texture optionnelle
                time: { value: 0.0 },
                opacity: { value: 0.0 }, // Démarre invisible
                globalSize: { value: 1.0 }
            },
            vertexShader: `
                attribute float size;
                attribute vec3 color;
                attribute float lifetime;
                uniform float time;
                uniform float globalSize;
                varying vec3 vColor;
                varying float vLifetime;
                
                void main() {
                    vColor = color;
                    vLifetime = lifetime;
                    
                    // Calcul de la taille et de la position
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * globalSize * (300.0 / -mvPosition.z);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D pointTexture;
                uniform float opacity;
                varying vec3 vColor;
                varying float vLifetime;
                
                void main() {
                    float finalOpacity = opacity * vLifetime;
                    
                    // Créer une particule circulaire avec un dégradé
                    float r = length(gl_PointCoord - vec2(0.5, 0.5)) * 2.0;
                    float alpha = max(0.0, 1.0 - r) * finalOpacity;
                    
                    gl_FragColor = vec4(vColor, alpha);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });
        
        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        particleSystem.userData.velocities = velocities;
        
        return particleSystem;
    }
    
    update(deltaTime, intensity) {
        // Mettre à jour les cycles d'animation
        this.animationState.breathCycle += this.animationState.breathSpeed * deltaTime;
        this.animationState.pulsePhase += this.animationState.pulseSpeed * deltaTime * (1 + intensity * 2);
        
        // Mettre à jour la respiration et la pulsation
        const breathEffect = Math.sin(this.animationState.breathCycle) * 0.05;
        const pulseEffect = Math.sin(this.animationState.pulsePhase) * 0.1 * intensity;
        
        // Appliquer au corps
        this.body.scale.set(
            this.initialScale * (1 + breathEffect + pulseEffect),
            this.initialScale * (1 - breathEffect * 0.5 + pulseEffect),
            this.initialScale * (1 + breathEffect + pulseEffect)
        );
        
        // Transition de couleur du corps
        // Déterminer la couleur cible en fonction de l'intensité
        if (intensity < 0.25) {
            this.animationState.targetColor = CONFIG.colors.baseRed;
        } else if (intensity < 0.5) {
            this.animationState.targetColor = CONFIG.colors.brightRed;
        } else if (intensity < 0.75) {
            this.animationState.targetColor = CONFIG.colors.orangeRed;
        } else {
            this.animationState.targetColor = CONFIG.colors.yellowOrange;
        }
        
        // Transition douce vers la couleur cible
        this.animationState.currentColor = AngerUtils.lerpColor(
            this.animationState.currentColor,
            this.animationState.targetColor,
            this.animationState.colorTransitionSpeed * deltaTime
        );
        
        // Appliquer la couleur au matériau
        this.bodyMaterial.color.setHex(this.animationState.currentColor);
        
        // Émissivité qui augmente avec l'intensité
        const emissiveIntensity = Math.pow(intensity, 2);
        this.bodyMaterial.emissive.setHex(CONFIG.colors.brightRed);
        this.bodyMaterial.emissiveIntensity = emissiveIntensity;
        
        // Aura qui devient visible à haute intensité
        this.auraMaterial.opacity = Math.max(0, intensity - 0.5) * 0.5;
        this.aura.scale.set(
            1 + intensity * 0.3 + pulseEffect,
            1 + intensity * 0.3 + pulseEffect,
            1 + intensity * 0.3 + pulseEffect
        );
        
        // Mise à jour des expressions du visage
        // Sourcils qui se froncent davantage
        const eyebrowAngle = 0.3 + intensity * 0.3;
        this.leftEyebrow.rotation.z = -eyebrowAngle;
        this.rightEyebrow.rotation.z = eyebrowAngle;
        
        // Les sourcils qui montent avec la colère
        this.animationState.eyeBrowRaise = AngerUtils.lerp(
            this.animationState.eyeBrowRaise,
            intensity * 0.2,
            0.1 * deltaTime
        );
        
        this.leftEyebrow.position.y = 0.5 + this.animationState.eyeBrowRaise;
        this.rightEyebrow.position.y = 0.5 + this.animationState.eyeBrowRaise;
        
        // La bouche s'ouvre progressivement avec la colère
        this.animationState.mouthOpenness = AngerUtils.lerp(
            this.animationState.mouthOpenness,
            0.2 + intensity * 0.5,
            0.05 * deltaTime
        );
        
        this.mouth.scale.set(1 + intensity * 0.4, this.animationState.mouthOpenness, 1);
        
        // Les dents deviennent visibles à haute intensité
        if (intensity > 0.6 && this.animationState.mouthOpenness > 0.4) {
            this.teeth.visible = true;
        } else {
            this.teeth.visible = false;
        }
        
        // Pupilles qui se contractent avec la colère
        const pupilSize = 1 - intensity * 0.6;
        this.leftPupil.scale.set(pupilSize, pupilSize, 1);
        this.rightPupil.scale.set(pupilSize, pupilSize, 1);
        
        // Vibration du personnage qui augmente avec l'intensité
        this.animationState.shakeIntensity = intensity * 0.05;
        if (this.animationState.shakeIntensity > 0) {
            this.group.position.set(
                this.position.x + (Math.random() - 0.5) * this.animationState.shakeIntensity,
                this.position.y + (Math.random() - 0.5) * this.animationState.shakeIntensity,
                this.position.z + (Math.random() - 0.5) * this.animationState.shakeIntensity
            );
        }
        
        // Mise à jour des systèmes de particules
        this.updateParticles(this.fireParticles, deltaTime, intensity, {
            speed: 1.2,
            speedVariation: 0.5,
            sizeMultiplier: 2.0,
            opacity: Math.min(1, intensity * 2)
        });
        
        this.updateParticles(this.emberParticles, deltaTime, intensity, {
            speed: 1.5,
            speedVariation: 0.8,
            sizeMultiplier: 1.5,
            opacity: Math.max(0, intensity - 0.3) * 1.5
        });
        
        this.updateParticles(this.smokeParticles, deltaTime, intensity, {
            speed: 0.8,
            speedVariation: 0.2,
            sizeMultiplier: 3.0,
            opacity: Math.max(0, intensity - 0.5)
        });
        
        // Mise à jour des points d'émission (pour les effets comme la vapeur sortant des oreilles)
        for (const point of this.emissionPoints) {
            point.phase += 0.02 * deltaTime;
            point.intensity = Math.max(0, intensity - 0.4) * point.pulseFactor;
            
            // Émettre des particules si suffisamment intense
            if (point.intensity > 0.1 && Math.random() < point.intensity * 0.2) {
                this.emitParticleFromPoint(point);
            }
        }
    }
    
    updateParticles(particleSystem, deltaTime, intensity, options) {
        if (!particleSystem || !particleSystem.geometry || !particleSystem.material) return;
        
        const positions = particleSystem.geometry.attributes.position.array;
        const velocities = particleSystem.userData.velocities;
        const lifetimes = particleSystem.geometry.attributes.lifetime.array;
        
        // Augmenter l'intensité générale
        particleSystem.material.uniforms.opacity.value = AngerUtils.lerp(
            particleSystem.material.uniforms.opacity.value,
            options.opacity,
            0.1 * deltaTime
        );
        
        particleSystem.material.uniforms.globalSize.value = AngerUtils.lerp(
            particleSystem.material.uniforms.globalSize.value,
            options.sizeMultiplier * (1 + intensity),
            0.1 * deltaTime
        );
        
        particleSystem.material.uniforms.time.value += 0.01 * deltaTime;
        
        // Mettre à jour chaque particule
        for (let i = 0; i < positions.length / 3; i++) {
            // Mise à jour de la position basée sur la vélocité
            positions[i * 3] += velocities[i].x * deltaTime * options.speed 
                * (1 + Math.random() * options.speedVariation);
            positions[i * 3 + 1] += velocities[i].y * deltaTime * options.speed 
                * (1 + Math.random() * options.speedVariation);
            positions[i * 3 + 2] += velocities[i].z * deltaTime * options.speed 
                * (1 + Math.random() * options.speedVariation);
            
            // Réduire la durée de vie
            lifetimes[i] -= 0.01 * deltaTime;
            
            // Réinitialiser la particule si sa durée de vie est écoulée
            if (lifetimes[i] <= 0) {
                this.resetParticle(i, positions, velocities, lifetimes, options.speed);
            }
        }
        
        // Marquer les buffers pour mise à jour
        particleSystem.geometry.attributes.position.needsUpdate = true;
        particleSystem.geometry.attributes.lifetime.needsUpdate = true;
    }
    
    resetParticle(index, positions, velocities, lifetimes, speed) {
        // Choisir un point d'émission aléatoire
        let emissionPoint;
        if (this.emissionPoints.length > 0 && Math.random() < 0.5) {
            emissionPoint = this.emissionPoints[Math.floor(Math.random() * this.emissionPoints.length)];
            
            positions[index * 3] = emissionPoint.position.x;
            positions[index * 3 + 1] = emissionPoint.position.y;
            positions[index * 3 + 2] = emissionPoint.position.z;
        } else {
            // Ou émerger de n'importe où sur la surface
            const angle = Math.random() * Math.PI * 2;
            const radius = 1.0 + Math.random() * 0.1;
            
            positions[index * 3] = Math.cos(angle) * radius;
            positions[index * 3 + 1] = Math.random() * 2 - 1; // y
            positions[index * 3 + 2] = Math.sin(angle) * radius;
        }
        
        // Vitesse dirigée principalement vers le haut
        velocities[index].set(
            (Math.random() - 0.5) * 0.01 * speed,
            0.01 * speed + Math.random() * 0.01 * speed,
            (Math.random() - 0.5) * 0.01 * speed
        );
        
        // Réinitialiser la durée de vie
        lifetimes[index] = 0.5 + Math.random() * 0.5;
    }
    
    emitParticleFromPoint(point) {
        // Créer une particule au point d'émission spécifié
        // Par exemple, vapeur des oreilles ou flammes sortant du corps
        const particlePosition = new THREE.Vector3().copy(point.position);
        
        // Ajouter à la position du groupe
        particlePosition.add(this.group.position);
        
        // Créer une petite explosion d'étincelles
        if (point.intensity > 0.3) {
            const sparkCount = Math.floor(3 + point.intensity * 5);
            for (let i = 0; i < sparkCount; i++) {
                const speed = 0.02 + Math.random() * 0.03;
                const angle = Math.random() * Math.PI * 2;
                const spark = {
                    position: particlePosition.clone(),
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * speed,
                        0.03 + Math.random() * 0.03,
                        Math.sin(angle) * speed
                    ),
                    size: 2 + Math.random() * 4,
                    color: new THREE.Color(CONFIG.colors.yellowOrange),
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02
                };
                explosionParticles.push(spark);
            }
        }
    }
    
    growWithAnger(intensity) {
        // Faire grandir le personnage avec l'intensité de la colère
        const targetScale = 1 + intensity * 1.0;
        this.initialScale = AngerUtils.lerp(this.initialScale, targetScale, 0.05);
    }
}

// Classe pour l'environnement qui réagit à la colère
class AngerEnvironment {
    constructor(scene) {
        this.scene = scene;
        
        // Créer un sol
        this.createGround();
        
        // Créer des murs qui peuvent vibrer et devenir rouges
        this.createWalls();
        
        // Ajouter des détails environnementaux
        this.createEnvironmentalDetails();
        
        // Ajouter l'éclairage dynamique
        this.createLighting();
    }
    
    createGround() {
        // Sol qui réagit à la colère
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        this.groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x333333,
            roughness: 0.8,
            metalness: 0.2,
            emissive: 0x000000
        });
        
        const ground = new THREE.Mesh(groundGeometry, this.groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -2;
        ground.receiveShadow = true;
        this.scene.add(ground);
        
        this.ground = ground;
    }
    
    createWalls() {
        // Murs qui tremblent avec la colère
        this.walls = [];
        
        // Propriétés des murs
        const wallHeight = 20;
        const wallWidth = 100;
        const wallDistance = 30;
        
        // Matériau pour les murs
        this.wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x444444,
            roughness: 0.7,
            metalness: 0.3,
            emissive: 0x000000
        });
        
        // Créer les 4 murs
        const wallGeometry = new THREE.PlaneGeometry(wallWidth, wallHeight);
        
        // Mur arrière
        const backWall = new THREE.Mesh(wallGeometry, this.wallMaterial);
        backWall.position.set(0, wallHeight / 2 - 2, -wallDistance / 2);
        backWall.receiveShadow = true;
        this.scene.add(backWall);
        this.walls.push(backWall);
        
        // Mur avant
        const frontWall = new THREE.Mesh(wallGeometry, this.wallMaterial);
        frontWall.position.set(0, wallHeight / 2 - 2, wallDistance / 2);
        frontWall.rotation.y = Math.PI;
        frontWall.receiveShadow = true;
        this.scene.add(frontWall);
        this.walls.push(frontWall);
        
        // Mur gauche
        const leftWall = new THREE.Mesh(wallGeometry, this.wallMaterial);
        leftWall.position.set(-wallDistance / 2, wallHeight / 2 - 2, 0);
        leftWall.rotation.y = Math.PI / 2;
        leftWall.receiveShadow = true;
        this.scene.add(leftWall);
        this.walls.push(leftWall);
        
        // Mur droit
        const rightWall = new THREE.Mesh(wallGeometry, this.wallMaterial);
        rightWall.position.set(wallDistance / 2, wallHeight / 2 - 2, 0);
        rightWall.rotation.y = -Math.PI / 2;
        rightWall.receiveShadow = true;
        this.scene.add(rightWall);
        this.walls.push(rightWall);
        
        // Plafond
        const ceilingGeometry = new THREE.PlaneGeometry(wallDistance, wallDistance);
        const ceiling = new THREE.Mesh(ceilingGeometry, this.wallMaterial);
        ceiling.position.set(0, wallHeight - 2, 0);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.receiveShadow = true;
        this.scene.add(ceiling);
        this.walls.push(ceiling);
    }
    
    createEnvironmentalDetails() {
        // Ajouter des fissures, des débris, etc. qui apparaissent avec la colère
        this.cracks = [];
        this.debrisPiles = [];
        
        // Créer des fissures sur les murs qui s'étendent avec l'intensité
        for (const wall of this.walls) {
            for (let i = 0; i < 3; i++) {
                const crackGeometry = new THREE.BufferGeometry();
                
                // Créer des fissures procédurales
                const points = [];
                const startPoint = new THREE.Vector3(
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 5,
                    0.01
                );
                
                points.push(startPoint);
                
                // Ajouter des segments ramifiés
                this.generateCrackSegments(startPoint, points, 0, 5, 1.0);
                
                // Convertir les points en positions pour la géométrie
                const positions = new Float32Array(points.length * 3);
                for (let j = 0; j < points.length; j++) {
                    positions[j * 3] = points[j].x;
                    positions[j * 3 + 1] = points[j].y;
                    positions[j * 3 + 2] = points[j].z;
                }
                
                crackGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                // Matériau pour la fissure
                const crackMaterial = new THREE.LineBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0
                });
                
                const crack = new THREE.Line(crackGeometry, crackMaterial);
                crack.userData.baseScale = 0.2 + Math.random() * 0.3;
                crack.scale.set(crack.userData.baseScale, crack.userData.baseScale, 1);
                
                wall.add(crack);
                this.cracks.push(crack);
            }
        }
        
        // Ajouter des amas de débris au sol qui augmentent avec la colère
        for (let i = 0; i < 5; i++) {
            const debrisPile = new THREE.Group();
            
            // Position aléatoire sur le sol
            debrisPile.position.set(
                (Math.random() - 0.5) * 20,
                -1.9, // Juste au-dessus du sol
                (Math.random() - 0.5) * 20
            );
            
            // Ajouter des petits rochers et débris
            for (let j = 0; j < 5 + Math.floor(Math.random() * 5); j++) {
                const debrisGeometry = new THREE.IcosahedronGeometry(
                    0.2 + Math.random() * 0.4,
                    0
                );
                
                const debrisMaterial = new THREE.MeshStandardMaterial({
                    color: 0x555555,
                    roughness: 0.9,
                    metalness: 0.1
                });
                
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debris.position.set(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 2
                );
                
                debris.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                debris.scale.set(
                    0.5 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.5,
                    0.5 + Math.random() * 0.5
                );
                
                debris.castShadow = true;
                debris.receiveShadow = true;
                
                debrisPile.add(debris);
            }
            
            debrisPile.scale.set(0, 0, 0); // Commencez invisible
            this.scene.add(debrisPile);
            this.debrisPiles.push(debrisPile);
        }
    }
    
    generateCrackSegments(startPoint, points, depth, maxDepth, length) {
        if (depth >= maxDepth) return;
        
        // Ajouter des segments de fissure avec ramification
        const numSegments = 1 + Math.floor(Math.random() * 3);
        
        for (let i = 0; i < numSegments; i++) {
            // Direction aléatoire, mais favorise certaines directions
            const direction = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.3) * 2, // Favoriser légèrement le haut
                0
            ).normalize();
            
            // Longueur aléatoire
            const segmentLength = length * (0.5 + Math.random() * 0.5);
            
            // Calculer le point d'arrivée
            const endPoint = new THREE.Vector3().copy(startPoint).add(
                direction.multiplyScalar(segmentLength)
            );
            
            // Ajouter un point intermédiaire pour plus de réalisme
            const midPoint = new THREE.Vector3().copy(startPoint).lerp(endPoint, 0.5);
            midPoint.x += (Math.random() - 0.5) * segmentLength * 0.3;
            midPoint.y += (Math.random() - 0.5) * segmentLength * 0.3;
            
            // Ajouter les points
            points.push(midPoint);
            points.push(endPoint);
            
            // Ramifications récursives si elles ne sont pas trop profondes et avec certaines chances
            if (depth < maxDepth - 1 && Math.random() < 0.6) {
                this.generateCrackSegments(
                    endPoint,
                    points,
                    depth + 1,
                    maxDepth,
                    segmentLength * 0.8
                );
            }
        }
    }
    
    createLighting() {
        // Créer les lumières qui deviennent plus intenses et rouges avec la colère
        
        // Lumière ambiante de base
        this.ambientLight = new THREE.AmbientLight(0x555555, 0.5);
        this.scene.add(this.ambientLight);
        
        // Lumière principale (qui change de couleur avec la colère)
        this.mainLight = new THREE.PointLight(0xffffff, 1, 30);
        this.mainLight.position.set(0, 5, 0);
        this.mainLight.castShadow = true;
        this.scene.add(this.mainLight);
        
        // Configuration des ombres
        this.mainLight.shadow.mapSize.width = 2048;
        this.mainLight.shadow.mapSize.height = 2048;
        this.mainLight.shadow.camera.near = 0.1;
        this.mainLight.shadow.camera.far = 30;
        this.mainLight.shadow.bias = -0.001;
        
        // Lumières d'accentuation
        this.accentLights = [];
        
        // Ajouter des lumières qui apparaissent progressivement autour de la scène
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI * 2;
            const radius = 8;
            
            const light = new THREE.PointLight(
                CONFIG.colors.brightRed,
                0, // Commence éteint
                15,
                2
            );
            
            light.position.set(
                Math.cos(angle) * radius,
                1 + Math.random() * 4,
                Math.sin(angle) * radius
            );
            
            this.scene.add(light);
            this.accentLights.push({
                light: light,
                baseIntensity: 0.5 + Math.random() * 0.5,
                pulsePhase: Math.random() * Math.PI * 2,
                pulseSpeed: 0.02 + Math.random() * 0.03
            });
        }
    }
    
    update(deltaTime, intensity) {
        // Mise à jour de l'environnement en fonction de l'intensité de la colère
        
        // Le sol devient progressivement rouge
        const groundColor = AngerUtils.lerpColor(0x333333, CONFIG.colors.baseRed, intensity * 0.5);
        this.groundMaterial.color.setHex(groundColor);
        
        // Émissivité du sol qui augmente
        const groundEmissive = AngerUtils.lerpColor(0x000000, CONFIG.colors.baseRed, Math.pow(intensity, 2) * 0.3);
        this.groundMaterial.emissive.setHex(groundEmissive);
        
        // Les murs tremblent avec la colère
        const wallShakeIntensity = intensity * 0.1;
        for (const wall of this.walls) {
            if (wallShakeIntensity > 0) {
                // Enregistrer la position d'origine si ce n'est pas déjà fait
                if (!wall.userData.originalPosition) {
                    wall.userData.originalPosition = wall.position.clone();
                }
                
                // Appliquer des tremblements aléatoires
                if (Math.random() < intensity) {
                    wall.position.set(
                        wall.userData.originalPosition.x + (Math.random() - 0.5) * wallShakeIntensity,
                        wall.userData.originalPosition.y + (Math.random() - 0.5) * wallShakeIntensity,
                        wall.userData.originalPosition.z + (Math.random() - 0.5) * wallShakeIntensity
                    );
                }
                
                // Faire rougeoyer les murs
                const wallColor = AngerUtils.lerpColor(0x444444, CONFIG.colors.baseRed, intensity * 0.3);
                this.wallMaterial.color.setHex(wallColor);
                
                // Émissivité des murs
                const wallEmissive = AngerUtils.lerpColor(0x000000, CONFIG.colors.baseRed, Math.pow(intensity, 2) * 0.2);
                this.wallMaterial.emissive.setHex(wallEmissive);
            }
        }
        
        // Les fissures deviennent plus visibles et s'étendent
        for (const crack of this.cracks) {
            // Visibilité basée sur un seuil d'intensité
            const crackThreshold = 0.3;
            let crackVisibility = 0;
            
            if (intensity > crackThreshold) {
                crackVisibility = (intensity - crackThreshold) / (1 - crackThreshold);
            }
            
            crack.material.opacity = crackVisibility;
            
            // Les fissures grandissent
            const growthFactor = 1 + crackVisibility * 2;
            crack.scale.set(
                crack.userData.baseScale * growthFactor,
                crack.userData.baseScale * growthFactor,
                1
            );
        }
        
        // Les amas de débris émergent du sol avec l'intensité
        for (let i = 0; i < this.debrisPiles.length; i++) {
            const pile = this.debrisPiles[i];
            
            // Intensité différente pour chaque pile pour les faire émerger progressivement
            const pileThreshold = 0.2 + i * 0.15;
            let pileVisibility = 0;
            
            if (intensity > pileThreshold) {
                pileVisibility = (intensity - pileThreshold) / (1 - pileThreshold);
            }
            
            pile.scale.set(pileVisibility, pileVisibility, pileVisibility);
            
            // Faire soulever les piles légèrement
            if (pileVisibility > 0) {
                pile.position.y = -1.9 + pileVisibility * 0.1;
                
                // Ajouter un peu de rotation aléatoire
                pile.rotation.y += Math.sin(timeElapsed * 0.001 + i) * 0.01 * intensity;
            }
        }
        
        // Mise à jour des lumières
        // Lumière principale qui devient plus intense et rouge
        const mainLightColor = AngerUtils.lerpColor(0xffffff, CONFIG.colors.brightRed, intensity * 0.7);
        this.mainLight.color.setHex(mainLightColor);
        this.mainLight.intensity = 1 + intensity * 2;
        
        // Lumière ambiante qui devient plus rouge
        const ambientLightColor = AngerUtils.lerpColor(0x555555, CONFIG.colors.baseRed, intensity * 0.3);
        this.ambientLight.color.setHex(ambientLightColor);
        
        // Lumières d'accentuation qui apparaissent et pulsent
        for (const accentLight of this.accentLights) {
            accentLight.pulsePhase += accentLight.pulseSpeed * deltaTime;
            
            // Intensité variable avec l'intensité de la colère
            const intensityThreshold = 0.4;
            let lightIntensity = 0;
            
            if (intensity > intensityThreshold) {
                const baseIntensity = (intensity - intensityThreshold) / (1 - intensityThreshold);
                const pulseAmount = Math.sin(accentLight.pulsePhase) * 0.5 + 0.5;
                
                lightIntensity = baseIntensity * accentLight.baseIntensity * (1 + pulseAmount);
            }
            
            accentLight.light.intensity = lightIntensity;
            
            // Faire changer les couleurs avec la colère
            const lightColor = AngerUtils.lerpColor(
                CONFIG.colors.brightRed,
                CONFIG.colors.yellowOrange,
                Math.sin(accentLight.pulsePhase * 0.5) * 0.5 + 0.5
            );
            accentLight.light.color.setHex(lightColor);
        }
    }
}

// Fonction pour initialiser l'animation de colère
function initColereCanvas() {
    try {
        console.log("Initialisation de l'animation de colère...");
        
        const canvas = document.getElementById('colere-canvas');
        if (!canvas) {
            console.error("Canvas colere non trouvé");
            updateLoadingProgress(); // Continuer malgré l'erreur
            return;
        }
        
        const container = document.getElementById('colere');
        
        // Vérification que Three.js est bien chargé
        if (typeof THREE === 'undefined') {
            console.error("Three.js n'est pas chargé");
            updateLoadingProgress(); // Continuer malgré l'erreur
            return;
        }
        
        // Configuration de la scène
        angerScene = new THREE.Scene();
        angerScene.background = new THREE.Color(0x1a0000);
        
        // Configuration de la caméra
        angerCamera = new THREE.PerspectiveCamera(
            CONFIG.camera.fov,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        angerCamera.position.set(0, 0, CONFIG.camera.distance);
        angerCamera.lookAt(0, 0, 0);
        
        // Configuration du renderer
        angerRenderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: true
        });
        angerRenderer.setSize(window.innerWidth, window.innerHeight);
        angerRenderer.setPixelRatio(window.devicePixelRatio);
        angerRenderer.shadowMap.enabled = true;
        angerRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Créer l'environnement
        angerEnvironment = new AngerEnvironment(angerScene);
        
        // Créer le personnage de colère
        angerCharacter = new AngerCharacter(angerScene, new THREE.Vector3(0, 0, 0));
        
        // Créer des objets destructibles
        createDestructibleObjects();
        
        // Configurer le post-traitement
        setupPostProcessing();
        
        // Système de particules pour les effets supplémentaires
        setupParticleSystems();
        
        // Gérer le redimensionnement de la fenêtre
        window.addEventListener('resize', onWindowResize);
        
        // Système de tracking du temps
        let lastTime = 0;
        let phase = 0;
        let phaseTime = 0;
        timeElapsed = 0;
        
        // Démarrer l'animation
        function animate(time) {
            try {
                const deltaTime = Math.min(50, time - lastTime); // Limiter le deltaTime pour éviter les saccades
                lastTime = time;
                timeElapsed += deltaTime;
                
                // Mise à jour de la progression de l'histoire
                phase = updateStoryProgress('colere', deltaTime);
                phaseTime += deltaTime;
                
                // Calculer l'intensité actuelle basée sur la phase et le temps
                let targetIntensity = CONFIG.phases[Math.floor(phase)].intensity;
                
                // Transition entre les phases
                const phaseIndex = Math.floor(phase);
                const nextPhaseIndex = Math.min(phaseIndex + 1, CONFIG.phases.length - 1);
                const phaseProgress = phase - phaseIndex;
                
                if (phaseProgress > 0 && nextPhaseIndex > phaseIndex) {
                    targetIntensity = AngerUtils.lerp(
                        CONFIG.phases[phaseIndex].intensity,
                        CONFIG.phases[nextPhaseIndex].intensity,
                        phaseProgress
                    );
                }
                
                // Lisser les transitions d'intensité
                currentIntensity = AngerUtils.lerp(currentIntensity, targetIntensity, 0.05);
                
                // Mise à jour de la caméra
                updateCamera(deltaTime, currentIntensity);
                
                // Mise à jour du personnage
                angerCharacter.update(deltaTime, currentIntensity);
                angerCharacter.growWithAnger(currentIntensity);
                
                // Mise à jour de l'environnement
                angerEnvironment.update(deltaTime, currentIntensity);
                
                // Mise à jour des objets destructibles
                updateDestructibleObjects(deltaTime, currentIntensity);
                
                // Mise à jour des explosions et particules spéciales
                updateSpecialEffects(deltaTime);
                
                // Mise à jour du post-processing
                updatePostProcessing(deltaTime, currentIntensity);
                
                // Rendu de la scène
                // angerRenderer.render(angerScene, angerCamera);
                postProcessing.render();
                
                requestAnimationFrame(animate);
            } catch (error) {
                console.error("Erreur dans l'animation de colère:", error);
                requestAnimationFrame(animate); // Continuer l'animation malgré l'erreur
            }
        }
        
        animate(0);
        updateLoadingProgress();
        
        console.log("Animation de colère initialisée avec succès");
    } catch (error) {
        console.error("Erreur dans l'initialisation de l'animation de colère:", error);
        updateLoadingProgress(); // Continuer malgré l'erreur
    }
}

// Configuration de la caméra
function updateCamera(deltaTime, intensity) {
    // Distance qui varie avec l'intensité
    const targetDistance = CONFIG.camera.distance - intensity * 2;
    angerCamera.position.z = AngerUtils.lerp(angerCamera.position.z, targetDistance, 0.05);
    
    // Tremblement de caméra qui augmente avec l'intensité
    const shakeAmount = CONFIG.camera.shakeIntensity * Math.pow(intensity, 2);
    
    if (shakeAmount > 0) {
        angerCamera.position.x += (Math.random() - 0.5) * shakeAmount;
        angerCamera.position.y += (Math.random() - 0.5) * shakeAmount;
    }
    
    // La caméra regarde toujours le centre
    angerCamera.lookAt(0, 0, 0);
}

// Création des objets destructibles
function createDestructibleObjects() {
    destructibleObjects = [];
    
    // Créer différents types d'objets avec différentes tailles et matériaux
    const objectTypes = ['cube', 'sphere', 'cylinder', 'torus', 'pyramid'];
    
    for (let i = 0; i < CONFIG.destruction.objectCount; i++) {
        // Disposition en cercle autour du personnage
        const angle = (i / CONFIG.destruction.objectCount) * Math.PI * 2;
        const radius = 4 + Math.random() * 3; // Distance du centre
        
        const position = new THREE.Vector3(
            Math.cos(angle) * radius,
            Math.random() * 2,
            Math.sin(angle) * radius
        );
        
        // Taille aléatoire
        const size = AngerUtils.randomInRange(
            CONFIG.destruction.minSize,
            CONFIG.destruction.maxSize
        ) / 100;
        
        // Type aléatoire
        const type = objectTypes[Math.floor(Math.random() * objectTypes.length)];
        
        // Créer un matériau spécifique à cet objet
        const material = new THREE.MeshStandardMaterial({
            color: 0xe0e0e0,
            roughness: 0.3 + Math.random() * 0.5,
            metalness: 0.2 + Math.random() * 0.6,
            emissive: 0x000000
        });
        
        // Créer l'objet destructible
        const destructible = new DestructibleObject(angerScene, position, size, type, material);
        destructibleObjects.push(destructible);
    }
}

// Mise à jour des objets destructibles
function updateDestructibleObjects(deltaTime, intensity) {
    // Probabilité de rupture des objets basée sur l'intensité
    const breakProbability = Math.max(0, intensity - CONFIG.destruction.breakableThreshold) * 0.01;
    
    for (let i = 0; i < destructibleObjects.length; i++) {
        const obj = destructibleObjects[i];
        
        if (!obj.broken) {
            // Déplacer les objets plus frénétiquement avec la colère
            obj.update(deltaTime, intensity);
            
            // Vérifier si l'objet doit se briser
            if (Math.random() < breakProbability * deltaTime) {
                obj.break(intensity);
            }
        } else {
            // Mettre à jour les fragments
            obj.update(deltaTime, intensity);
        }
    }
}

// Configuration du post-traitement
function setupPostProcessing() {
    try {
        postProcessing = new PostProcessor(angerRenderer, angerScene, angerCamera);
    } catch (error) {
        console.error("Erreur lors de la configuration du post-traitement:", error);
        // Fallback au rendu standard si le post-traitement échoue
        postProcessing = {
            update: () => {},
            render: () => angerRenderer.render(angerScene, angerCamera),
            resize: () => {}
        };
    }
}

// Mise à jour du post-traitement
function updatePostProcessing(deltaTime, intensity) {
    if (postProcessing && postProcessing.update) {
        postProcessing.update(deltaTime, intensity);
    }
}

// Configuration des systèmes de particules
function setupParticleSystems() {
    // Cette fonction configure tous les systèmes de particules spéciaux
    particleSystems.explosionMeshes = [];
    explosionParticles = [];
    activeExplosions = [];
    
    // D'autres systèmes de particules peuvent être configurés ici
}

// Mise à jour des effets spéciaux
function updateSpecialEffects(deltaTime) {
    // Mettre à jour les explosions actives
    for (let i = 0; i < activeExplosions.length; i++) {
        const explosion = activeExplosions[i];
        const isActive = explosion.update(deltaTime);
        explosion.draw(angerScene);
        
        if (!isActive) {
            activeExplosions.splice(i, 1);
            i--;
        }
    }
    
    // Mettre à jour et nettoyer les particules d'explosion
    for (let i = 0; i < explosionParticles.length; i++) {
        const p = explosionParticles[i];
        p.life -= p.decay * deltaTime;
        
        if (p.life <= 0) {
            explosionParticles.splice(i, 1);
            i--;
        } else {
            // Mettre à jour la position
            p.position.x += p.velocity.x * deltaTime;
            p.position.y += p.velocity.y * deltaTime;
            p.position.z += p.velocity.z * deltaTime;
            
            // Ralentir la particule
            p.velocity.x *= 0.98;
            p.velocity.y *= 0.98;
            p.velocity.z *= 0.98;
            
            // Ajouter de la gravité
            p.velocity.y -= 0.0003 * deltaTime;
            
            // Dessiner la particule (utiliser un mesh pour plus de performances)
            const particleGeometry = new THREE.SphereGeometry(p.size * p.life, 8, 8);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: p.color,
                transparent: true,
                opacity: p.life
            });
            const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);
            particleMesh.position.copy(p.position);
            
            angerScene.add(particleMesh);
            particleSystems.explosionMeshes.push({
                mesh: particleMesh,
                lifetime: p.life
            });
        }
    }
    
    // Nettoyer les meshes d'explosion de la frame précédente
    for (let i = 0; i < particleSystems.explosionMeshes.length; i++) {
        const meshInfo = particleSystems.explosionMeshes[i];
        angerScene.remove(meshInfo.mesh);
        
        if (meshInfo.mesh.geometry) {
            meshInfo.mesh.geometry.dispose();
        }
        
        if (meshInfo.mesh.material) {
            meshInfo.mesh.material.dispose();
        }
    }
    
    particleSystems.explosionMeshes = [];
}

// Gestion du redimensionnement de fenêtre
function onWindowResize() {
    angerCamera.aspect = window.innerWidth / window.innerHeight;
    angerCamera.updateProjectionMatrix();
    angerRenderer.setSize(window.innerWidth, window.innerHeight);
    
    if (postProcessing && postProcessing.resize) {
        postProcessing.resize(window.innerWidth, window.innerHeight);
    }
}

// Nettoyage des ressources pour éviter les fuites de mémoire
function cleanupColereAnimation() {
    // Nettoyer les objets destructibles
    for (const obj of destructibleObjects) {
        obj.clean();
    }
    destructibleObjects = [];
    
    // Nettoyer les systèmes de particules
    cleanupParticleSystems();
    
    // Nettoyer les listeners d'événements
    window.removeEventListener('resize', onWindowResize);
    
    // Autres nettoyages spécifiques
    // ...
}

function cleanupParticleSystems() {
    // Nettoyer les meshes d'explosion
    for (const meshInfo of particleSystems.explosionMeshes) {
        angerScene.remove(meshInfo.mesh);
        
        if (meshInfo.mesh.geometry) {
            meshInfo.mesh.geometry.dispose();
        }
        
        if (meshInfo.mesh.material) {
            meshInfo.mesh.material.dispose();
        }
    }
    
    particleSystems.explosionMeshes = [];
    explosionParticles = [];
    activeExplosions = [];
}

// Exporter la fonction d'initialisation
function resetColereStory() {
    try {
        // Nettoyer l'ancienne animation si elle existe
        cleanupColereAnimation();
        
        // Réinitialiser les variables globales
        currentIntensity = 0;
        timeElapsed = 0;
        
        // Les autres réinitialisations sont gérées dans initColereCanvas
    } catch (error) {
        console.error("Erreur dans resetColereStory:", error);
    }
}
        
        /**
         * ======================================
         * ANIMATION DE DÉGOÛT
         * ======================================
         */
        let foodPlate = null;
        let flies = [];
        
        function resetDegoutStory() {
            try {
                // Suppression de l'assiette de nourriture si elle existe
                if (foodPlate && foodPlate.element && foodPlate.element.parentNode) {
                    foodPlate.element.parentNode.removeChild(foodPlate.element);
                    foodPlate = null;
                }
                
                // Suppression des mouches
                flies.forEach(fly => {
                    if (fly && fly.element && fly.element.parentNode) {
                        fly.element.parentNode.removeChild(fly.element);
                    }
                });
                flies = [];
            } catch (error) {
                console.error("Erreur dans resetDegoutStory:", error);
            }
        }
        
        // Fonction auxiliaire pour créer les mouches
        function createFlies(container, foodPlate) {
            try {
                if (!container || !foodPlate) return;
                
                flies = []; // Réinitialiser le tableau de mouches
                
                for (let i = 0; i < 10; i++) {
                    const fly = document.createElement('div');
                    fly.className = 'fly';
                    container.appendChild(fly);
                    
                    flies.push({
                        element: fly,
                        x: foodPlate.x + (Math.random() - 0.5) * 100,
                        y: foodPlate.y + (Math.random() - 0.5) * 100,
                        angle: Math.random() * Math.PI * 2,
                        speed: 1 + Math.random() * 2,
                        phaseOffset: Math.random() * Math.PI * 2,
                        circleRadius: 20 + Math.random() * 60,
                        baseX: foodPlate.x,
                        baseY: foodPlate.y,
                        size: 5 + Math.random() * 5,
                        active: false
                    });
                }
            } catch (error) {
                console.error("Erreur dans createFlies:", error);
            }
        }

        function initDegoutCanvas() {
            try {
                const canvas = document.getElementById('degout-canvas');
                if (!canvas) {
                    console.error("Canvas degout non trouvé");
                    updateLoadingProgress(); // Continuer malgré l'erreur
                    return;
                }
                
                const ctx = canvas.getContext('2d');
                const container = document.getElementById('degout');
                
                // Définition du canvas à pleine taille
                function resizeCanvas() {
                    if (canvas) {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    }
                }
                
                window.addEventListener('resize', resizeCanvas);
                resizeCanvas();
                
                // Création de blobs pour l'arrière-plan
                const blobs = [];
                const blobCount = 10;
                
                for (let i = 0; i < blobCount; i++) {
                    blobs.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: 40 + Math.random() * 60,
                        color: `rgba(${100 + Math.random() * 50}, ${150 + Math.random() * 50}, ${0 + Math.random() * 30}, ${0.1 + Math.random() * 0.3})`,
                        points: [],
                        pointCount: 6 + Math.floor(Math.random() * 4),
                        speed: 0.3 + Math.random() * 0.7,
                        angle: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.01,
                        pulseSpeed: 0.5 + Math.random() * 1.5
                    });
                }
                
                for (let blob of blobs) {
                    for (let i = 0; i < blob.pointCount; i++) {
                        const angle = (i / blob.pointCount) * Math.PI * 2;
                        const randomRadius = blob.radius * (0.7 + Math.random() * 0.6);
                        
                        blob.points.push({
                            angle: angle,
                            radius: randomRadius,
                            originalRadius: randomRadius,
                            pulsePhase: Math.random() * Math.PI * 2
                        });
                    }
                }
                
                // Création du personnage
                const character = {
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    size: 80,
                    eyeSize: 15,
                    mouthWidth: 30,
                    mouthHeight: 10,
                    eyebrowAngle: Math.PI * 0.1,
                    blinkTimer: 0,
                    targetX: canvas.width * 0.7,
                    targetY: canvas.height * 0.5,
                    disgustLevel: 0, // 0 = neutre, 3 = dégoût extrême
                    moveSpeed: 0.04
                };
                
                // Création de l'assiette de nourriture
                if (container) {
                    foodPlate = {
                        element: document.createElement('div'),
                        x: canvas.width * 0.3,
                        y: canvas.height * 0.5,
                        phase: 0,
                        rottenLevel: 0
                    };
                    
                    foodPlate.element.className = 'food-plate';
                    
                    const food = document.createElement('div');
                    food.className = 'food';
                    foodPlate.element.appendChild(food);
                    
                    foodPlate.element.style.left = `${foodPlate.x - 100}px`;
                    foodPlate.element.style.top = `${foodPlate.y - 100}px`;
                    container.appendChild(foodPlate.element);
                    
                    // Création des mouches
                    createFlies(container, foodPlate);
                }
                
                function drawBlob(blob, time) {
                    try {
                        if (!ctx) return;
                        
                        ctx.fillStyle = blob.color;
                        ctx.beginPath();
                        
                        // Mise à jour des points
                        for (let i = 0; i < blob.pointCount; i++) {
                            const point = blob.points[i];
                            point.radius = point.originalRadius + 
                                Math.sin(time * 0.001 * blob.pulseSpeed + point.pulsePhase) * (point.originalRadius * 0.3);
                        }
                        
                        // Dessin du blob
                        for (let i = 0; i <= blob.pointCount; i++) {
                            const point = blob.points[i % blob.pointCount];
                            const angle = point.angle + blob.angle;
                            
                            const x = blob.x + Math.cos(angle) * point.radius;
                            const y = blob.y + Math.sin(angle) * point.radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                const prevPoint = blob.points[(i - 1) % blob.pointCount];
                                const prevAngle = prevPoint.angle + blob.angle;
                                const prevX = blob.x + Math.cos(prevAngle) * prevPoint.radius;
                                const prevY = blob.y + Math.sin(prevAngle) * prevPoint.radius;
                                
                                const cpX = (x + prevX) / 2;
                                const cpY = (y + prevY) / 2;
                                
                                ctx.quadraticCurveTo(prevX, prevY, cpX, cpY);
                            }
                        }
                        
                        ctx.fill();
                    } catch (error) {
                        console.error("Erreur dans drawBlob:", error);
                    }
                }
                
                function drawCharacter(time) {
                    try {
                        if (!ctx) return;
                        
                        // Tête
                        const skinHue = Math.max(0, 48 - character.disgustLevel * 8);
                        ctx.fillStyle = `hsl(${skinHue}, 80%, 80%)`;
                        ctx.beginPath();
                        ctx.arc(character.x, character.y, character.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Yeux
                        const blinkAmount = Math.max(0, 1 - Math.abs(character.blinkTimer - 50) / 10);
                        const eyeHeight = character.eyeSize * (1 - blinkAmount * 0.9);
                        
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.ellipse(
                            character.x - character.size * 0.3, 
                            character.y - character.size * 0.2, 
                            character.eyeSize, 
                            eyeHeight, 
                            0, 0, Math.PI * 2
                        );
                        ctx.ellipse(
                            character.x + character.size * 0.3, 
                            character.y - character.size * 0.2, 
                            character.eyeSize, 
                            eyeHeight, 
                            0, 0, Math.PI * 2
                        );
                        ctx.fill();
                        
                        // Pupilles - regarder ailleurs à mesure que le dégoût augmente
                        if (blinkAmount < 0.8) {
                            ctx.fillStyle = '#304030';
                            
                            // Direction du regard dépend du niveau de dégoût
                            const gazeDirection = Math.min(1, character.disgustLevel * 0.3) * 10;
                            
                            ctx.beginPath();
                            ctx.arc(
                                character.x - character.size * 0.3 - gazeDirection, 
                                character.y - character.size * 0.2, 
                                character.eyeSize * 0.5, 
                                0, Math.PI * 2
                            );
                            ctx.arc(
                                character.x + character.size * 0.3 - gazeDirection, 
                                character.y - character.size * 0.2, 
                                character.eyeSize * 0.5, 
                                0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                        
                        // Sourcils - s'inclinent vers le haut à mesure que le dégoût augmente
                        const eyebrowDisgustAngle = character.eyebrowAngle + character.disgustLevel * 0.05;
                        
                        ctx.fillStyle = `hsl(${skinHue - 20}, 60%, 50%)`;
                        ctx.save();
                        
                        ctx.translate(character.x - character.size * 0.3, character.y - character.size * 0.35);
                        ctx.rotate(-eyebrowDisgustAngle);
                        ctx.fillRect(-character.size * 0.25, -character.size * 0.05, character.size * 0.5, character.size * 0.1);
                        ctx.restore();
                        
                        ctx.save();
                        ctx.translate(character.x + character.size * 0.3, character.y - character.size * 0.35);
                        ctx.rotate(eyebrowDisgustAngle);
                        ctx.fillRect(-character.size * 0.25, -character.size * 0.05, character.size * 0.5, character.size * 0.1);
                        ctx.restore();
                        
                        // Bouche (expression dégoûtée) - plus inclinée vers le bas avec le dégoût
                        const mouthDisgustAmount = 0.2 + character.disgustLevel * 0.3;
                        
                        ctx.fillStyle = '#d04040';
                        ctx.beginPath();
                        ctx.moveTo(character.x - character.mouthWidth / 2, character.y + character.size * 0.25);
                        ctx.quadraticCurveTo(
                            character.x, 
                            character.y + character.size * 0.25 + character.mouthHeight * mouthDisgustAmount, 
                            character.x + character.mouthWidth / 2, 
                            character.y + character.size * 0.25
                        );
                        ctx.quadraticCurveTo(
                            character.x, 
                            character.y + character.size * 0.25 - character.mouthHeight / 2, 
                            character.x - character.mouthWidth / 2, 
                            character.y + character.size * 0.25
                        );
                        ctx.fill();
                        
                        // Rides du nez - plus prononcées avec le dégoût
                        const wrinkleAmount = Math.min(1, character.disgustLevel * 0.5);
                        
                        if (wrinkleAmount > 0.1) {
                            ctx.strokeStyle = `rgba(${208 - skinHue}, ${160 - skinHue * 0.5}, ${128 - skinHue * 0.3}, ${wrinkleAmount})`;
                            ctx.lineWidth = 2;
                            
                            // Première ride
                            ctx.beginPath();
                            ctx.moveTo(character.x - character.size * 0.15, character.y - character.size * 0.05);
                            ctx.quadraticCurveTo(
                                character.x, 
                                character.y - character.size * (0.03 + wrinkleAmount * 0.05), 
                                character.x + character.size * 0.15, 
                                character.y - character.size * 0.05
                            );
                            ctx.stroke();
                            
                            // Deuxième ride si très dégoûté
                            if (wrinkleAmount > 0.5) {
                                ctx.beginPath();
                                ctx.moveTo(character.x - character.size * 0.1, character.y - character.size * 0.1);
                                ctx.quadraticCurveTo(
                                    character.x, 
                                    character.y - character.size * (0.08 + wrinkleAmount * 0.03), 
                                    character.x + character.size * 0.1, 
                                    character.y - character.size * 0.1
                                );
                                ctx.stroke();
                            }
                        }
                        
                        // Teinte verte pour dégoût extrême
                        if (character.disgustLevel > 2) {
                            ctx.fillStyle = `rgba(100, 255, 100, ${(character.disgustLevel - 2) * 0.1})`;
                            ctx.beginPath();
                            ctx.arc(character.x, character.y, character.size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    } catch (error) {
                        console.error("Erreur dans drawCharacter:", error);
                    }
                }
                
                // Suivi du temps
                let lastTime = 0;
                
                function animate(time) {
                    try {
                        const deltaTime = time - lastTime;
                        lastTime = time;
                        
                        // Mise à jour de la progression de l'histoire
                        const phase = updateStoryProgress('degout', deltaTime);
                        
                        // Mises à jour spécifiques à la phase
                        updatePhaseElements(phase, deltaTime);
                        
                        if (!ctx) return;
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Dessin de l'arrière-plan avec un dégradé basé sur la phase de l'histoire
                        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                        gradient.addColorStop(0, `rgba(${26 + phase * 3}, ${59 - phase * 5}, ${12 + phase * 3}, 1)`);
                        gradient.addColorStop(1, `rgba(${44 - phase * 3}, ${76 - phase * 6}, ${28 - phase * 2}, 1)`);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Mise à jour et dessin des blobs
                        for (let blob of blobs) {
                            // Déplacement lent du blob
                            blob.x += Math.cos(blob.angle) * blob.speed * (deltaTime / 16);
                            blob.y += Math.sin(blob.angle) * blob.speed * (deltaTime / 16);
                            
                            // Changement de direction occasionnel
                            if (Math.random() < 0.01) {
                                blob.angle += (Math.random() - 0.5) * Math.PI / 4;
                            }
                            
                            // Rotation du blob
                            blob.angle += blob.rotationSpeed * (deltaTime / 16);
                            
                            // Rebond sur les bords
                            if (blob.x < -blob.radius) blob.x = canvas.width + blob.radius;
                            if (blob.x > canvas.width + blob.radius) blob.x = -blob.radius;
                            if (blob.y < -blob.radius) blob.y = canvas.height + blob.radius;
                            if (blob.y > canvas.height + blob.radius) blob.y = -blob.radius;
                            
                            drawBlob(blob, time);
                        }
                        
                        // Mise à jour du personnage
                        character.blinkTimer += 1;
                        if (character.blinkTimer > 200) {
                            character.blinkTimer = 0;
                        }
                        
                        // Déplacement du personnage basé sur la phase et le niveau de dégoût
                        switch (phase) {
                            case 0:
                                character.targetX = canvas.width * 0.6;
                                character.disgustLevel = 0.2;
                                break;
                            case 1:
                                character.targetX = canvas.width * 0.5;
                                character.disgustLevel = 1;
                                break;
                            case 2:
                                character.targetX = canvas.width * 0.65;
                                character.disgustLevel = 2;
                                break;
                            case 3:
                                character.targetX = canvas.width * 0.75;
                                character.disgustLevel = 3;
                                break;
                        }
                        
                        // Éloignement du personnage de la nourriture à mesure que le dégoût augmente
                        character.x += (character.targetX - character.x) * character.moveSpeed * (deltaTime / 16);
                        character.y += (character.targetY - character.y) * character.moveSpeed * (deltaTime / 16);
                        
                        // Dessin du personnage
                        drawCharacter(time);
                        
                        requestAnimationFrame(animate);
                    } catch (error) {
                        console.error("Erreur dans animate de degout:", error);
                        requestAnimationFrame(animate); // Continuer l'animation malgré l'erreur
                    }
                }
                
                function updatePhaseElements(phase, deltaTime) {
                    try {
                        // Vérification que foodPlate existe
                        if (!foodPlate || !foodPlate.element) {
                            console.log("foodPlate non disponible, création...");
                            if (container) {
                                foodPlate = {
                                    element: document.createElement('div'),
                                    x: canvas.width * 0.3,
                                    y: canvas.height * 0.5,
                                    phase: 0,
                                    rottenLevel: 0
                                };
                                
                                foodPlate.element.className = 'food-plate';
                                
                                const food = document.createElement('div');
                                food.className = 'food';
                                foodPlate.element.appendChild(food);
                                
                                foodPlate.element.style.left = `${foodPlate.x - 100}px`;
                                foodPlate.element.style.top = `${foodPlate.y - 100}px`;
                                container.appendChild(foodPlate.element);
                                
                                // Création des mouches si nécessaire
                                if (flies.length === 0) {
                                    createFlies(container, foodPlate);
                                }
                            } else {
                                console.error("Container non disponible pour foodPlate");
                                return;
                            }
                        }
                        
                        // Animation de l'assiette de nourriture basée sur la phase
                        if (phase >= 0 && foodPlate.phase === 0) {
                            foodPlate.phase = 1;
                            foodPlate.element.style.opacity = '1';
                        }
                        
                        // La nourriture devient plus pourrie avec chaque phase
                        const food = foodPlate.element.querySelector('.food');
                        if (food) {
                            food.style.background = `linear-gradient(to bottom right, 
                                hsl(${90 - phase * 20}, ${70 - phase * 10}%, ${40 - phase * 5}%), 
                                hsl(${70 - phase * 20}, ${60 - phase * 10}%, ${30 - phase * 5}%))`;
                        }
                        
                        // Vérification que flies est un tableau
                        if (!Array.isArray(flies)) {
                            console.error("flies n'est pas un tableau");
                            return;
                        }
                        
                        // Les mouches apparaissent dans les phases ultérieures
                        for (let i = 0; i < flies.length; i++) {
                            const fly = flies[i];
                            if (!fly || !fly.element) continue;
                            
                            // Détermination de quand chaque mouche doit apparaître
                            if (phase >= 1 && i < 3 && !fly.active) {
                                fly.active = true;
                                fly.element.style.opacity = '0.7';
                            } else if (phase >= 2 && i < 7 && !fly.active) {
                                fly.active = true;
                                fly.element.style.opacity = '0.7';
                            } else if (phase >= 3 && !fly.active) {
                                fly.active = true;
                                fly.element.style.opacity = '0.7';
                            }
                            
                            // Animation des mouches actives
                            if (fly.active) {
                                // Mouvement circulaire avec du hasard
                                const time = Date.now() * 0.001;
                                const flyCircleRadius = fly.circleRadius * (1 + Math.sin(time * 0.5) * 0.2);
                                
                                // Positionnement de base autour de la nourriture avec un chaos croissant à mesure que le dégoût augmente
                                const chaosLevel = Math.min(1, phase * 0.2);
                                
                                fly.baseX = foodPlate.x + (Math.sin(time * 0.3) * 30 * chaosLevel);
                                fly.baseY = foodPlate.y + (Math.cos(time * 0.2) * 20 * chaosLevel);
                                
                                // Calcul de la position avec des variations aléatoires
                                fly.x = fly.baseX + Math.cos(time * fly.speed + fly.phaseOffset) * flyCircleRadius;
                                fly.y = fly.baseY + Math.sin(time * fly.speed + fly.phaseOffset) * flyCircleRadius * 0.6;
                                
                                // Application d'une instabilité aléatoire basée sur la phase (plus chaotique dans les phases ultérieures)
                                if (Math.random() < 0.1 * phase) {
                                    fly.x += (Math.random() - 0.5) * 10 * phase;
                                    fly.y += (Math.random() - 0.5) * 10 * phase;
                                }
                                
                                // Changements de direction occasionnels
                                if (Math.random() < 0.02) {
                                    fly.phaseOffset += (Math.random() - 0.5) * Math.PI;
                                }
                                
                                // Les mouches deviennent plus grandes dans les phases ultérieures
                                const sizeFactor = 1 + phase * 0.3;
                                fly.element.style.width = `${fly.size * sizeFactor}px`;
                                fly.element.style.height = `${fly.size * sizeFactor}px`;
                                
                                // Positionnement de la mouche
                                fly.element.style.left = `${fly.x}px`;
                                fly.element.style.top = `${fly.y}px`;
                                
                                // Ajout d'ombres pour rendre les mouches plus visibles
                                fly.element.style.boxShadow = `0 0 ${3 + phase}px rgba(0, 0, 0, 0.5)`;
                                
                                // Ajout d'un effet d'ailes avec des pseudo-éléments
                                const animationSpeed = 200 - phase * 20; // Bourdonnement plus rapide dans les phases ultérieures
                                fly.element.style.animation = `flutter ${animationSpeed}ms infinite alternate ease-in-out`;
                                
                                // Dans la phase la plus dégoûtante, certaines mouches se posent réellement sur la nourriture
                                if (phase >= 3 && Math.random() < 0.01) {
                                    // Atterrissage sur la nourriture
                                    const angle = Math.random() * Math.PI * 2;
                                    const landRadius = 50 * Math.random();
                                    fly.x = foodPlate.x + Math.cos(angle) * landRadius;
                                    fly.y = foodPlate.y + Math.sin(angle) * landRadius;
                                    fly.element.style.left = `${fly.x}px`;
                                    fly.element.style.top = `${fly.y}px`;
                                    
                                    // Pause brève
                                    fly.element.style.animation = 'none';
                                    
                                    // Redécollage après un moment
                                    setTimeout(() => {
                                        if (fly.element) {
                                            fly.element.style.animation = `flutter ${animationSpeed}ms infinite alternate ease-in-out`;
                                        }
                                    }, 500 + Math.random() * 1000);
                                }
                            }
                        }
                        
                        // Ajout de taches de moisissure en phase 2 et 3
                        if (phase >= 2 && foodPlate.rottenLevel < phase) {
                            foodPlate.rottenLevel = phase;
                            
                            // Ajout de taches de moisissure à la nourriture
                            const moldSpots = phase >= 2 ? 3 + phase * 2 : 0;
                            const food = foodPlate.element.querySelector('.food');
                            
                            if (food) {
                                for (let i = 0; i < moldSpots; i++) {
                                    const moldSpot = document.createElement('div');
                                    moldSpot.style.position = 'absolute';
                                    moldSpot.style.width = `${5 + Math.random() * 15}px`;
                                    moldSpot.style.height = `${5 + Math.random() * 15}px`;
                                    moldSpot.style.borderRadius = '50%';
                                    moldSpot.style.backgroundColor = `hsl(${Math.random() < 0.5 ? 80 : 40}, ${60 + Math.random() * 20}%, ${30 + Math.random() * 20}%)`;
                                    moldSpot.style.left = `${Math.random() * 80 + 10}%`;
                                    moldSpot.style.top = `${Math.random() * 80 + 10}%`;
                                    moldSpot.style.opacity = '0';
                                    moldSpot.style.transition = 'opacity 1s';
                                    food.appendChild(moldSpot);
                                    
                                    // Apparition progressive de la tache de moisissure
                                    setTimeout(() => {
                                        if (moldSpot) {
                                            moldSpot.style.opacity = '0.7';
                                        }
                                    }, 100 * i);
                                }
                            }
                        }
                        
                        // Ajout d'un effet de goutte dégoûtante dans la phase finale
                        if (phase >= 3 && container) {
                            // Création de gouttes visqueuses à intervalles aléatoires
                            if (Math.random() < 0.05) {
                                const drip = document.createElement('div');
                                drip.style.position = 'absolute';
                                drip.style.width = `${3 + Math.random() * 5}px`;
                                drip.style.height = `${10 + Math.random() * 20}px`;
                                drip.style.borderRadius = '50% 50% 20% 20% / 30% 30% 70% 70%';
                                drip.style.backgroundColor = `hsla(${70 - Math.random() * 50}, 70%, 25%, 0.7)`;
                                
                                // Positionnement au bas de l'assiette de nourriture
                                const angle = (Math.random() - 0.5) * Math.PI;
                                drip.style.left = `${foodPlate.x + Math.cos(angle) * 100}px`;
                                drip.style.top = `${foodPlate.y + 100}px`;
                                drip.style.transformOrigin = 'center top';
                                container.appendChild(drip);
                                
                                // Animation de la goutte qui tombe
                                let dripY = foodPlate.y + 100;
                                const dripFall = setInterval(() => {
                                    dripY += 1 + Math.random() * 2;
                                    if (drip) {
                                        drip.style.top = `${dripY}px`;
                                    }
                                    
                                    // Suppression quand elle atteint le bas de l'écran
                                    if (dripY > window.innerHeight) {
                                        clearInterval(dripFall);
                                        if (drip && drip.parentNode) {
                                            drip.parentNode.removeChild(drip);
                                        }
                                    }
                                }, 50);
                                
                                // Disparition progressive au fil du temps
                                setTimeout(() => {
                                    if (drip) {
                                        drip.style.transition = 'opacity 1s';
                                        drip.style.opacity = '0';
                                        
                                        // Suppression après la disparition
                                        setTimeout(() => {
                                            if (drip && drip.parentNode) {
                                                drip.parentNode.removeChild(drip);
                                            }
                                        }, 1000);
                                    }
                                }, 3000 + Math.random() * 2000);
                            }
                        }
                    } catch (error) {
                        console.error("Erreur dans updatePhaseElements de degout:", error);
                    }
                }
                
                animate(0);
                updateLoadingProgress();
            } catch (error) {
                console.error("Erreur globale dans initDegoutCanvas:", error);
                updateLoadingProgress(); // Continuer malgré l'erreur
            }
        }

        /**
         * ======================================
         * INITIALISATION ET CONFIGURATION
         * ======================================
         */
        document.addEventListener('DOMContentLoaded', () => {
            try {
                console.log("Initialisation de l'application...");
                
                // Affichage du tooltip des contrôles après un délai
                setTimeout(() => {
                    const controlsTooltip = document.getElementById('controls-tooltip');
                    if (controlsTooltip) {
                        controlsTooltip.style.opacity = '1';
                        
                        // Masquage du tooltip après un certain temps
                        setTimeout(() => {
                            controlsTooltip.style.opacity = '0';
                        }, 10000);
                    }
                }, 5000);
                
                // Affichage/masquage du tooltip au survol
                const controlsTooltip = document.getElementById('controls-tooltip');
                if (controlsTooltip) {
                    controlsTooltip.addEventListener('mouseenter', () => {
                        controlsTooltip.style.opacity = '1';
                    });
                    
                    controlsTooltip.addEventListener('mouseleave', () => {
                        controlsTooltip.style.opacity = '0';
                    });
                }
                
                // Initialisation de toutes les animations
                console.log("Initialisation des animations...");
                initTristesseCanvas();
                initColereCanvas();
                initDegoutCanvas();
                
                // Affichage du texte de la première section
                const tristesseText = document.querySelector('#tristesse .emotion-text');
                if (tristesseText) {
                    tristesseText.classList.add('visible');
                }
                updateActiveNavDot('tristesse');
                
                // Configuration de la navigation clavier pour l'accessibilité
                document.addEventListener('keydown', (event) => {
                    try {
                        if (event.key === 'ArrowDown' || event.key === 'PageDown') {
                            const sections = document.querySelectorAll('.emotion-container');
                            const activeSection = document.querySelector('.emotion-container.active');
                            
                            if (activeSection) {
                                const index = Array.from(sections).indexOf(activeSection);
                                if (index < sections.length - 1) {
                                    sections[index + 1].scrollIntoView({ behavior: 'smooth' });
                                }
                            }
                        } else if (event.key === 'ArrowUp' || event.key === 'PageUp') {
                            const sections = document.querySelectorAll('.emotion-container');
                            const activeSection = document.querySelector('.emotion-container.active');
                            
                            if (activeSection) {
                                const index = Array.from(sections).indexOf(activeSection);
                                if (index > 0) {
                                    sections[index - 1].scrollIntoView({ behavior: 'smooth' });
                                }
                            }
                        }
                    } catch (error) {
                        console.error("Erreur dans le gestionnaire de clavier:", error);
                    }
                });

                // Amélioration de l'expérience avec des contrôles clavier pour la narration
                document.addEventListener('keydown', (event) => {
                    try {
                        if (event.key === ' ' || event.code === 'Space') {
                            const activeSection = document.querySelector('.emotion-container.active');
                            if (activeSection) {
                                const sectionId = activeSection.id;
                                const state = storyStates[sectionId];
                                
                                if (state) {
                                    // Avancer à la phase suivante
                                    if (state.currentPhase < 3) {
                                        state.currentPhase++;
                                        state.phaseTime = 0;
                                        updateTimelineMarkers(sectionId, state.currentPhase);
                                        updateNarrationText(sectionId, state.currentPhase);
                                    }
                                }
                            }
                            event.preventDefault(); // Empêcher le défilement par défaut
                        }
                    } catch (error) {
                        console.error("Erreur dans le gestionnaire d'espace:", error);
                    }
                });
                
                // Ajout d'effets spéciaux basés sur le mouvement de la souris
                document.addEventListener('mousemove', (event) => {
                    try {
                        const activeSection = document.querySelector('.emotion-container.active');
                        if (!activeSection) return;
                        
                        const sectionId = activeSection.id;
                        const mouseX = event.clientX;
                        const mouseY = event.clientY;
                        
                        // Différents effets pour chaque émotion
                        switch (sectionId) {
                            case 'tristesse':
                                // Création occasionnelle de gouttes de pluie où la souris se déplace
                                if (Math.random() < 0.05) {
                                    const raindrop = document.createElement('div');
                                    raindrop.style.position = 'absolute';
                                    raindrop.style.width = '2px';
                                    raindrop.style.height = '15px';
                                    raindrop.style.backgroundColor = 'rgba(180, 200, 255, 0.6)';
                                    raindrop.style.left = `${mouseX}px`;
                                    raindrop.style.top = `${mouseY}px`;
                                    raindrop.style.zIndex = '5';
                                    raindrop.style.pointerEvents = 'none';
                                    document.body.appendChild(raindrop);
                                    
                                    // Animation de la goutte de pluie qui tombe
                                    let yPos = mouseY;
                                    const fallInterval = setInterval(() => {
                                        yPos += 5;
                                        if (raindrop) {
                                            raindrop.style.top = `${yPos}px`;
                                        }
                                        
                                        if (yPos > window.innerHeight) {
                                            clearInterval(fallInterval);
                                            if (raindrop && raindrop.parentNode) {
                                                raindrop.parentNode.removeChild(raindrop);
                                            }
                                        }
                                    }, 20);
                                }
                                break;
                            
                            case 'colere':
                                // Création d'un effet d'étincelle sous la souris
                                if (Math.random() < 0.1) {
                                    const spark = document.createElement('div');
                                    spark.style.position = 'absolute';
                                    spark.style.width = `${3 + Math.random() * 5}px`;
                                    spark.style.height = `${3 + Math.random() * 5}px`;
                                    spark.style.backgroundColor = `rgba(255, ${150 + Math.random() * 100}, 0, 0.7)`;
                                    spark.style.borderRadius = '50%';
                                    spark.style.left = `${mouseX}px`;
                                    spark.style.top = `${mouseY}px`;
                                    spark.style.zIndex = '5';
                                    spark.style.pointerEvents = 'none';
                                    spark.style.boxShadow = '0 0 10px rgba(255, 200, 0, 0.7)';
                                    document.body.appendChild(spark);
                                    
                                    // Animation de l'étincelle
                                    let opacity = 1;
                                    let size = 1;
                                    const sparkInterval = setInterval(() => {
                                        opacity -= 0.05;
                                        size += 0.2;
                                        if (spark) {
                                            spark.style.opacity = opacity.toString();
                                            spark.style.transform = `scale(${size})`;
                                        }
                                        
                                        if (opacity <= 0) {
                                            clearInterval(sparkInterval);
                                            if (spark && spark.parentNode) {
                                                spark.parentNode.removeChild(spark);
                                            }
                                        }
                                    }, 20);
                                }
                                break;
                            
                            case 'degout':
                                // Création d'un léger effet de brume verte près de la souris
                                if (Math.random() < 0.05) {
                                    const mist = document.createElement('div');
                                    mist.style.position = 'absolute';
                                    mist.style.width = `${20 + Math.random() * 30}px`;
                                    mist.style.height = `${20 + Math.random() * 30}px`;
                                    mist.style.backgroundColor = `rgba(${100 + Math.random() * 50}, ${150 + Math.random() * 50}, ${20 + Math.random() * 50}, 0.2)`;
                                    mist.style.borderRadius = '50%';
                                    mist.style.left = `${mouseX - 15}px`;
                                    mist.style.top = `${mouseY - 15}px`;
                                    mist.style.zIndex = '5';
                                    mist.style.pointerEvents = 'none';
                                    mist.style.filter = 'blur(5px)';
                                    document.body.appendChild(mist);
                                    
                                    // Animation de la brume
                                    let opacity = 0.2;
                                    const mistInterval = setInterval(() => {
                                        opacity -= 0.01;
                                        if (mist) {
                                            mist.style.opacity = opacity.toString();
                                        }
                                        
                                        if (opacity <= 0) {
                                            clearInterval(mistInterval);
                                            if (mist && mist.parentNode) {
                                                mist.parentNode.removeChild(mist);
                                            }
                                        }
                                    }, 50);
                                }
                                break;
                        }
                    } catch (error) {
                        console.error("Erreur dans le gestionnaire de souris:", error);
                    }
                });

                // Force la fin du chargement après un délai si ce n'est pas déjà fait
                setTimeout(() => {
                    console.log("Vérification du chargement...");
                    const loadingElement = document.getElementById('loading');
                    if (loadingElement && loadingElement.style.display !== 'none') {
                        console.log("Forçage de la fin du chargement après délai...");
                        loadingForceComplete = true;
                        completeLoading();
                    }
                }, 10000); // 10 secondes
                
            } catch (error) {
                console.error("Erreur globale dans DOMContentLoaded:", error);
                
                // Affichage d'un message d'erreur mais poursuite quand même
                const errorMessage = document.createElement('div');
                errorMessage.textContent = "Certains éléments n'ont pas pu être chargés, mais l'expérience va continuer.";
                errorMessage.style.color = "red";
                errorMessage.style.margin = "10px 0";
                
                const loadingElement = document.getElementById('loading');
                if (loadingElement) {
                    loadingElement.appendChild(errorMessage);
                    
                    // Masquage de l'écran de chargement après un délai
                    setTimeout(() => {
                        loadingElement.style.display = 'none';
                    }, 3000);
                }
            }
        });

        // Effet caché - effet spécial lorsqu'on tape le nom d'une émotion
        let typedKeys = '';
        document.addEventListener('keypress', (event) => {
            try {
                typedKeys += event.key.toLowerCase();
                
                // Vérification des noms d'émotions
                ['tristesse', 'colere', 'degout'].forEach(emotion => {
                    if (typedKeys.includes(emotion)) {
                        // Création d'un effet spécial
                        const specialEffect = document.createElement('div');
                        specialEffect.style.position = 'fixed';
                        specialEffect.style.top = '0';
                        specialEffect.style.left = '0';
                        specialEffect.style.width = '100%';
                        specialEffect.style.height = '100%';
                        specialEffect.style.backgroundColor = emotion === 'tristesse' ? 'rgba(100, 149, 237, 0.3)' : 
                                                          emotion === 'colere' ? 'rgba(255, 69, 0, 0.3)' : 
                                                          'rgba(154, 205, 50, 0.3)';
                        specialEffect.style.zIndex = '100';
                        specialEffect.style.pointerEvents = 'none';
                        specialEffect.style.opacity = '0';
                        specialEffect.style.transition = 'opacity 0.5s';
                        document.body.appendChild(specialEffect);
                        
                        // Affichage du nom de l'émotion
                        const emotionText = document.createElement('div');
                        emotionText.textContent = emotion.toUpperCase();
                        emotionText.style.position = 'fixed';
                        emotionText.style.top = '50%';
                        emotionText.style.left = '50%';
                        emotionText.style.transform = 'translate(-50%, -50%)';
                        emotionText.style.fontSize = '72px';
                        emotionText.style.color = 'white';
                        emotionText.style.textShadow = '0 0 20px rgba(0, 0, 0, 0.7)';
                        emotionText.style.fontWeight = 'bold';
                        specialEffect.appendChild(emotionText);
                        
                        // Affichage de l'effet
                        setTimeout(() => {
                            specialEffect.style.opacity = '1';
                            
                            // Navigation vers la section d'émotion
                            const section = document.getElementById(emotion);
                            if (section) {
                                section.scrollIntoView({ behavior: 'smooth' });
                            }
                            
                            // Masquage de l'effet
                            setTimeout(() => {
                                specialEffect.style.opacity = '0';
                                
                                // Suppression de l'élément après la transition
                                setTimeout(() => {
                                    if (specialEffect.parentNode) {
                                        specialEffect.parentNode.removeChild(specialEffect);
                                    }
                                }, 500);
                            }, 1500);
                        }, 10);
                        
                        // Réinitialisation des touches tapées
                        typedKeys = '';
                    }
                });
                
                // Limitation de la longueur des touches suivies
                if (typedKeys.length > 20) {
                    typedKeys = typedKeys.substring(typedKeys.length - 20);
                }
            } catch (error) {
                console.error("Erreur dans le gestionnaire de frappe:", error);
                typedKeys = ''; // Réinitialisation en cas d'erreur
            }
        });
    </script>
</body>
</html>